Config = {maxHeartbeats := 65536, timeout := 10, solverConfig = native, logFile := evalOut.txt}

Testing || CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.IsFilteredOrEmpty C] {D : Type u₁}
  [inst_2 : CategoryTheory.Category.{v₁, u₁} D] (R : CategoryTheory.Functor C D) [inst : R.IsRightAdjoint],
  CategoryTheory.IsFilteredOrEmpty D
Result.exception ::
Duper saturated

Testing || IsCoprime.of_mul_add_right_left : ∀ {R : Type u} [inst : CommSemiring R] {x y z : R}, IsCoprime (z * y + x) y → IsCoprime x y
Result.success

Testing || CategoryTheory.evaluation_obj_obj : ∀ (C : Type u₁) [inst : CategoryTheory.Category.{v₁, u₁} C] (D : Type u₂) [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  (X : C) (F : CategoryTheory.Functor C D), ((CategoryTheory.evaluation C D).obj X).obj F = F.obj X
Result.success

Testing || add_le_of_le_tsub_right_of_le : ∀ {α : Type u_1} [inst : AddCommSemigroup α] [inst_1 : PartialOrder α] [inst_2 : ExistsAddOfLE α]
  [inst_3 : AddLeftMono α] [inst_4 : Sub α] [inst_5 : OrderedSub α] {a b c : α}, b ≤ c → a ≤ c - b → a + b ≤ c
Result.success

Testing || Matrix.Nondegenerate.exists_not_ortho_of_ne_zero : ∀ {m : Type u_1} {R : Type u_2} [inst : Fintype m] [inst_1 : CommRing R] {M : Matrix m m R},
  M.Nondegenerate → ∀ {v : m → R}, v ≠ 0 → ∃ w, Matrix.dotProduct v (M.mulVec w) ≠ 0
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #0, (∀ x1 : (#1 → #2), (∀ x2 : #1, ((!4 (λx3 : #1, (x0 x2 x3)) x1) = (!5 x0 x1 x2))))) is not type correct

Testing || NonUnitalSubring.closure_eq_of_le : ∀ {R : Type u} [inst : NonUnitalNonAssocRing R] {s : Set R} {t : NonUnitalSubring R},
  s ⊆ ↑t → t ≤ NonUnitalSubring.closure s → NonUnitalSubring.closure s = t
Result.success

Testing || UInt32.intCast_def : ∀ (z : ℤ), ↑z = { toBitVec := ↑z }
Result.success

Testing || MeasureTheory.SignedMeasure.rnDeriv_sub : ∀ {α : Type u_1} {m : MeasurableSpace α} (s t : MeasureTheory.SignedMeasure α) (μ : MeasureTheory.Measure α)
  [inst : s.HaveLebesgueDecomposition μ] [inst : t.HaveLebesgueDecomposition μ]
  [hst : (s - t).HaveLebesgueDecomposition μ], (s - t).rnDeriv μ =ᵐ[μ] s.rnDeriv μ - t.rnDeriv μ
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.foldlIdx_eq_foldlIdxSpec : ∀ {α : Type u} {β : Type v} (f : ℕ → α → β → α) (a : α) (bs : List β) (start : ℕ),
  List.foldlIdx f a bs start = List.foldlIdxSpec f a bs start
Result.exception ::
Duper saturated

Testing || Subring.coe_zero : ∀ {R : Type u} [inst : Ring R] (s : Subring R), ↑0 = 0
Result.success

Testing || Std.DHashMap.Internal.Raw₀.getKey?_eq_getKey?ₘ : ∀ {α : Type u} {β : α → Type v} [inst : BEq α] [inst_1 : Hashable α] (m : Std.DHashMap.Internal.Raw₀ α β) (a : α),
  m.getKey? a = m.getKey?ₘ a
Result.success

Testing || Multiset.map_univ_coeEmbedding : ∀ {α : Type u_1} [inst : DecidableEq α] (m : Multiset α), Finset.map m.coeEmbedding Finset.univ = m.toEnumFinset
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.univ`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Ring.multichoose_zero_right' : ∀ {R : Type u_1} [inst : AddCommMonoid R] [inst_1 : Pow R ℕ] [inst_2 : BinomialRing R] (r : R),
  Ring.multichoose r 0 = r ^ 0
Result.exception ::
Duper saturated

Testing || Filter.EventuallyEq.gradient : ∀ {𝕜 : Type u_1} {F : Type u_2} [inst : RCLike 𝕜] [inst_1 : NormedAddCommGroup F] [inst_2 : InnerProductSpace 𝕜 F]
  [inst_3 : CompleteSpace F] {f : F → 𝕜} {x : F} {f₁ : F → 𝕜}, f₁ =ᶠ[nhds x] f → gradient f₁ =ᶠ[nhds x] gradient f
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Matrix.PosSemidef.eq_of_sq_eq_sq : ∀ {n : Type u_2} {𝕜 : Type u_4} [inst : Fintype n] [inst_1 : RCLike 𝕜] [inst_2 : DecidableEq n] {A : Matrix n n 𝕜},
  A.PosSemidef → ∀ {B : Matrix n n 𝕜}, B.PosSemidef → A ^ 2 = B ^ 2 → A = B
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || minpoly.coeff_zero_ne_zero : ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},
  IsIntegral A x → x ≠ 0 → (minpoly A x).coeff 0 ≠ 0
Result.success

Testing || List.cons_subperm_of_not_mem_of_mem : ∀ {α : Type u_1} {a : α} {l₁ l₂ : List α}, a ∉ l₁ → a ∈ l₂ → l₁.Subperm l₂ → (a :: l₁).Subperm l₂
Result.exception ::
(deterministic) timeout at `«forward demodulation»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || LinearMap.BilinForm.IsSymm.eq : ∀ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]
  {B : LinearMap.BilinForm R M}, B.IsSymm → ∀ (x y : M), (B x) y = (B y) x
Result.exception ::
Duper saturated

Testing || CategoryTheory.Limits.IsImage.isoExt_inv_m : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} {f : X ⟶ Y}
  {F F' : CategoryTheory.Limits.MonoFactorisation f} (hF : CategoryTheory.Limits.IsImage F)
  (hF' : CategoryTheory.Limits.IsImage F'), CategoryTheory.CategoryStruct.comp (hF.isoExt hF').inv F.m = F'.m
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.lift x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Equiv.curry_apply : ∀ (α : Type u_9) (β : Type u_10) (γ : Sort u_11), ⇑(Equiv.curry α β γ) = Function.curry
Result.exception ::
Duper saturated

Testing || dif_neg : ∀ {c : Prop} {h : Decidable c} (hnc : ¬c) {α : Sort u} {t : c → α} {e : ¬c → α}, dite c t e = e hnc
Result.exception ::
Duper saturated

Testing || Ordinal.one_CNF : ∀ {o : Ordinal.{u_1}}, o ≠ 0 → Ordinal.CNF 1 o = [(0, o)]
Result.exception ::
Duper saturated

Testing || ContinuousAffineMap.sub_contLinear : ∀ {R : Type u_2} {V : Type u_3} {W : Type u_4} {P : Type u_6} [inst : NormedAddCommGroup V] [inst_1 : MetricSpace P]
  [inst_2 : NormedAddTorsor V P] [inst_3 : NormedAddCommGroup W] [inst_4 : NormedField R] [inst_5 : NormedSpace R V]
  [inst_6 : NormedSpace R W] (f g : P →ᴬ[R] W), (f - g).contLinear = f.contLinear - g.contLinear
Result.success

Testing || AddEquiv.instEquivLike.proof_2 : ∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (f : M ≃+ N), Function.RightInverse f.invFun f.toFun
Result.success

Testing || List.mapIdx_set : ∀ {α : Type u_1} {α_1 : Type u_2} {f : ℕ → α → α_1} {l : List α} {i : ℕ} {a : α},
  List.mapIdx f (l.set i a) = (List.mapIdx f l).set i (f i a)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || SetTheory.PGame.insertRight_le : ∀ (x x' : SetTheory.PGame), x.insertRight x' ≤ x
Result.exception ::
Duper saturated

Testing || nhdsAdjoint_nhds : ∀ {α : Type u} (a : α) (f : Filter α), nhds a = pure a ⊔ f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `nhdsAdjoint x_0 x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || instUniqueAddUnitsOfSubsingleton.proof_1 : ∀ {M : Type u_1} [inst : AddMonoid M] [inst_1 : Subsingleton M] (x : AddUnits M), x = 0
Result.exception ::
Duper saturated

Testing || Cardinal.mk_coe_finset : ∀ {α : Type u} {s : Finset α}, Cardinal.mk { x // x ∈ s } = ↑s.card
Result.exception ::
Duper saturated

Testing || CategoryTheory.Sieve.pullback_ofObjects_eq_top : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {I : Type u_1} (Y : I → C) {X : C} {i : I},
  (X ⟶ Y i) → CategoryTheory.Sieve.ofObjects Y X = ⊤
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.Presieve X is not a `∀`

Testing || Set.iUnion_option : ∀ {α : Type u_1} {ι : Type u_11} (s : Option ι → Set α), ⋃ o, s o = s none ∪ ⋃ i, s (some i)
Result.success

Testing || Ergodic.ae_empty_or_univ_of_preimage_ae_le' : ∀ {α : Type u_1} {m : MeasurableSpace α} {s : Set α} {f : α → α} {μ : MeasureTheory.Measure α},
  Ergodic f μ → MeasureTheory.NullMeasurableSet s μ → f ⁻¹' s ≤ᵐ[μ] s → μ s ≠ ⊤ → s =ᵐ[μ] ∅ ∨ s =ᵐ[μ] Set.univ
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (!5 (!6 !2) (!7 !1 !4) !4) is not type correct

Testing || MeasureTheory.Measure.rnDeriv_smul_right_of_ne_top : ∀ {α : Type u_1} {m : MeasurableSpace α} (ν μ : MeasureTheory.Measure α) [inst : MeasureTheory.IsFiniteMeasure ν]
  [inst : ν.HaveLebesgueDecomposition μ] {r : ENNReal}, r ≠ 0 → r ≠ ⊤ → ν.rnDeriv (r • μ) =ᵐ[μ] r⁻¹ • ν.rnDeriv μ
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || PartialHomeomorph.coe_trans_symm : ∀ {X : Type u_1} {Y : Type u_3} {Z : Type u_5} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y]
  [inst_2 : TopologicalSpace Z] (e : PartialHomeomorph X Y) (e' : PartialHomeomorph Y Z),
  ↑(e.trans e').symm = ↑e.symm ∘ ↑e'.symm
Result.exception ::
Duper saturated

Testing || Set.bounded_lt_Iic : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : NoMaxOrder α] (a : α), Set.Bounded (fun x1 x2 => x1 < x2) (Set.Iic a)
Result.success

Testing || MeasureTheory.eLpNorm_const_smul_le : ∀ {α : Type u_1} {F : Type u_3} {m0 : MeasurableSpace α} {p : ENNReal} {μ : MeasureTheory.Measure α}
  [inst : NormedAddCommGroup F] {𝕜 : Type u_5} [inst_1 : NormedRing 𝕜] [inst_2 : MulActionWithZero 𝕜 F]
  [inst_3 : BoundedSMul 𝕜 F] {c : 𝕜} {f : α → F}, MeasureTheory.eLpNorm (c • f) p μ ≤ ‖c‖₊ • MeasureTheory.eLpNorm f p μ
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `SMulZeroClass.toSMul`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Iso.isIso_inv : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (e : X ≅ Y), CategoryTheory.IsIso e.inv
Result.exception ::
Duper saturated

Testing || IntermediateField.adjoin_univ : ∀ (F : Type u_3) (E : Type u_4) [inst : Field F] [inst_1 : Field E] [inst_2 : Algebra F E],
  IntermediateField.adjoin F Set.univ = ⊤
Result.exception ::
Duper saturated

Testing || NonemptyInterval.snd_add : ∀ {α : Type u_2} [inst : Preorder α] [inst_1 : Add α] [inst_2 : AddLeftMono α] [inst_3 : AddRightMono α]
  (s t : NonemptyInterval α), (s + t).toProd.2 = s.toProd.2 + t.toProd.2
Result.success

Testing || CategoryTheory.Bicategory.RightExtension.w_assoc : ∀ {B : Type u} [inst : CategoryTheory.Bicategory B] {a b c : B} {f : a ⟶ b} {g : a ⟶ c}
  {s t : CategoryTheory.Bicategory.RightExtension f g} (η : s ⟶ t) {Z : a ⟶ c} (h : g ⟶ Z),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f η.left)
      (CategoryTheory.CategoryStruct.comp t.counit h) =
    CategoryTheory.CategoryStruct.comp s.counit h
Result.exception ::
(deterministic) timeout at `printProof`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Disjoint.subset_compl_left : ∀ {α : Type u} {s t : Set α}, Disjoint t s → s ⊆ tᶜ
Result.success

Testing || IsAntichain.flip : ∀ {α : Type u_1} {r : α → α → Prop} {s : Set α}, IsAntichain r s → IsAntichain (flip r) s
Result.exception ::
Duper saturated

Testing || LowerAdjoint.closure_iUnion_closure : ∀ {α : Type u_1} {ι : Sort u_2} {β : Type u_4} [inst : SetLike α β] (l : LowerAdjoint SetLike.coe) (f : ι → α),
  l.toFun (⋃ i, ↑(l.toFun ↑(f i))) = l.toFun (⋃ i, ↑(f i))
Result.exception ::
Duper saturated

Testing || Subsemiring.mem_closure_iff : ∀ {R : Type u} [inst : NonAssocSemiring R] {s : Set R} {x : R},
  x ∈ Subsemiring.closure s ↔ x ∈ AddSubmonoid.closure ↑(Submonoid.closure s)
Result.success

Testing || Real.deriv_cos : ∀ {x : ℝ}, deriv Real.cos x = -Real.sin x
Result.success

Testing || Pell.IsFundamental.mul_inv_x_lt_x : ∀ {d : ℤ} {a₁ : Pell.Solution₁ d},
  Pell.IsFundamental a₁ → ∀ {a : Pell.Solution₁ d}, 1 < a.x → 0 < a.y → (a * a₁⁻¹).x < a.x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `HasDistribNeg.toInvolutiveNeg`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Complex.cos_conj : ∀ (x : ℂ), Complex.cos ((starRingEnd ℂ) x) = (starRingEnd ℂ) (Complex.cos x)
Result.success

Testing || MeasureTheory.Supermartingale.set_integral_le : ∀ {Ω : Type u_1} {ι : Type u_3} [inst : Preorder ι] {m0 : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω}
  {ℱ : MeasureTheory.Filtration ι m0} [inst_1 : MeasureTheory.SigmaFiniteFiltration μ ℱ] {f : ι → Ω → ℝ},
  MeasureTheory.Supermartingale f ℱ μ →
    ∀ {i j : ι}, i ≤ j → ∀ {s : Set Ω}, MeasurableSet s → ∫ (ω : Ω) in s, f j ω ∂μ ≤ ∫ (ω : Ω) in s, f i ω ∂μ
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `↑x_1 i`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AddAction.pretransitive_iff_unique_quotient_of_nonempty : ∀ (G : Type u_1) (α : Type u_2) [inst : AddGroup G] [inst_1 : AddAction G α] [inst_2 : Nonempty α],
  AddAction.IsPretransitive G α ↔ Nonempty (Unique (AddAction.orbitRel.Quotient G α))
Result.exception ::
Duper saturated

Testing || InnerProductGeometry.norm_sub_eq_add_norm_of_angle_eq_pi : ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},
  InnerProductGeometry.angle x y = Real.pi → ‖x - y‖ = ‖x‖ + ‖y‖
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Finset.union_sdiff_cancel_left : ∀ {α : Type u_1} [inst : DecidableEq α] {s t : Finset α}, Disjoint s t → (s ∪ t) \ s = t
Result.success

Testing || Module.Presentation.finite : ∀ {A : Type u} [inst : Ring A] {M : Type v} [inst_1 : AddCommGroup M] [inst_2 : _root_.Module A M]
  (pres : Module.Presentation A M) [inst_3 : Finite pres.G], Module.Finite A M
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.toSolution`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || LowerSet.mem_iInf₂_iff : ∀ {α : Type u_1} {ι : Sort u_4} {κ : ι → Sort u_5} [inst : LE α] {a : α} {f : (i : ι) → κ i → LowerSet α},
  a ∈ ⨅ i, ⨅ j, f i j ↔ ∀ (i : ι) (j : κ i), a ∈ f i j
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type κ i✝ of λ binder contains bound variables

Testing || Finsupp.smul_single' : ∀ {α : Type u_1} {R : Type u_11} {x : Semiring R} (c : R) (a : α) (b : R), (c • fun₀ | a => b) = fun₀ | a => c * b
Result.success

Testing || Commute.inv : ∀ {G : Type u_1} [inst : DivisionMonoid G] {a b : G}, Commute a b → (a * b)⁻¹ = a⁻¹ * b⁻¹
Result.success

Testing || Finset.Nonempty.piFinset_const : ∀ {β : Type u_2} {ι : Type u_5} [inst : Fintype ι] [inst_1 : DecidableEq ι] {s : Finset β},
  s.Nonempty → (Fintype.piFinset fun x => s).Nonempty
Result.success

Testing || List.cons_sublist_cons' : ∀ {α : Type u} {l₁ l₂ : List α} {a b : α}, (a :: l₁).Sublist (b :: l₂) ↔ (a :: l₁).Sublist l₂ ∨ a = b ∧ l₁.Sublist l₂
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Set.image_subset_sups_right : ∀ {α : Type u_2} [inst : SemilatticeSup α] {s t : Set α} {a : α}, a ∈ s → (fun x1 x2 => x1 ⊔ x2) a '' t ⊆ s ⊻ t
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!9 (!11 (!4 (λx0 : #1, (!5 !2 x0)) !6)) (!7 !1 !6)) = (!3 (!4 (λx0 : #1, (!5 !2 x0)) !6) (!7 !1 !6))) is not type correct

Testing || FractionalIdeal.mem_extended_iff : ∀ {A : Type u_1} [inst : CommRing A] {B : Type u_2} [inst_1 : CommRing B] {f : A →+* B} {K : Type u_3} {M : Submonoid A}
  [inst_2 : CommRing K] [inst_3 : Algebra A K] [inst_4 : IsLocalization M K] (L : Type u_4) {N : Submonoid B}
  [inst_5 : CommRing L] [inst_6 : Algebra B L] [inst_7 : IsLocalization N L] (hf : M ≤ Submonoid.comap f N)
  (I : FractionalIdeal M K) (x : L),
  x ∈ FractionalIdeal.extended L hf I ↔ x ∈ Submodule.span B (⇑(IsLocalization.map L f hf) '' ↑I)
Result.success

Testing || Bimod.regular_actRight : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] (A : Mon_ C),
  (Bimod.regular A).actRight = A.mul
Result.success

Testing || TrivSqZeroExt.map_comp_map : ∀ {R' : Type u} {M : Type v} [inst : CommSemiring R'] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R' M]
  [inst_3 : _root_.Module R'ᵐᵒᵖ M] [inst_4 : IsCentralScalar R' M] {N : Type u_3} {P : Type u_4}
  [inst_5 : AddCommMonoid N] [inst_6 : _root_.Module R' N] [inst_7 : _root_.Module R'ᵐᵒᵖ N]
  [inst_8 : IsCentralScalar R' N] [inst_9 : AddCommMonoid P] [inst_10 : _root_.Module R' P]
  [inst_11 : _root_.Module R'ᵐᵒᵖ P] [inst_12 : IsCentralScalar R' P] (f : M →ₗ[R'] N) (g : N →ₗ[R'] P),
  TrivSqZeroExt.map (g ∘ₗ f) = (TrivSqZeroExt.map g).comp (TrivSqZeroExt.map f)
Result.exception ::
Duper saturated

Testing || StrictConvexOn.slope_lt_of_hasDerivAt : ∀ {S : Set ℝ} {f : ℝ → ℝ} {x y f' : ℝ},
  StrictConvexOn ℝ S f → x ∈ S → y ∈ S → x < y → HasDerivAt f f' y → slope f x y < f'
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!3 (!12 !4) !5) = (!6 !4 !5)) is not type correct

Testing || AddUnits.min_val : ∀ {α : Type u_1} [inst : AddMonoid α] [inst_1 : LinearOrder α] {a b : AddUnits α}, ↑(a ⊓ b) = ↑a ⊓ ↑b
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || FreeCommRing.isSupported_add : ∀ {α : Type u} {x y : FreeCommRing α} {s : Set α}, x.IsSupported s → y.IsSupported s → (x + y).IsSupported s
Result.success

Testing || IsPGroup.exists_fixed_point_of_prime_dvd_card_of_fixed_point : ∀ {p : ℕ} {G : Type u_1} [inst : Group G],
  IsPGroup p G →
    ∀ [hp : Fact (Nat.Prime p)] (α : Type u_2) [inst_1 : MulAction G α] [inst_2 : Finite α],
      p ∣ Nat.card α → ∀ {a : α}, a ∈ MulAction.fixedPoints G α → ∃ b ∈ MulAction.fixedPoints G α, a ≠ b
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #2, (∀ x1 : #2, ((!8 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || ContDiffBump.neg : ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : HasContDiffBump E]
  (f : ContDiffBump 0) (x : E), ↑f (-x) = ↑f x
Result.success

Testing || IsAddSubgroup.normalizer_isAddSubgroup : ∀ {G : Type u_1} [inst : AddGroup G] (s : Set G), IsAddSubgroup (IsAddSubgroup.addNormalizer s)
Result.exception ::
Duper saturated

Testing || SubmonoidClass.finsupp_prod_mem : ∀ {α : Type u_1} {M : Type u_8} {N : Type u_10} [inst : _root_.Zero M] [inst_1 : CommMonoid N] {S : Type u_16}
  [inst_2 : SetLike S N] [inst_3 : SubmonoidClass S N] (s : S) (f : α →₀ M) (g : α → M → N),
  (∀ (c : α), f c ≠ 0 → g c (f c) ∈ s) → f.prod g ∈ s
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || BitVec.sub_add_bmod_cancel : ∀ {w : ℕ} {x y : BitVec w}, (↑(2 ^ w) - ↑y.toNat + ↑x.toNat).bmod (2 ^ w) = (↑x.toNat - ↑y.toNat).bmod (2 ^ w)
Result.exception ::
(deterministic) timeout at `printProof`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Set.einfsep_iUnion_mem_option : ∀ {α : Type u_1} [inst : EDist α] {ι : Type u_3} (o : Option ι) (s : ι → Set α),
  (⋃ i ∈ o, s i).einfsep = ⨅ i ∈ o, (s i).einfsep
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type i✝ ∈ o of λ binder contains bound variables

Testing || bddAbove_neg : ∀ {G : Type u_2} [inst : AddGroup G] [inst_1 : Preorder G] [inst_2 : AddLeftMono G] [inst_3 : AddRightMono G]
  {s : Set G}, BddAbove (-s) ↔ BddBelow s
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Sat.Fmla.subsumes_left : ∀ (f f₁ f₂ : Sat.Fmla), f.subsumes (f₁.and f₂) → f.subsumes f₁
Result.exception ::
Duper saturated

Testing || OrderHom.snd_coe : ∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] (self : α × β), OrderHom.snd self = self.2
Result.success

Testing || Quaternion.imK_snd_dualNumberEquiv : ∀ {R : Type u_1} [inst : CommRing R] (q : Quaternion (DualNumber R)),
  (TrivSqZeroExt.snd (Quaternion.dualNumberEquiv q)).imK = TrivSqZeroExt.snd q.imK
Result.success

Testing || AddCommMagma.IsRightCancelAdd.toIsCancelAdd : ∀ (G : Type u) [inst : AddCommMagma G] [inst_1 : IsRightCancelAdd G], IsCancelAdd G
Result.exception ::
Duper saturated

Testing || Finset.sum_smul_vsub_const_eq_affineCombination_vsub : ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module k V]
  [S : AddTorsor V P] {ι : Type u_4} (s : Finset ι) (w : ι → k) (p₁ : ι → P) (p₂ : P),
  ∑ i ∈ s, w i = 1 → ∑ i ∈ s, w i • (p₁ i -ᵥ p₂) = (Finset.affineCombination k s p₁) w -ᵥ p₂
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Limits.hasTerminalChangeUniverse : ∀ (C : Type u₁) [inst : CategoryTheory.Category.{v₁, u₁} C]
  [h : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete PEmpty.{w + 1}) C],
  CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete PEmpty.{w' + 1}) C
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Algebra.IsStandardSmooth.localization_away : ∀ {R : Type u} {S : Type v} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] (r : R)
  [inst_3 : IsLocalization.Away r S], Algebra.IsStandardSmooth R S
Result.exception ::
Duper saturated

Testing || IsCoprime.dvd_of_dvd_mul_right : ∀ {R : Type u} [inst : CommSemiring R] {x y z : R}, IsCoprime x z → x ∣ y * z → x ∣ y
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || UInt32.toUInt16_toNat : ∀ (x : UInt32), x.toUInt16.toNat = x.toNat % 2 ^ 16
Result.success

Testing || Std.Tactic.BVDecide.Normalize.Bool.or_elim : ∀ (a b : Bool), (a || b) = !(!a && !b)
Result.success

Testing || MeasureTheory.SimpleFunc.pair_apply : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : MeasurableSpace α] (f : MeasureTheory.SimpleFunc α β)
  (g : MeasureTheory.SimpleFunc α γ) (a : α), (f.pair g) a = (f a, g a)
Result.success

Testing || _private.Mathlib.NumberTheory.FermatPsp.0.Nat.b_id_helper : ∀ {a b : ℕ}, 2 ≤ a → 2 < b → 2 ≤ (a ^ b + 1) / (a + 1)
Result.exception ::
(deterministic) timeout at `«forward demodulation»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ofLex_inj : ∀ {α : Type u_1} {a b : Lex α}, ofLex a = ofLex b ↔ a = b
Result.success

Testing || compactlySupported_eq_top : ∀ {α : Type u_1} {γ : Type u_2} [inst : TopologicalSpace α] [inst_1 : NonUnitalNormedRing γ] [inst_2 : CompactSpace α],
  compactlySupported α γ = ⊤
Result.success

Testing || LinearIsometry.map_orthogonalProjection' : ∀ {𝕜 : Type u_1} [inst : RCLike 𝕜] {E : Type u_4} {E' : Type u_5} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedAddCommGroup E'] [inst_3 : InnerProductSpace 𝕜 E] [inst_4 : InnerProductSpace 𝕜 E'] (f : E →ₗᵢ[𝕜] E')
  (p : Submodule 𝕜 E) [inst_5 : HasOrthogonalProjection p] [inst_6 : HasOrthogonalProjection (Submodule.map f p)]
  (x : E), f ↑((orthogonalProjection p) x) = ↑((orthogonalProjection (Submodule.map f p)) (f x))
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ProbabilityTheory.Kernel.iIndepSets.ae_isProbabilityMeasure : ∀ {α : Type u_1} {Ω : Type u_2} {ι : Type u_3} {_mα : MeasurableSpace α} {_mΩ : MeasurableSpace Ω}
  {κ : ProbabilityTheory.Kernel α Ω} {μ : MeasureTheory.Measure α} {π : ι → Set (Set Ω)},
  ProbabilityTheory.Kernel.iIndepSets π κ μ → ∀ᵐ (a : α) ∂μ, MeasureTheory.IsProbabilityMeasure (κ a)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type i✝ ∈ s of λ binder contains bound variables

Testing || Real.exp_ne_zero : ∀ (x : ℝ), Real.exp x ≠ 0
Result.success

Testing || Profinite.NobelingProof.GoodProducts.maxToGood_injective : ∀ {I : Type u} (C : Set (I → Bool)) [inst : LinearOrder I] [inst_1 : WellFoundedLT I] {o : Ordinal.{u}}
  (hC : IsClosed C) (hsC : Profinite.NobelingProof.contained C (Order.succ o))
  (ho : o < Ordinal.type fun x1 x2 => x1 < x2)
  (h₁ :
    ⊤ ≤
      Submodule.span ℤ
        (Set.range
          (Profinite.NobelingProof.GoodProducts.eval
            (Profinite.NobelingProof.π C fun x => Profinite.NobelingProof.ord I x < o)))),
  Function.Injective (Profinite.NobelingProof.GoodProducts.MaxToGood C hC hsC ho h₁)
Result.exception ::
Duper saturated

Testing || StrictConvexOn.map_sum_eq_iff' : ∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_4} {ι : Type u_5} [inst : LinearOrderedField 𝕜] [inst_1 : AddCommGroup E]
  [inst_2 : OrderedAddCommGroup β] [inst_3 : _root_.Module 𝕜 E] [inst_4 : _root_.Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]
  {s : Set E} {f : E → β} {t : Finset ι} {w : ι → 𝕜} {p : ι → E},
  StrictConvexOn 𝕜 s f →
    (∀ i ∈ t, 0 ≤ w i) →
      ∑ i ∈ t, w i = 1 →
        (∀ i ∈ t, p i ∈ s) →
          (f (∑ i ∈ t, w i • p i) = ∑ i ∈ t, w i • f (p i) ↔ ∀ j ∈ t, w j ≠ 0 → p j = ∑ i ∈ t, w i • p i)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!25 !26 !27) = !0) is not type correct

Testing || RightCancelSemigroup.ext : ∀ {G : Type u} {x y : RightCancelSemigroup G}, Mul.mul = Mul.mul → x = y
Result.exception ::
Duper saturated

Testing || Finset.diffs_union_right : ∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : GeneralizedBooleanAlgebra α] {s t₁ t₂ : Finset α},
  s.diffs (t₁ ∪ t₂) = s.diffs t₁ ∪ s.diffs t₂
Result.success

Testing || CategoryTheory.Functor.relativelyRepresentable.symmetryIso_hom : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {F : CategoryTheory.Functor C D} {Y : D} {b : C} {f' : F.obj b ⟶ Y} (hf' : F.relativelyRepresentable f') {a : C}
  {g : F.obj a ⟶ Y} (hg : F.relativelyRepresentable g) [inst_2 : F.Full] [inst_3 : F.Faithful],
  (hf'.symmetryIso hg).hom = hf'.symmetry hg
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.MorphismProperty D is not a `∀`

Testing || Fin.rev_sub : ∀ {n : ℕ} (a b : Fin n), (a - b).rev = a.rev + b
Result.success

Testing || Std.Tactic.BVDecide.BVBinPred.eval_ult : ∀ {w : ℕ}, Std.Tactic.BVDecide.BVBinPred.ult.eval = BitVec.ult
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.sum_pos : ∀ {M : Type u_3} [inst : OrderedAddCommMonoid M] (l : List M), (∀ x ∈ l, 0 < x) → l ≠ [] → 0 < l.sum
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Ordinal.comp_familyOfBFamily' : ∀ {α : Type u_1} {β : Type u_2} {ι : Type u} (r : ι → ι → Prop) [inst : IsWellOrder ι r] {o : Ordinal.{u}}
  (ho : Ordinal.type r = o) (f : (a : Ordinal.{u}) → a < o → α) (g : α → β),
  g ∘ Ordinal.familyOfBFamily' r ho f = Ordinal.familyOfBFamily' r ho fun i hi => g (f i hi)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type i < o of λ binder contains bound variables

Testing || star_natCast_smul : ∀ {R : Type u_1} {M : Type u_2} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]
  [inst_3 : StarAddMonoid M] (n : ℕ) (x : M), star (↑n • x) = ↑n • star x
Result.exception ::
Duper saturated

Testing || SetTheory.PGame.fuzzy_of_fuzzy_of_equiv : ∀ {x y z : SetTheory.PGame}, x.Fuzzy y → y ≈ z → x.Fuzzy z
Result.exception ::
Duper saturated

Testing || LocallyConvexSpace.ofBases : ∀ (𝕜 : Type u_1) (E : Type u_2) [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E] [inst_2 : _root_.Module 𝕜 E]
  [inst_3 : TopologicalSpace E] {ι : Type u_3} (b : E → ι → Set E) (p : E → ι → Prop),
  (∀ (x : E), (nhds x).HasBasis (p x) (b x)) → (∀ (x : E) (i : ι), p x i → Convex 𝕜 (b x i)) → LocallyConvexSpace 𝕜 E
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #3, ((!6 x0 (λx1 : #0, (∀ x2 : #0, ((!9 x0 x2) → (∀ x3 : #4, (∀ x4 : #4, ((!8 !10 x3) → ((!8 !10 x4) → (((!11 x3 x4) = !12) → (!9 x0 (!13 (!14 x3 x1) (!14 x4 x2)))))))))))) = (!4 x0))) is not type correct

Testing || EulerProduct.eulerProduct : ∀ {R : Type u_1} [inst : NormedCommRing R] {f : ℕ → R} [inst_1 : CompleteSpace R],
  f 1 = 1 →
    (∀ {m n : ℕ}, m.Coprime n → f (m * n) = f m * f n) →
      (Summable fun x => ‖f x‖) →
        f 0 = 0 →
          Filter.Tendsto (fun n => ∏ p ∈ n.primesBelow, ∑' (e : ℕ), f (p ^ e)) Filter.atTop (nhds (∑' (n : ℕ), f n))
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : Nat, (∀ x1 : Nat, ((!20 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || Mathlib.Vector.get_ofFn : ∀ {α : Type u_1} {n : ℕ} (f : Fin n → α) (i : Fin n), (Mathlib.Vector.ofFn f).get i = f i
Result.exception ::
Duper saturated

Testing || CategoryTheory.ShortComplex.sub_τ₁ : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  {S₁ S₂ : CategoryTheory.ShortComplex C} (φ φ' : S₁ ⟶ S₂), (φ - φ').τ₁ = φ.τ₁ - φ'.τ₁
Result.success

Testing || MeasureTheory.Martingale.stoppedValue_ae_eq_restrict_eq : ∀ {Ω : Type u_1} {E : Type u_2} {m : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} [inst : NormedAddCommGroup E]
  [inst_1 : NormedSpace ℝ E] [inst_2 : CompleteSpace E] {ι : Type u_3} [inst_3 : LinearOrder ι]
  [inst_4 : TopologicalSpace ι] [inst_5 : OrderTopology ι] [inst_6 : FirstCountableTopology ι]
  {ℱ : MeasureTheory.Filtration ι m} [inst_7 : MeasureTheory.SigmaFiniteFiltration μ ℱ] {τ : Ω → ι} {f : ι → Ω → E}
  {n : ι},
  MeasureTheory.Martingale f ℱ μ →
    ∀ (hτ : MeasureTheory.IsStoppingTime ℱ τ) (hτ_le : ∀ (x : Ω), τ x ≤ n)
      [inst_8 : MeasureTheory.SigmaFinite (μ.trim ⋯)] (i : ι),
      MeasureTheory.stoppedValue f τ =ᵐ[μ.restrict {x | τ x = i}] MeasureTheory.condexp hτ.measurableSpace μ (f n)
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Set (Set Ω) is not a `∀`

Testing || Complex.sameRay_of_arg_eq : ∀ {x y : ℂ}, x.arg = y.arg → SameRay ℝ x y
Result.success

Testing || CategoryTheory.Limits.initial.to_comp : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.Limits.HasInitial C] {P Q : C}
  (f : P ⟶ Q),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.initial.to P) f = CategoryTheory.Limits.initial.to Q
Result.exception ::
Duper saturated

Testing || BoundedLatticeHom.id_comp : ∀ {α : Type u_3} {β : Type u_4} [inst : Lattice α] [inst_1 : Lattice β] [inst_2 : BoundedOrder α]
  [inst_3 : BoundedOrder β] (f : BoundedLatticeHom α β), (BoundedLatticeHom.id β).comp f = f
Result.success

Testing || Differentiable.analyticAt : ∀ {E : Type u} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] [inst_2 : CompleteSpace E] {f : ℂ → E},
  Differentiable ℂ f → ∀ (z : ℂ), AnalyticAt ℂ f z
Result.success

Testing || CompleteOrthogonalIdempotents.option : ∀ {R : Type u_1} [inst : Ring R] {I : Type u_3} {e : I → R} [inst_1 : Fintype I],
  OrthogonalIdempotents e → CompleteOrthogonalIdempotents fun x => x.elim (1 - ∑ i : I, e i) e
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.univ`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || QuaternionAlgebra.neg_mk : ∀ {R : Type u_3} {c₁ c₂ : R} [inst : Neg R] (a₁ a₂ a₃ a₄ : R),
  -{ re := a₁, imI := a₂, imJ := a₃, imK := a₄ } = { re := -a₁, imI := -a₂, imJ := -a₃, imK := -a₄ }
Result.success

Testing || Filter.eventually_gt_atTop : ∀ {α : Type u_3} [inst : Preorder α] [inst_1 : NoMaxOrder α] (a : α), ∀ᶠ (x : α) in Filter.atTop, a < x
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #1, (∀ x1 : #2, ((!1 x1 x0) = (!5 x0 x1)))) is not type correct

Testing || NNReal.iSup_mul_le : ∀ {ι : Sort u_2} {a : NNReal} {g : ι → NNReal} {h : NNReal}, (∀ (i : ι), g i * h ≤ a) → iSup g * h ≤ a
Result.success

Testing || Padic.AddValuation.map_add : ∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (x y : ℚ_[p]), x.addValuationDef ⊓ y.addValuationDef ≤ (x + y).addValuationDef
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `OrderTop.toTop`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || PNat.mod_add_div' : ∀ (m k : ℕ+), ↑(m.mod k) + m.div k * ↑k = ↑m
Result.success

Testing || CategoryTheory.SingleFunctors.shiftIso_add' : ∀ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_7, u_1} C]
  [inst_1 : CategoryTheory.Category.{u_6, u_2} D] {A : Type u_5} [inst_2 : AddMonoid A]
  [inst_3 : CategoryTheory.HasShift D A] (F : CategoryTheory.SingleFunctors C D A) (n m mn : A) (hnm : m + n = mn)
  (a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a''),
  F.shiftIso mn a a'' ⋯ =
    CategoryTheory.isoWhiskerLeft (F.functor a'') (CategoryTheory.shiftFunctorAdd' D m n mn hnm) ≪≫
      ((F.functor a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm ≪≫
        CategoryTheory.isoWhiskerRight (F.shiftIso m a' a'' ha'') (CategoryTheory.shiftFunctor D n) ≪≫
          F.shiftIso n a a' ha'
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `rfl`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || imaginaryPart_eq_neg_I_smul_skewAdjointPart : ∀ {A : Type u_1} [inst : AddCommGroup A] [inst_1 : _root_.Module ℂ A] [inst_2 : StarAddMonoid A]
  [inst_3 : StarModule ℂ A] (x : A), ↑(imaginaryPart x) = -Complex.I • ↑((skewAdjointPart ℝ) x)
Result.success

Testing || Submodule.toAddSubmonoid_eq : ∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]
  {p q : Submodule R M}, p.toAddSubmonoid = q.toAddSubmonoid ↔ p = q
Result.success

Testing || DFinsupp.equivFunOnFintype_symm_coe : ∀ {ι : Type u} {β : ι → Type v} [inst : (i : ι) → _root_.Zero (β i)] [inst_1 : Fintype ι] (f : Π₀ (i : ι), β i),
  DFinsupp.equivFunOnFintype.symm ⇑f = f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0 x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || _private.Mathlib.NumberTheory.Padics.Hensel.0.newton_seq_dist : ∀ {p : ℕ} [inst : Fact (Nat.Prime p)] {F : Polynomial ℤ_[p]} {a : ℤ_[p]}
  (hnorm : ‖Polynomial.eval a F‖ < ‖Polynomial.eval a (Polynomial.derivative F)‖ ^ 2) {n k : ℕ},
  n ≤ k →
    ‖newton_seq_gen hnorm k - newton_seq_gen hnorm n‖ ≤
      ‖Polynomial.eval a (Polynomial.derivative F)‖ * T_gen p F a ^ 2 ^ n
Result.exception ::
Duper saturated

Testing || Multiset.disjoint_add_right : ∀ {α : Type u_1} {s t u : Multiset α}, Disjoint s (t + u) ↔ Disjoint s t ∧ Disjoint s u
Result.success

Testing || List.Perm.symm : ∀ {α : Type u_1} {l₁ l₂ : List α}, l₁.Perm l₂ → l₂.Perm l₁
Result.exception ::
Duper saturated

Testing || CompleteLat.Iso.mk_hom_toFun : ∀ {α β : CompleteLat} (e : ↑α ≃o ↑β) (a : ↑α), (CompleteLat.Iso.mk e).hom.toFun a = e a
Result.success

Testing || PartENat.card_eq_zero_iff_empty : ∀ (α : Type u_3), PartENat.card α = 0 ↔ IsEmpty α
Result.exception ::
Duper saturated

Testing || NonemptyInterval.pure_fst : ∀ {α : Type u_1} [inst : Preorder α] (a : α), (NonemptyInterval.pure a).toProd.1 = a
Result.success

Testing || AlternatingMap.coe_multilinearMap_injective : ∀ {R : Type u_1} [inst : Semiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]
  {N : Type u_3} [inst_3 : AddCommMonoid N] [inst_4 : _root_.Module R N] {ι : Type u_7},
  Function.Injective AlternatingMap.toMultilinearMap
Result.exception ::
Duper saturated

Testing || FreeCommRing.isSupported_sub : ∀ {α : Type u} {x y : FreeCommRing α} {s : Set α}, x.IsSupported s → y.IsSupported s → (x - y).IsSupported s
Result.success

Testing || MeasureTheory.ae_of_all : ∀ {α : Type u_1} {F : Type u_3} [inst : FunLike F (Set α) ENNReal] [inst_1 : MeasureTheory.OuterMeasureClass F α]
  {p : α → Prop} (μ : F), (∀ (a : α), p a) → ∀ᵐ (a : α) ∂μ, p a
Result.success

Testing || CoxeterSystem.not_isRightDescent_iff : ∀ {B : Type u_1} {W : Type u_2} [inst : Group W] {M : CoxeterMatrix B} (cs : CoxeterSystem M W) {w : W} {i : B},
  ¬cs.IsRightDescent w i ↔ cs.length (w * cs.simple i) = cs.length w + 1
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || RingHom.liftOfRightInverse_comp_apply : ∀ {A : Type u_1} {B : Type u_2} {C : Type u_3} [inst : Ring A] [inst_1 : Ring B] [inst_2 : Ring C] (f : A →+* B)
  (f_inv : B → A) (hf : Function.RightInverse f_inv ⇑f) (g : { g // RingHom.ker f ≤ RingHom.ker g }) (x : A),
  ((f.liftOfRightInverse f_inv hf) g) (f x) = ↑g x
Result.exception ::
Duper saturated

Testing || LinearIndependent.total_ne_of_not_mem_support : ∀ {ι : Type u'} {R : Type u_2} {M : Type u_4} {v : ι → M} [inst : Ring R] [inst_1 : AddCommGroup M]
  [inst_2 : _root_.Module R M] [inst_3 : Nontrivial R],
  LinearIndependent R v → ∀ {x : ι} (f : ι →₀ R), x ∉ f.support → (Finsupp.linearCombination R v) f ≠ v x
Result.success

Testing || CategoryTheory.Limits.Cocones.precomposeEquivalence_unitIso : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u₃} [inst_1 : CategoryTheory.Category.{v₃, u₃} C]
  {F G : CategoryTheory.Functor J C} (α : G ≅ F),
  (CategoryTheory.Limits.Cocones.precomposeEquivalence α).unitIso =
    CategoryTheory.NatIso.ofComponents
      (fun s =>
        CategoryTheory.Limits.Cocones.ext
          (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj s).pt) ⋯)
      ⋯
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀
  (naturality :
    autoParam
      (∀ {X Y : CategoryTheory.Limits.Cocone F} (f : X ⟶ Y),
        CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).map f)
            (CategoryTheory.Limits.Cocones.ext
                (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj Y).pt)
                ⋯).hom =
          CategoryTheory.CategoryStruct.comp
            (CategoryTheory.Limits.Cocones.ext
                (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj X).pt) ⋯).hom
            (((CategoryTheory.Limits.Cocones.precompose α.hom).comp
                  (CategoryTheory.Limits.Cocones.precompose α.inv)).map
              f))
      _auto✝),
  (CategoryTheory.Limits.Cocones.precomposeEquivalence α).unitIso =
    CategoryTheory.NatIso.ofComponents
      (fun s =>
        CategoryTheory.Limits.Cocones.ext
          (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cocone F)).obj s).pt) ⋯)
      naturality, type of dependent ∀ bound variable is of sort `Prop`

Testing || AntivaryOn.of_neg_right : ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : OrderedAddCommGroup α] [inst_1 : OrderedAddCommGroup β]
  {s : Set ι} {f : ι → α} {g : ι → β}, AntivaryOn f (-g) s → MonovaryOn f g s
Result.exception ::
Duper saturated

Testing || DedekindDomain.ProdAdicCompletions.IsFiniteAdele.mul : ∀ {R : Type u_1} {K : Type u_2} [inst : CommRing R] [inst_1 : IsDedekindDomain R] [inst_2 : Field K]
  [inst_3 : Algebra R K] [inst_4 : IsFractionRing R K] {x y : DedekindDomain.ProdAdicCompletions R K},
  x.IsFiniteAdele → y.IsFiniteAdele → (x * y).IsFiniteAdele
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: DedekindDomain.ProdAdicCompletions R K is not a `∀`

Testing || Int.bitwise_or : Int.bitwise or = Int.lor
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Filter.eventuallyLE_congr : ∀ {α : Type u} {β : Type v} [inst : LE β] {l : Filter α} {f f' g g' : α → β},
  f =ᶠ[l] f' → g =ᶠ[l] g' → (f ≤ᶠ[l] g ↔ f' ≤ᶠ[l] g')
Result.success

Testing || ProbabilityTheory.Kernel.compProd_apply : ∀ {α : Type u_1} {β : Type u_2} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} {γ : Type u_3}
  {mγ : MeasurableSpace γ} {s : Set (β × γ)},
  MeasurableSet s →
    ∀ (κ : ProbabilityTheory.Kernel α β) [inst : ProbabilityTheory.IsSFiniteKernel κ]
      (η : ProbabilityTheory.Kernel (α × β) γ) [inst : ProbabilityTheory.IsSFiniteKernel η] (a : α),
      ((κ.compProd η) a) s = ∫⁻ (b : β), (η (a, b)) {c | (b, c) ∈ s} ∂κ a
Result.success

Testing || List.cons_head!_tail : ∀ {α : Type u} [inst : Inhabited α] {l : List α}, l ≠ [] → l.head! :: l.tail = l
Result.success

Testing || hasSum_geometric_of_abs_lt_one : ∀ {r : ℝ}, |r| < 1 → HasSum (fun n => r ^ n) (1 - r)⁻¹
Result.success

Testing || PolynomialModule.eval_map' : ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  (f : M →ₗ[R] M) (q : PolynomialModule R M) (r : R),
  (PolynomialModule.eval r) ((PolynomialModule.map R f) q) = f ((PolynomialModule.eval r) q)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WittVector.mul_polyOfInterest_aux1 : ∀ (p : ℕ) [hp : Fact (Nat.Prime p)] (n : ℕ),
  ∑ i ∈ Finset.range (n + 1), ↑p ^ i * WittVector.wittMul p i ^ p ^ (n - i) = WittVector.wittPolyProd p n
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Filter.Tendsto.inv_tendsto_zero : ∀ {𝕜 : Type u_1} {α : Type u_2} [inst : LinearOrderedField 𝕜] [inst_1 : TopologicalSpace 𝕜] [inst_2 : OrderTopology 𝕜]
  {l : Filter α} {f : α → 𝕜}, Filter.Tendsto f l (nhdsWithin 0 (Set.Ioi 0)) → Filter.Tendsto f⁻¹ l Filter.atTop
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `LinearOrderedField.toInv`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Submodule.convex : ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E] [inst_2 : _root_.Module 𝕜 E]
  (K : Submodule 𝕜 E), Convex 𝕜 ↑K
Result.exception ::
Duper saturated

Testing || Submodule.quotientPi_apply : ∀ {ι : Type u_1} {R : Type u_2} [inst : CommRing R] {Ms : ι → Type u_3} [inst_1 : (i : ι) → AddCommGroup (Ms i)]
  [inst_2 : (i : ι) → _root_.Module R (Ms i)] [inst_3 : Fintype ι] [inst_4 : DecidableEq ι]
  (p : (i : ι) → Submodule R (Ms i)) (a : ((i : ι) → Ms i) ⧸ Submodule.pi Set.univ p) (i : ι),
  (Submodule.quotientPi p) a i = (Submodule.quotientPiLift p (fun i => (p i).mkQ) ⋯) a i
Result.exception ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || FirstOrder.Language.Formula.equivSentence_inf : ∀ {L : FirstOrder.Language} {α : Type u'} (φ ψ : L.Formula α),
  FirstOrder.Language.Formula.equivSentence (φ ⊓ ψ) =
    FirstOrder.Language.Formula.equivSentence φ ⊓ FirstOrder.Language.Formula.equivSentence ψ
Result.success

Testing || TrivSqZeroExt.isUnit_or_isNilpotent : ∀ {R : Type u_1} {M : Type u_2} [inst : DivisionSemiring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  [inst_3 : _root_.Module Rᵐᵒᵖ M] [inst_4 : SMulCommClass R Rᵐᵒᵖ M] (a : TrivSqZeroExt R M), IsUnit a ∨ IsNilpotent a
Result.success

Testing || ZMod.val_add_of_le : ∀ {n : ℕ} [inst : NeZero n] {a b : ZMod n}, n ≤ a.val + b.val → (a + b).val = a.val + b.val - n
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `PartialOrder.toPreorder`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MvPowerSeries.order_le : ∀ {σ : Type u_1} {R : Type u_2} [inst : Semiring R] {f : MvPowerSeries σ R} {d : σ →₀ ℕ},
  (MvPowerSeries.coeff R d) f ≠ 0 → f.order ≤ ↑d.degree
Result.success

Testing || AffineMap.snd_linear : ∀ {k : Type u_1} {V1 : Type u_2} {P1 : Type u_3} {V2 : Type u_4} {P2 : Type u_5} [inst : Ring k]
  [inst_1 : AddCommGroup V1] [inst_2 : _root_.Module k V1] [inst_3 : AddTorsor V1 P1] [inst_4 : AddCommGroup V2]
  [inst_5 : _root_.Module k V2] [inst_6 : AddTorsor V2 P2], AffineMap.snd.linear = LinearMap.snd k V1 V2
Result.success

Testing || LinearEquiv.coe_coe : ∀ {R : Type u_1} {S : Type u_5} {M : Type u_6} {M₂ : Type u_8} [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] {module_M : _root_.Module R M}
  {module_S_M₂ : _root_.Module S M₂} {σ : R →+* S} {σ' : S →+* R} {re₁ : RingHomInvPair σ σ'}
  {re₂ : RingHomInvPair σ' σ} (e : M ≃ₛₗ[σ] M₂), ⇑↑e = ⇑e
Result.success

Testing || LinearEquiv.sumArrowLequivProdArrow_symm_apply_inr : ∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] {α : Type u_5}
  {β : Type u_6} (f : α → M) (g : β → M) (b : β),
  (LinearEquiv.sumArrowLequivProdArrow α β R M).symm (f, g) (Sum.inr b) = g b
Result.success

Testing || Finset.Nontrivial.pow : ∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : CancelMonoid α] {s : Finset α},
  s.Nontrivial → ∀ {n : ℕ}, n ≠ 0 → (s ^ n).Nontrivial
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WeierstrassCurve.Affine.Point.some_add_some_of_Yne : ∀ {F : Type u} [inst : Field F] {W : WeierstrassCurve.Affine F} {x₁ x₂ y₁ y₂ : F} {h₁ : W.Nonsingular x₁ y₁}
  {h₂ : W.Nonsingular x₂ y₂} (hy : y₁ ≠ W.negY x₂ y₂),
  WeierstrassCurve.Affine.Point.some h₁ + WeierstrassCurve.Affine.Point.some h₂ = WeierstrassCurve.Affine.Point.some ⋯
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || isCoprime_mul_unit_right_left : ∀ {R : Type u_1} [inst : CommSemiring R] {x : R}, IsUnit x → ∀ (y z : R), IsCoprime (y * x) z ↔ IsCoprime y z
Result.success

Testing || ciInf_le_of_le' : ∀ {α : Type u_1} {ι : Sort u_4} [inst : ConditionallyCompleteLinearOrderBot α] {f : ι → α} {a : α} (c : ι),
  f c ≤ a → iInf f ≤ a
Result.success

Testing || RingHom.map_mulVec : ∀ {m : Type u_2} {n : Type u_3} {R : Type u_7} {S : Type u_8} [inst : Fintype n] [inst_1 : NonAssocSemiring R]
  [inst_2 : NonAssocSemiring S] (f : R →+* S) (M : Matrix m n R) (v : n → R) (i : m),
  f (M.mulVec v i) = (M.map ⇑f).mulVec (⇑f ∘ v) i
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix m n R is not a `∀`

Testing || Ordinal.dvd_of_mod_eq_zero : ∀ {a b : Ordinal.{u_4}}, a % b = 0 → b ∣ a
Result.exception ::
Duper saturated

Testing || Profinite.projective_of_extrDisc : ∀ {X : Profinite}, ExtremallyDisconnected ↑X.toTop → CategoryTheory.Projective X
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_5
    x_0).topologicalSpace_coe`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || FirstOrder.Language.Substructure.mem_inf : ∀ {L : FirstOrder.Language} {M : Type w} [inst : L.Structure M] {p p' : L.Substructure M} {x : M},
  x ∈ p ⊓ p' ↔ x ∈ p ∧ x ∈ p'
Result.exception ::
Duper saturated

Testing || ModuleCat.ExtendScalars.map'_id : ∀ {R : Type u₁} {S : Type u₂} [inst : CommRing R] [inst_1 : CommRing S] (f : R →+* S) {M : ModuleCat R},
  ModuleCat.ExtendScalars.map' f (CategoryTheory.CategoryStruct.id M) =
    CategoryTheory.CategoryStruct.id (ModuleCat.ExtendScalars.obj' f M)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Real.sin_zero : Real.sin 0 = 0
Result.exception ::
Duper saturated

Testing || CategoryTheory.Sigma.inclCompMap_inv_app : ∀ {I : Type w₁} (C : I → Type u₁) [inst : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)] {J : Type w₂} (g : J → I)
  (j : J) (X : C (g j)), (CategoryTheory.Sigma.inclCompMap C g j).inv.app X = CategoryTheory.CategoryStruct.id ⟨g j, X⟩
Result.success

Testing || div_mul_cancel_left : ∀ {G : Type u_3} [inst : CommGroup G] (a b : G), a / (a * b) = b⁻¹
Result.success

Testing || AlgebraicGeometry.IsOpenImmersion.app_eq_invApp_app_of_comp_eq_aux : ∀ {X Y U : AlgebraicGeometry.Scheme} (f : Y ⟶ U) (g : U ⟶ X) (fg : Y ⟶ X),
  fg = CategoryTheory.CategoryStruct.comp f g →
    ∀ [h : AlgebraicGeometry.IsOpenImmersion g] (V : U.Opens),
      (TopologicalSpace.Opens.map f.base).obj V =
        (TopologicalSpace.Opens.map fg.base).obj ((AlgebraicGeometry.Scheme.Hom.opensFunctor g).obj V)
Result.exception ::
Duper saturated

Testing || MeasureTheory.OuterMeasure.mkMetric_top : ∀ {X : Type u_2} [inst : EMetricSpace X], (MeasureTheory.OuterMeasure.mkMetric fun x => ⊤) = ⊤
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type 0 < r✝ of λ binder contains bound variables

Testing || Std.DHashMap.Internal.Raw₀.getKey?_eq_none : ∀ {α : Type u} {β : α → Type v} (m : Std.DHashMap.Internal.Raw₀ α β) [inst : BEq α] [inst_1 : Hashable α]
  [inst_2 : EquivBEq α] [inst_3 : LawfulHashable α], (↑m).WF → ∀ {a : α}, m.contains a = false → m.getKey? a = none
Result.success

Testing || WithTop.pow_right_strictMono : ∀ {α : Type u_1} [inst : DecidableEq α] [inst_1 : CanonicallyOrderedCommSemiring α] [inst_2 : PosMulStrictMono α]
  [inst_3 : NoZeroDivisors α] [inst_4 : Nontrivial α] {n : ℕ}, n ≠ 0 → StrictMono fun a => a ^ n
Result.exception ::
Duper saturated

Testing || ofBoolRing_symm_eq : ∀ {α : Type u_1}, ofBoolRing.symm = toBoolRing
Result.success

Testing || MvPolynomial.C_dvd_iff_zmod : ∀ {σ : Type u_1} (n : ℕ) (φ : MvPolynomial σ ℤ),
  MvPolynomial.C ↑n ∣ φ ↔ (MvPolynomial.map (Int.castRingHom (ZMod n))) φ = 0
Result.exception ::
Duper saturated

Testing || CategoryTheory.MonoidalCategory.whiskerLeftIso_trans : ∀ {C : Type u} [𝒞 : CategoryTheory.Category.{v, u} C] [inst : CategoryTheory.MonoidalCategory C] (W : C) {X Y Z : C}
  (f : X ≅ Y) (g : Y ≅ Z),
  CategoryTheory.MonoidalCategory.whiskerLeftIso W (f ≪≫ g) =
    CategoryTheory.MonoidalCategory.whiskerLeftIso W f ≪≫ CategoryTheory.MonoidalCategory.whiskerLeftIso W g
Result.exception ::
Duper saturated

Testing || EReal.coe_ennreal_le_coe_ennreal_iff : ∀ {x y : ENNReal}, ↑x ≤ ↑y ↔ x ≤ y
Result.success

Testing || NonUnitalSubring.coe_bot : ∀ {R : Type u} [inst : NonUnitalNonAssocRing R], ↑⊥ = {0}
Result.success

Testing || innerDualCone_eq_iInter_innerDualCone_singleton : ∀ {H : Type u_1} [inst : NormedAddCommGroup H] [inst_1 : InnerProductSpace ℝ H] (s : Set H),
  ↑s.innerDualCone = ⋂ i, ↑{↑i}.innerDualCone
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type { x // x ∈ x_0 } of λ binder contains bound variables

Testing || Set.iUnion_sub_left_image : ∀ {α : Type u_2} [inst : Sub α] {s t : Set α}, ⋃ a ∈ s, (fun x => a - x) '' t = s - t
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a ∈ s of λ binder contains bound variables

Testing || SetTheory.PGame.lf_of_lf_of_le : ∀ {x y z : SetTheory.PGame}, x.LF y → y ≤ z → x.LF z
Result.success

Testing || MeasureTheory.eLpNorm_trim_ae : ∀ {α : Type u_1} {E : Type u_2} {m m0 : MeasurableSpace α} {p : ENNReal} {μ : MeasureTheory.Measure α}
  [inst : NormedAddCommGroup E] (hm : m ≤ m0) {f : α → E},
  MeasureTheory.AEStronglyMeasurable f (μ.trim hm) → MeasureTheory.eLpNorm f p (μ.trim hm) = MeasureTheory.eLpNorm f p μ
Result.exception ::
Duper saturated

Testing || List.Perm.subset : ∀ {α : Type u_1} {l₁ l₂ : List α}, l₁.Perm l₂ → l₁ ⊆ l₂
Result.exception ::
Duper saturated

Testing || Complex.differentiableAt_cos : ∀ {x : ℂ}, DifferentiableAt ℂ Complex.cos x
Result.exception ::
Duper saturated

Testing || CategoryTheory.Functor.Iteration.truncFunctor_obj : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {Φ : CategoryTheory.Functor C C}
  (ε : CategoryTheory.Functor.id C ⟶ Φ) {J : Type u} {j : J} [inst_1 : Preorder J] [inst_2 : OrderBot J]
  [inst_3 : SuccOrder J] {i : J} (hi : i ≤ j) (iter : CategoryTheory.Functor.Iteration ε j),
  (CategoryTheory.Functor.Iteration.truncFunctor ε hi).obj iter = iter.trunc hi
Result.success

Testing || RelEmbedding.map_rel_iff : ∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} (f : r ↪r s) {a b : α}, s (f a) (f b) ↔ r a b
Result.success

Testing || SymAlg.sym_ne_zero_iff : ∀ {α : Type u_1} [inst : _root_.Zero α] (a : α), SymAlg.sym a ≠ 0 ↔ a ≠ 0
Result.success

Testing || AlgebraicGeometry.StructureSheaf.stalkSpecializes_stalk_to_fiber : ∀ {R : Type u_1} [inst : CommRing R] {x y : PrimeSpectrum R} (h : x ⤳ y),
  CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Spec.structureSheaf R).presheaf.stalkSpecializes h)
      (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x) =
    CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R y)
      (let_fun this := PrimeSpectrum.localizationMapOfSpecializes h;
      this)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Complex.abs_im_eq_abs : ∀ {z : ℂ}, |z.im| = Complex.abs z ↔ z.re = 0
Result.success

Testing || Ordinal.principal_swap_iff : ∀ {o : Ordinal.{u}} {op : Ordinal.{u} → Ordinal.{u} → Ordinal.{u}},
  Ordinal.Principal (Function.swap op) o ↔ Ordinal.Principal op o
Result.exception ::
Duper saturated

Testing || MeasureTheory.Martingale.stoppedValue_ae_eq_restrict_eq : ∀ {Ω : Type u_1} {E : Type u_2} {m : MeasurableSpace Ω} {μ : MeasureTheory.Measure Ω} [inst : NormedAddCommGroup E]
  [inst_1 : NormedSpace ℝ E] [inst_2 : CompleteSpace E] {ι : Type u_3} [inst_3 : LinearOrder ι]
  [inst_4 : TopologicalSpace ι] [inst_5 : OrderTopology ι] [inst_6 : FirstCountableTopology ι]
  {ℱ : MeasureTheory.Filtration ι m} [inst_7 : MeasureTheory.SigmaFiniteFiltration μ ℱ] {τ : Ω → ι} {f : ι → Ω → E}
  {n : ι},
  MeasureTheory.Martingale f ℱ μ →
    ∀ (hτ : MeasureTheory.IsStoppingTime ℱ τ) (hτ_le : ∀ (x : Ω), τ x ≤ n)
      [inst_8 : MeasureTheory.SigmaFinite (μ.trim ⋯)] (i : ι),
      MeasureTheory.stoppedValue f τ =ᵐ[μ.restrict {x | τ x = i}] MeasureTheory.condexp hτ.measurableSpace μ (f n)
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Set (Set Ω) is not a `∀`

Testing || PartialEquiv.restr_univ : ∀ {α : Type u_1} {β : Type u_2} {e : PartialEquiv α β}, e.restr Set.univ = e
Result.success

Testing || MeasureTheory.AEFinStronglyMeasurable.ae_nonneg_of_forall_setIntegral_nonneg : ∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ℝ},
  MeasureTheory.AEFinStronglyMeasurable f μ →
    (∀ (s : Set α), MeasurableSet s → μ s < ⊤ → MeasureTheory.IntegrableOn f s μ) →
      (∀ (s : Set α), MeasurableSet s → μ s < ⊤ → 0 ≤ ∫ (x : α) in s, f x ∂μ) → 0 ≤ᵐ[μ] f
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #2, (∀ x1 : #3, (∀ x2 : (#0 → Prop), ((!18 (λx3 : #0, (x2 x3)) (!13 (!11 x0 x1))) → ((!18 (λx3 : #0, (x2 x3)) (!13 (!11 x0 (!19 x1)))) → (!18 (λx3 : #0, (x2 x3)) (!13 x0))))))) is not type correct

Testing || Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.limplies_of_assignmentsInvariant : ∀ {n : ℕ} (f : Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula n),
  f.AssignmentsInvariant →
    Std.Tactic.BVDecide.LRAT.Internal.Limplies (Std.Tactic.BVDecide.LRAT.Internal.PosFin n) f f.assignments
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Square.Hom.comp_τ₄ : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {sq₁ sq₂ sq₃ : CategoryTheory.Square C} (f : sq₁.Hom sq₂)
  (g : sq₂.Hom sq₃), (f.comp g).τ₄ = CategoryTheory.CategoryStruct.comp f.τ₄ g.τ₄
Result.success

Testing || Eq.congr_left : ∀ {α : Sort u_1} {x y z : α}, x = y → (x = z ↔ y = z)
Result.success

Testing || LieAlgebra.exists_isRegular_of_finrank_le_card : ∀ (R : Type u_1) (L : Type u_3) [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]
  [inst_3 : Module.Finite R L] [inst_4 : Module.Free R L] [inst_5 : IsDomain R],
  ↑(Module.finrank R L) ≤ Cardinal.mk R → ∃ x, LieAlgebra.IsRegular R x
Result.exception ::
Duper saturated

Testing || leftInverse_add_left_sub : ∀ {G : Type u_3} [inst : AddGroup G] (c : G), Function.LeftInverse (fun x => x + c) fun x => x - c
Result.exception ::
Duper saturated

Testing || MeasurableSpace.generateFrom_measurableSet : ∀ {α : Type u_1} [inst : MeasurableSpace α], MeasurableSpace.generateFrom {s | MeasurableSet s} = inst
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `MeasurableSpace.generateFrom x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MeasureTheory.Measure.measure_isMulInvariant_eq_smul_of_isCompact_closure : ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G]
  [inst_3 : MeasurableSpace G] [inst_4 : BorelSpace G] [inst_5 : LocallyCompactSpace G] (μ' μ : MeasureTheory.Measure G)
  [inst_6 : μ.IsHaarMeasure] [inst_7 : MeasureTheory.IsFiniteMeasureOnCompacts μ'] [inst_8 : μ'.IsMulLeftInvariant]
  {s : Set G}, IsCompact (closure s) → μ' s = μ'.haarScalarFactor μ • μ s
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `MeasurableSet (cifvar_24 x_1 x_2)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Profinite.NobelingProof.GoodProducts.linearIndependentAux : ∀ {I : Type u} [inst : LinearOrder I] [inst_1 : WellFoundedLT I] (μ : Ordinal.{u}), Profinite.NobelingProof.P I μ
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || BddAbove.isBoundedUnder_of_range : ∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] {f : Filter β} {u : β → α},
  BddAbove (Set.range u) → Filter.IsBoundedUnder (fun x1 x2 => x1 ≤ x2) f u
Result.success

Testing || FractionalIdeal.num_eq_zero_iff : ∀ {R : Type u_1} [inst : CommRing R] {K : Type u_3} [inst_1 : Field K] [inst_2 : Algebra R K]
  [inst_3 : IsFractionRing R K] [inst_4 : Nontrivial R] {I : FractionalIdeal (nonZeroDivisors R) K}, I.num = 0 ↔ I = 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `FractionalIdeal.instZero x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Finset.ruzsa_covering_mul : ∀ {G : Type u_1} [inst : Group G] {K : ℝ} [inst_1 : DecidableEq G] {A B : Finset G},
  B.Nonempty → ↑(A * B).card ≤ K * ↑B.card → ∃ F ⊆ A, ↑F.card ≤ K ∧ A ⊆ F * (B / B)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Preorder.toLT`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Matrix.head_cons : ∀ {α : Type u} {m : ℕ} (x : α) (u : Fin m → α), Matrix.vecHead (Matrix.vecCons x u) = x
Result.success

Testing || Set.image_neg_Ici : ∀ {α : Type u_1} [inst : OrderedAddCommGroup α] (a : α), Neg.neg '' Set.Ici a = Set.Iic (-a)
Result.success

Testing || Set.natCard_div_le : ∀ {G : Type u_1} [inst : Group G] {s t : Set G}, Nat.card ↑(s / t) ≤ Nat.card ↑s * Nat.card ↑t
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Finset.mem_disjSum : ∀ {α : Type u_1} {β : Type u_2} {s : Finset α} {t : Finset β} {x : α ⊕ β},
  x ∈ s.disjSum t ↔ (∃ a ∈ s, Sum.inl a = x) ∨ ∃ b ∈ t, Sum.inr b = x
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.pseudofunctorOfIsLocallyDiscrete_mapComp : ∀ {B : Type u_1} {C : Type u_2} [inst : CategoryTheory.Bicategory B]
  [inst_1 : CategoryTheory.Bicategory.IsLocallyDiscrete B] [inst_2 : CategoryTheory.Bicategory C] (obj : B → C)
  (map : {b b' : B} → (b ⟶ b') → (obj b ⟶ obj b'))
  (mapId : (b : B) → map (CategoryTheory.CategoryStruct.id b) ≅ CategoryTheory.CategoryStruct.id (obj b))
  (mapComp :
    {b₀ b₁ b₂ : B} →
      (f : b₀ ⟶ b₁) →
        (g : b₁ ⟶ b₂) →
          map (CategoryTheory.CategoryStruct.comp f g) ≅ CategoryTheory.CategoryStruct.comp (map f) (map g))
  (map₂_associator :
    autoParam
      (∀ {b₀ b₁ b₂ b₃ : B} (f : b₀ ⟶ b₁) (g : b₁ ⟶ b₂) (h : b₂ ⟶ b₃),
        CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.comp f g) h).hom
            (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapComp f g).hom (map h))
              (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (map f) (map g) (map h)).hom
                (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapComp g h).inv)
                  (mapComp f (CategoryTheory.CategoryStruct.comp g h)).inv))) =
          CategoryTheory.eqToHom ⋯)
      _auto✝)
  (map₂_left_unitor :
    autoParam
      (∀ {b₀ b₁ : B} (f : b₀ ⟶ b₁),
        CategoryTheory.CategoryStruct.comp (mapComp (CategoryTheory.CategoryStruct.id b₀) f).hom
            (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (mapId b₀).hom (map f))
              (CategoryTheory.Bicategory.leftUnitor (map f)).hom) =
          CategoryTheory.eqToHom ⋯)
      _auto✝¹)
  (map₂_right_unitor :
    autoParam
      (∀ {b₀ b₁ : B} (f : b₀ ⟶ b₁),
        CategoryTheory.CategoryStruct.comp (mapComp f (CategoryTheory.CategoryStruct.id b₁)).hom
            (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (map f) (mapId b₁).hom)
              (CategoryTheory.Bicategory.rightUnitor (map f)).hom) =
          CategoryTheory.eqToHom ⋯)
      _auto✝²)
  {a b c : B} (f : a ⟶ b) (g : b ⟶ c),
  (CategoryTheory.pseudofunctorOfIsLocallyDiscrete obj map mapId mapComp map₂_associator map₂_left_unitor
          map₂_right_unitor).mapComp
      f g =
    mapComp f g
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.Bicategory.homCategory
  x_0 x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Std.DHashMap.getKey_insert_self : ∀ {α : Type u} {β : α → Type v} {x : BEq α} {x_1 : Hashable α} {m : Std.DHashMap α β} [inst : EquivBEq α]
  [inst_1 : LawfulHashable α] {k : α} {v : β k}, (m.insert k v).getKey k ⋯ = k
Result.exception ::
Duper saturated

Testing || map_symmDiff : ∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} [inst : FunLike F α β] [inst_1 : CoheytingAlgebra α]
  [inst_2 : CoheytingAlgebra β] [inst_3 : CoheytingHomClass F α β] (f : F) (a b : α),
  f (symmDiff a b) = symmDiff (f a) (f b)
Result.success

Testing || BoundedContinuousFunction.norm_lt_iff_of_compact : ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : SeminormedAddCommGroup β] [inst_2 : CompactSpace α]
  {f : BoundedContinuousFunction α β} {M : ℝ}, 0 < M → (‖f‖ < M ↔ ∀ (x : α), ‖f x‖ < M)
Result.exception ::
Duper saturated

Testing || WithTop.sum_eq_top_iff : ∀ {ι : Type u_1} {α : Type u_2} [inst : AddCommMonoid α] {s : Finset ι} {f : ι → WithTop α},
  ∑ i ∈ s, f i = ⊤ ↔ ∃ i ∈ s, f i = ⊤
Result.success

Testing || Real.le_sSup_iff : ∀ {s : Set ℝ} {a : ℝ}, BddAbove s → s.Nonempty → (a ≤ sSup s ↔ ∀ ε < 0, ∃ x ∈ s, a + ε < x)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Associated.prod : ∀ {M : Type u_5} [inst : CommMonoid M] {ι : Type u_6} (s : Finset ι) (f g : ι → M),
  (∀ i ∈ s, Associated (f i) (g i)) → Associated (∏ i ∈ s, f i) (∏ i ∈ s, g i)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.instInsert`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Fin.cycleRange_zero : ∀ (n : ℕ), Fin.cycleRange 0 = 1
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || HolorIndex.cast_type : ∀ {ds₁ ds₂ : List ℕ} (is : List ℕ) (eq : ds₁ = ds₂) (h : List.Forall₂ (fun x1 x2 => x1 < x2) is ds₁),
  ↑(cast ⋯ ⟨is, h⟩) = is
Result.exception ::
Duper saturated

Testing || UpperHalfPlane.coe_mk : ∀ (z : ℂ) (h : 0 < z.im), ↑(UpperHalfPlane.mk z h) = z
Result.success

Testing || Nat.one_lt_pow_iff : ∀ {n : ℕ}, n ≠ 0 → ∀ {a : ℕ}, 1 < a ^ n ↔ 1 < a
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MeasureTheory.FiniteMeasure.null_iff_toMeasure_null : ∀ {Ω : Type u_1} [inst : MeasurableSpace Ω] (ν : MeasureTheory.FiniteMeasure Ω) (s : Set Ω), ν s = 0 ↔ ↑ν s = 0
Result.exception ::
Duper saturated

Testing || min_mul_min_le_min_mul_mul' : ∀ {α : Type u_1} [inst : Mul α] [inst_1 : LinearOrder α] [inst_2 : MulLeftMono α] [inst_3 : MulRightMono α]
  {a b c d : α}, (a ⊓ c) * (b ⊓ d) ≤ a * b ⊓ c * d
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.smul_sum : ∀ {α : Type u_1} {β : Type u_2} [inst : AddMonoid β] [inst_1 : DistribSMul α β] {r : α} {l : List β},
  r • l.sum = (List.map (fun x => r • x) l).sum
Result.exception ::
Duper saturated

Testing || LinearMap.compQuadraticMap_polar : ∀ {S : Type u_1} {R : Type u_3} {M : Type u_4} {N : Type u_5} [inst : CommRing R] [inst_1 : AddCommGroup M]
  [inst_2 : AddCommGroup N] [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R N] {N' : Type u_8}
  [inst_5 : AddCommGroup N'] [inst_6 : CommSemiring S] [inst_7 : Algebra S R] [inst_8 : _root_.Module S N]
  [inst_9 : _root_.Module S N'] [inst_10 : IsScalarTower S R N] [inst_11 : _root_.Module S M]
  [inst_12 : IsScalarTower S R M] (f : N →ₗ[S] N') (Q : QuadraticMap R M N) (x y : M),
  QuadraticMap.polar (⇑(f.compQuadraticMap' Q)) x y = f (QuadraticMap.polar (⇑Q) x y)
Result.exception ::
Duper saturated

Testing || lowerBounds_infClosure : ∀ {α : Type u_2} [inst : SemilatticeInf α] (s : Set α), lowerBounds (infClosure s) = lowerBounds s
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Ordinal.lsub_le : ∀ {ι : Type u_4} {f : ι → Ordinal.{max u_5 u_4}} {a : Ordinal.{max u_5 u_4}}, (∀ (i : ι), f i < a) → Ordinal.lsub f ≤ a
Result.success

Testing || Subsemigroup.comap_top : ∀ {M : Type u_1} {N : Type u_2} [inst : Mul M] [inst_1 : Mul N] (f : M →ₙ* N), Subsemigroup.comap f ⊤ = ⊤
Result.success

Testing || CofiniteTopology.continuous_of : ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : T1Space X], Continuous ⇑CofiniteTopology.of
Result.success

Testing || LE.le.add_eq_left : ∀ {α : Type u_1} [inst : IdemSemiring α] {a b : α}, b ≤ a → a + b = a
Result.success

Testing || ContMDiffAt.clm_comp : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners 𝕜 E H} {M : Type u_4}
  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] {F₁ : Type u_8} [inst_6 : NormedAddCommGroup F₁]
  [inst_7 : NormedSpace 𝕜 F₁] {F₂ : Type u_9} [inst_8 : NormedAddCommGroup F₂] [inst_9 : NormedSpace 𝕜 F₂]
  {F₃ : Type u_10} [inst_10 : NormedAddCommGroup F₃] [inst_11 : NormedSpace 𝕜 F₃] {n : ℕ∞} {g : M → F₁ →L[𝕜] F₃}
  {f : M → F₂ →L[𝕜] F₁} {x : M},
  ContMDiffAt I (modelWithCornersSelf 𝕜 (F₁ →L[𝕜] F₃)) n g x →
    ContMDiffAt I (modelWithCornersSelf 𝕜 (F₂ →L[𝕜] F₁)) n f x →
      ContMDiffAt I (modelWithCornersSelf 𝕜 (F₂ →L[𝕜] F₃)) n (fun x => (g x).comp (f x)) x
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.regularTopology.isSheafFor_regular_of_projective : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_5, u_1} C] {X : C} (S : CategoryTheory.Presieve X)
  [inst_1 : S.regular] [inst_2 : CategoryTheory.Projective X] (F : CategoryTheory.Functor Cᵒᵖ (Type u_4)),
  CategoryTheory.Presieve.IsSheafFor F S
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Y ⟶ X of λ binder contains bound variables

Testing || QuotSMulTop.map_comp : ∀ {R : Type u_2} [inst : CommRing R] (r : R) {M : Type u_1} {M' : Type u_3} {M'' : Type u_4} [inst_1 : AddCommGroup M]
  [inst_2 : _root_.Module R M] [inst_3 : AddCommGroup M'] [inst_4 : _root_.Module R M'] [inst_5 : AddCommGroup M'']
  [inst_6 : _root_.Module R M''] (g : M' →ₗ[R] M'') (f : M →ₗ[R] M'),
  (QuotSMulTop.map r) (g ∘ₗ f) = (QuotSMulTop.map r) g ∘ₗ (QuotSMulTop.map r) f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Submodule.Quotient.addCommGroup
  x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MeasureTheory.IntegrableOn.union : ∀ {α : Type u_1} {E : Type u_3} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {f : α → E} {s t : Set α}
  {μ : MeasureTheory.Measure α},
  MeasureTheory.IntegrableOn f s μ → MeasureTheory.IntegrableOn f t μ → MeasureTheory.IntegrableOn f (s ∪ t) μ
Result.success

Testing || Int.lt_mul_of_ediv_lt : ∀ {a b c : ℤ}, 0 < c → a / c < b → a < b * c
Result.success

Testing || MeasureTheory.SimpleFunc.GCongr.mk_le_mk : ∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] [inst_1 : Preorder β] {f g : α → β}
  {hf : ∀ (x : β), MeasurableSet (f ⁻¹' {x})} {hg : ∀ (x : β), MeasurableSet (g ⁻¹' {x})} {hf' : (Set.range f).Finite}
  {hg' : (Set.range g).Finite},
  f ≤ g →
    { toFun := f, measurableSet_fiber' := hf, finite_range' := hf' } ≤
      { toFun := g, measurableSet_fiber' := hg, finite_range' := hg' }
Result.success

Testing || cfcₙHomSuperset_id' : ∀ {R : Type u_1} {A : Type u_2} {p : A → Prop} [inst : CommSemiring R] [inst_1 : Nontrivial R] [inst_2 : StarRing R]
  [inst_3 : MetricSpace R] [inst_4 : TopologicalSemiring R] [inst_5 : ContinuousStar R] [inst_6 : NonUnitalRing A]
  [inst_7 : StarRing A] [inst_8 : TopologicalSpace A] [inst_9 : _root_.Module R A] [inst_10 : IsScalarTower R A A]
  [inst_11 : SMulCommClass R A A] [instCFCₙ : NonUnitalContinuousFunctionalCalculus R p] {a : A} (ha : p a) {s : Set R}
  (hs : quasispectrum R a ⊆ s), (cfcₙHomSuperset ha hs) (ContinuousMapZero.id ⋯) = a
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: quasispectrum R a ⊆ s is not a `∀`

Testing || ContinuousMap.sup_mem_subalgebra_closure : ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : CompactSpace X] (A : Subalgebra ℝ C(X, ℝ)) (f g : ↥A),
  ↑f ⊔ ↑g ∈ A.topologicalClosure
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || IsFractionRing.associated_num_den_inv : ∀ {A : Type u_1} [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : UniqueFactorizationMonoid A] {K : Type u_2}
  [inst_3 : Field K] [inst_4 : Algebra A K] [inst_5 : IsFractionRing A K] (x : K),
  x ≠ 0 → Associated (IsFractionRing.num A x) ↑(IsFractionRing.den A x⁻¹)
Result.success

Testing || Con.le_comap_conGen : ∀ {M : Type u_4} {N : Type u_5} [inst : Mul M] [inst_1 : Mul N] (f : M → N) (H : ∀ (x y : M), f (x * y) = f x * f y)
  (rel : N → N → Prop), (conGen fun x y => rel (f x) (f y)) ≤ Con.comap f H (conGen rel)
Result.exception ::
Duper saturated

Testing || TopologicalSpace.CompactOpens.coe_mk : ∀ {α : Type u_1} [inst : TopologicalSpace α] (s : TopologicalSpace.Compacts α) (h : IsOpen s.carrier),
  ↑{ toCompacts := s, isOpen' := h } = ↑s
Result.success

Testing || Metric.cthickening_thickening_subset : ∀ {α : Type u} [inst : PseudoEMetricSpace α] {ε : ℝ},
  0 ≤ ε → ∀ (δ : ℝ) (s : Set α), Metric.cthickening ε (Metric.thickening δ s) ⊆ Metric.cthickening (ε + δ) s
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instHAdd`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || mul_right_eq_self₀ : ∀ {M₀ : Type u_1} [inst : CancelMonoidWithZero M₀] {a b : M₀}, a * b = a ↔ b = 1 ∨ a = 0
Result.success

Testing || AlgHom.ker_rangeRestrict : ∀ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]
  [inst_3 : Semiring B] [inst_4 : Algebra R B] (f : A →ₐ[R] B), RingHom.ker f.rangeRestrict = RingHom.ker f
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || AlgHom.map_smul_of_tower : ∀ {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Semiring B]
  [inst_3 : Algebra R A] [inst_4 : Algebra R B] (φ : A →ₐ[R] B) {R' : Type u_1} [inst_5 : SMul R' A]
  [inst_6 : SMul R' B] [inst_7 : LinearMap.CompatibleSMul A B R' R] (r : R') (x : A), φ (r • x) = r • φ x
Result.exception ::
Duper saturated

Testing || wellFoundedGT_antisymmetrization_iff : ∀ {α : Type u_1} [inst : Preorder α], WellFoundedGT (Antisymmetrization α fun x1 x2 => x1 ≤ x2) ↔ WellFoundedGT α
Result.exception ::
Duper saturated

Testing || frontier_Icc : ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderTopology α]
  [inst_3 : DenselyOrdered α] [inst_4 : NoMinOrder α] [inst_5 : NoMaxOrder α] {a b : α},
  a ≤ b → frontier (Set.Icc a b) = {a, b}
Result.success

Testing || Set.compl_singleton_eq : ∀ {α : Type u} (a : α), {a}ᶜ = {x | x ≠ a}
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #1, ((!3 (!1 x0)) = (!1 x0))) is not type correct

Testing || ContinuousMap.dist_le_iff_of_nonempty : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : CompactSpace α] [inst_2 : PseudoMetricSpace β]
  {f g : C(α, β)} {C : ℝ} [inst_3 : Nonempty α], dist f g ≤ C ↔ ∀ (x : α), dist (f x) (g x) ≤ C
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MeasureTheory.IsFundamentalDomain.measure_ne_zero : ∀ {G : Type u_1} {α : Type u_3} [inst : Group G] [inst_1 : MulAction G α] [inst_2 : MeasurableSpace α] {s : Set α}
  {μ : MeasureTheory.Measure α} [inst_3 : Countable G] [inst_4 : MeasureTheory.SMulInvariantMeasure G α μ],
  μ ≠ 0 → MeasureTheory.IsFundamentalDomain G s μ → μ s ≠ 0
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #2, (∀ x1 : #1, ((!5 x0 x1) → (!12 (!13 x1) (!14 (λx2 : #6, (!15 x2 x0))) !10)))) is not type correct

Testing || AffineSubspace.sOppSide_lineMap_right : ∀ {R : Type u_1} {V : Type u_2} {P : Type u_4} [inst : LinearOrderedField R] [inst_1 : AddCommGroup V]
  [inst_2 : _root_.Module R V] [inst_3 : AddTorsor V P] {s : AffineSubspace R P} {x y : P},
  x ∈ s → y ∉ s → ∀ {t : R}, t < 0 → s.SOppSide y ((AffineMap.lineMap x y) t)
Result.success

Testing || Projectivization.map_injective : ∀ {K : Type u_1} {V : Type u_2} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module K V]
  {L : Type u_3} {W : Type u_4} [inst_3 : DivisionRing L] [inst_4 : AddCommGroup W] [inst_5 : _root_.Module L W]
  {σ : K →+* L} {τ : L →+* K} [inst_6 : RingHomInvPair σ τ] (f : V →ₛₗ[σ] W) (hf : Function.Injective ⇑f),
  Function.Injective (Projectivization.map f hf)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Submodule.le_comap_single_pi : ∀ {R : Type u} {ι : Type x} [inst : Semiring R] {φ : ι → Type u_1} [inst_1 : (i : ι) → AddCommMonoid (φ i)]
  [inst_2 : (i : ι) → _root_.Module R (φ i)] [inst_3 : DecidableEq ι] (p : (i : ι) → Submodule R (φ i)) {i : ι},
  p i ≤ Submodule.comap (LinearMap.single R φ i) (Submodule.pi Set.univ p)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_1 x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || deriv_update : ∀ {𝕜 : Type u_1} {ι : Type u_2} [inst : DecidableEq ι] [inst_1 : Fintype ι] [inst_2 : NontriviallyNormedField 𝕜]
  (x : ι → 𝕜) (i : ι) (y : 𝕜), deriv (Function.update x i) y = Pi.single i 1
Result.success

Testing || Submonoid.map_iInf : ∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {F : Type u_4} [inst_2 : FunLike F M N]
  [mc : MonoidHomClass F M N] {ι : Sort u_5} [inst_3 : Nonempty ι] (f : F),
  Function.Injective ⇑f → ∀ (s : ι → Submonoid M), Submonoid.map f (iInf s) = ⨅ i, Submonoid.map f (s i)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Combinatorics.Subspace.coe_apply : ∀ {η : Type u_5} {α : Type u_6} {ι : Type u_7} (l : Combinatorics.Subspace η α ι) (x : η → α) (i : ι),
  ↑l x i = Sum.elim id x (l.idxFun i)
Result.success

Testing || FreeSemigroup.ext : ∀ {α : Type u} {x y : FreeSemigroup α}, x.head = y.head → x.tail = y.tail → x = y
Result.exception ::
Duper saturated

Testing || SetTheory.PGame.one_leftMoves : SetTheory.PGame.LeftMoves 1 = PUnit.{u_1 + 1}
Result.success

Testing || OrderIso.equivalence_unitIso : ∀ {X : Type u} {Y : Type v} [inst : Preorder X] [inst_1 : Preorder Y] (e : X ≃o Y),
  e.equivalence.unitIso = CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.eqToIso ⋯) ⋯
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀
  (naturality :
    autoParam
      (∀ {X_1 Y_1 : X} (f : X_1 ⟶ Y_1),
        CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.id X).map f) (CategoryTheory.eqToIso ⋯).hom =
          CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToIso ⋯).hom ((⋯.functor.comp ⋯.functor).map f))
      _auto✝),
  e.equivalence.unitIso =
    CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.eqToIso ⋯)
      naturality, type of dependent ∀ bound variable is of sort `Prop`

Testing || Module.reflection_apply : ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M] {x : M}
  {f : Module.Dual R M} (y : M) (h : f x = 2), (Module.reflection h) y = y - f y • x
Result.success

Testing || CategoryTheory.ComonadHom.ext' : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {T₁ T₂ : CategoryTheory.Comonad C} (f g : T₁ ⟶ T₂),
  f.app = g.app → f = g
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_5 x_0).app`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || NumberField.InfinitePlace.comap_surjective : ∀ {k : Type u_1} [inst : Field k] {K : Type u_2} [inst_1 : Field K] [inst_2 : Algebra k K]
  [inst_3 : Algebra.IsAlgebraic k K], Function.Surjective fun x => x.comap (algebraMap k K)
Result.exception ::
Duper saturated

Testing || Substring.ValidFor.drop : ∀ {l m r : List Char} {s : Substring},
  Substring.ValidFor l m r s → ∀ (n : ℕ), Substring.ValidFor (l ++ List.take n m) (List.drop n m) r (s.drop n)
Result.exception ::
(deterministic) timeout at `«forward demodulation»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ZMod.pow_div_two_eq_neg_one_or_one : ∀ (p : ℕ) [inst : Fact (Nat.Prime p)] {a : ZMod p}, a ≠ 0 → a ^ (p / 2) = 1 ∨ a ^ (p / 2) = -1
Result.exception ::
(deterministic) timeout at `«forward demodulation»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CauchyFilter.denseRange_pureCauchy : ∀ {α : Type u} [inst : UniformSpace α], DenseRange CauchyFilter.pureCauchy
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || mem_tangentCone_of_openSegment_subset : ∀ {G : Type u_4} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {s : Set G} {x y : G},
  openSegment ℝ x y ⊆ s → y - x ∈ tangentConeAt ℝ s x
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WeierstrassCurve.Ψ₂Sq_eq : ∀ {R : Type r} [inst : CommRing R] (W : WeierstrassCurve R), W.Ψ₂Sq = W.twoTorsionPolynomial.toPoly
Result.success

Testing || Monoid.exponent_pos : ∀ {G : Type u} [inst : Monoid G], 0 < Monoid.exponent G ↔ Monoid.ExponentExists G
Result.success

Testing || Nat.clog_of_two_le : ∀ {b n : ℕ}, 1 < b → 2 ≤ n → Nat.clog b n = Nat.clog b ((n + b - 1) / b) + 1
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_1.decLt x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || NonemptyInterval.fst_nsmul : ∀ {α : Type u_2} [inst : AddMonoid α] [inst_1 : Preorder α] [inst_2 : AddLeftMono α] [inst_3 : AddRightMono α]
  (s : NonemptyInterval α) (n : ℕ), (n • s).toProd.1 = n • s.toProd.1
Result.success

Testing || AddSubgroup.comap.proof_1 : ∀ {G : Type u_2} [inst : AddGroup G] {N : Type u_1} [inst_1 : AddGroup N], AddMonoidHomClass (G →+ N) G N
Result.exception ::
Duper saturated

Testing || Order.pred_iterate_le : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : PredOrder α] (k : ℕ) (x : α), Order.pred^[k] x ≤ x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Order.pred`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || OrderHom.map_lfp_comp : ∀ {α : Type u} {β : Type v} [inst : CompleteLattice α] [inst_1 : CompleteLattice β] (f : β →o α) (g : α →o β),
  f (OrderHom.lfp (g.comp f)) = OrderHom.lfp (f.comp g)
Result.exception ::
Duper saturated

Testing || Subgroup.le_topologicalClosure : ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] (s : Subgroup G),
  s ≤ s.topologicalClosure
Result.success

Testing || CategoryTheory.Functor.mapHomotopyCategory_obj : ∀ {ι : Type u_2} {V : Type u} [inst : CategoryTheory.Category.{v, u} V] [inst_1 : CategoryTheory.Preadditive V]
  {W : Type u_3} [inst_2 : CategoryTheory.Category.{u_4, u_3} W] [inst_3 : CategoryTheory.Preadditive W]
  (F : CategoryTheory.Functor V W) [inst_4 : F.Additive] (c : ComplexShape ι)
  (a : CategoryTheory.Quotient (homotopic V c)),
  (F.mapHomotopyCategory c).obj a = (HomotopyCategory.quotient W c).obj ((F.mapHomologicalComplex c).obj a.as)
Result.success

Testing || list_sum_mem : ∀ {M : Type u_1} {B : Type u_3} [inst : AddMonoid M] [inst_1 : SetLike B M] [inst_2 : AddSubmonoidClass B M] {S : B}
  {l : List M}, (∀ x ∈ l, x ∈ S) → l.sum ∈ S
Result.exception ::
Duper saturated

Testing || Codisjoint.symm : ∀ {α : Type u_1} [inst : PartialOrder α] [inst_1 : OrderTop α] ⦃a b : α⦄, Codisjoint a b → Codisjoint b a
Result.success

Testing || Nat.succ_iterate : ∀ (a n : ℕ), Nat.succ^[n] a = a + n
Result.success

Testing || Lean.Omega.Int.lt_of_not_le : ∀ {x y : ℤ}, ¬x ≤ y → y < x
Result.success

Testing || Matrix.mul_submatrix_one : ∀ {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {α : Type v} [inst : Fintype n] [inst_1 : Finite o]
  [inst_2 : NonAssocSemiring α] [inst_3 : DecidableEq o] (e₁ : n ≃ o) (e₂ : l → o) (M : Matrix m n α),
  M * Matrix.submatrix 1 (⇑e₁) e₂ = M.submatrix id (⇑e₁.symm ∘ e₂)
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix m n α is not a `∀`

Testing || QuadraticModuleCat.toIsometry_id : ∀ {R : Type u} [inst : CommRing R] {M : QuadraticModuleCat R},
  (CategoryTheory.CategoryStruct.id M).toIsometry = QuadraticMap.Isometry.id M.form
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀
  (map_app' : ∀ (m : ↑M.toModuleCat), M.form (LinearMap.id.toFun m) = M.form m),
  QuadraticMap.Isometry.id M.form =
    { toLinearMap := LinearMap.id, map_app' := map_app' }, type of dependent ∀ bound variable is of sort `Prop`

Testing || InnerProductSpace.Core.inner_sub_left : ∀ {𝕜 : Type u_1} {F : Type u_3} [inst : RCLike 𝕜] [inst_1 : AddCommGroup F] [inst_2 : _root_.Module 𝕜 F]
  [c : PreInnerProductSpace.Core 𝕜 F] (x y z : F), inner (x - y) z = inner x z - inner y z
Result.success

Testing || Nat.mul_lt_mul_of_lt_of_le' : ∀ {a c b d : ℕ}, a < c → b ≤ d → 0 < b → a * b < c * d
Result.success

Testing || SmoothPartitionOfUnity.toPartitionOfUnity_toFun : ∀ {ι : Type uι} {E : Type uE} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {H : Type uH}
  [inst_2 : TopologicalSpace H] {I : ModelWithCorners ℝ E H} {M : Type uM} [inst_3 : TopologicalSpace M]
  [inst_4 : ChartedSpace H M] {s : Set M} (f : SmoothPartitionOfUnity ι I M s) (i : ι), f.toPartitionOfUnity i = ↑(f i)
Result.success

Testing || Submodule.quotDualCoannihilatorToDual_apply : ∀ {R : Type u_1} {M : Type u_2} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  (W : Submodule R (Module.Dual R M)) (m : M) (w : ↥W),
  (W.quotDualCoannihilatorToDual (Submodule.Quotient.mk m)) w = ↑w m
Result.success

Testing || IsCompact.nhdsSet_inf_eq_biSup : ∀ {X : Type u} [inst : TopologicalSpace X] {K : Set X},
  IsCompact K → ∀ (l : Filter X), nhdsSet K ⊓ l = ⨆ x ∈ K, nhds x ⊓ l
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x ∈ K of λ binder contains bound variables

Testing || exists_disjoint_smul_of_isCompact : ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] [inst_3 : NoncompactSpace G]
  {K L : Set G}, IsCompact K → IsCompact L → ∃ g, Disjoint K (g • L)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Set.inv`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || exists_setIndependent_of_sSup_atoms_eq_top : ∀ {α : Type u_2} [inst : CompleteLattice α] [inst_1 : IsModularLattice α] [inst_2 : IsCompactlyGenerated α],
  sSup {a | IsAtom a} = ⊤ → ∃ s, sSupIndep s ∧ sSup s = ⊤ ∧ ∀ ⦃a : α⦄, a ∈ s → IsAtom a
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #0, (∀ x1 : #0, ((!7 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || NNReal.mk_one : ⟨1, ⋯⟩ = 1
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀ (property : 0 ≤ 1),
  1 = ⟨1, property⟩, type of dependent ∀ bound variable is of sort `Prop`

Testing || leOnePart_le_one' : ∀ {α : Type u_1} [inst : Lattice α] [inst_1 : Group α] {a : α}, a⁻ᵐ ≤ 1 ↔ a⁻¹ ≤ 1
Result.success

Testing || Functor.mapEquiv_symm_apply : ∀ {α β : Type u} (f : Type u → Type v) [inst : Functor f] [inst_1 : LawfulFunctor f] (h : α ≃ β) (y : f β),
  (Functor.mapEquiv f h).symm y = ⇑h.symm <$> y
Result.success

Testing || OrderEmbedding.preimage_Ioi : ∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] (e : α ↪o β) (x : α),
  ⇑e ⁻¹' Set.Ioi (e x) = Set.Ioi x
Result.exception ::
Duper saturated

Testing || CentroidHom.toEnd_pow : ∀ {α : Type u_5} [inst : NonUnitalNonAssocSemiring α] (x : CentroidHom α) (n : ℕ), (x ^ n).toEnd = x.toEnd ^ n
Result.success

Testing || List.ofFn_mul' : ∀ {α : Type u} {m n : ℕ} (f : Fin (m * n) → α),
  List.ofFn f = (List.ofFn fun i => List.ofFn fun j => f ⟨m * ↑i + ↑j, ⋯⟩).flatten
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Fin.prop j`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Set.iUnion_nonempty_self : ∀ {α : Type u_1} (s : Set α), ⋃ (_ : s.Nonempty), s = s
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x ∈ s of λ binder contains bound variables

Testing || CategoryTheory.ShortComplex.RightHomologyMapData.smul_φH : ∀ {R : Type u_1} {C : Type u_2} [inst : Semiring R] [inst_1 : CategoryTheory.Category.{u_3, u_2} C]
  [inst_2 : CategoryTheory.Preadditive C] [inst_3 : CategoryTheory.Linear R C] {S₁ S₂ : CategoryTheory.ShortComplex C}
  {φ : S₁ ⟶ S₂} {h₁ : S₁.RightHomologyData} {h₂ : S₂.RightHomologyData}
  (γ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂) (a : R), (γ.smul a).φH = a • γ.φH
Result.success

Testing || EMetric.ball_mem_nhds : ∀ {α : Type u} [inst : PseudoEMetricSpace α] (x : α) {ε : ENNReal}, 0 < ε → EMetric.ball x ε ∈ nhds x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `EMetric.ball x_1 x_2`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || SymplecticGroup.symplectic_det : ∀ {l : Type u_1} {R : Type u_2} [inst : DecidableEq l] [inst_1 : Fintype l] [inst_2 : CommRing R]
  {A : Matrix (l ⊕ l) (l ⊕ l) R}, A ∈ Matrix.symplecticGroup l R → IsUnit A.det
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix (l ⊕ l) (l ⊕ l) R is not a `∀`

Testing || tendsto_ceil_left_pure_ceil : ∀ {α : Type u_1} [inst : LinearOrderedRing α] [inst_1 : FloorRing α] [inst_2 : TopologicalSpace α]
  [inst_3 : OrderClosedTopology α] (x : α), Filter.Tendsto Int.ceil (nhdsWithin x (Set.Iic x)) (pure ⌈x⌉)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instDistribLatticeOfLinearOrder`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Finset.cons_induction : ∀ {α : Type u_3} {p : Finset α → Prop},
  p ∅ → (∀ (a : α) (s : Finset α) (h : a ∉ s), p s → p (Finset.cons a s h)) → ∀ (s : Finset α), p s
Result.exception ::
Duper saturated

Testing || MvPolynomial.coe_eq_zero_iff : ∀ {σ : Type u_1} {R : Type u_2} [inst : CommSemiring R] {φ : MvPolynomial σ R}, ↑φ = 0 ↔ φ = 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `MvPolynomial.commSemiring`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Comma.toIdPUnitEquiv_counitIso_hom_app : ∀ {B : Type u₂} [inst : CategoryTheory.Category.{v₂, u₂} B]
  (L : CategoryTheory.Functor (CategoryTheory.Discrete PUnit.{u_1 + 1}) (CategoryTheory.Discrete PUnit.{u_2 + 1}))
  (R : CategoryTheory.Functor B (CategoryTheory.Discrete PUnit.{u_2 + 1})) (X : B),
  (CategoryTheory.Comma.toIdPUnitEquiv L R).counitIso.hom.app X = CategoryTheory.CategoryStruct.id X
Result.exception ::
Duper saturated

Testing || aeSeq.prop_of_mem_aeSeqSet : ∀ {ι : Sort u_1} {α : Type u_2} {β : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β] {f : ι → α → β}
  {μ : MeasureTheory.Measure α} {p : α → (ι → β) → Prop} (hf : ∀ (i : ι), AEMeasurable (f i) μ) {x : α},
  x ∈ aeSeqSet hf p → p x fun n => aeSeq hf p n x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `AEMeasurable.mk (cifvar_1 i) ⋯ x`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.Nodup.isCycleOn_formPerm : ∀ {α : Type u_2} [inst : DecidableEq α] {l : List α}, l.Nodup → l.formPerm.IsCycleOn {a | a ∈ l}
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #3, (∀ x1 : (#3 → Prop), ((!6 (!4 (λx2 : #3, (x1 x2))) x0) ↔ (x1 x0)))) is not type correct

Testing || CategoryTheory.Limits.image.ι_zero' : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Limits.HasEqualizers C] {X Y : C}
  {f : X ⟶ Y}, f = 0 → ∀ [inst_4 : CategoryTheory.Limits.HasImage f], CategoryTheory.Limits.image.ι f = 0
Result.exception ::
Duper saturated

Testing || Bornology.IsCobounded.closedBall_compl_subset : ∀ {α : Type u} [inst : PseudoMetricSpace α] {s : Set α},
  Bornology.IsCobounded s → ∀ (c : α), ∃ r, (Metric.closedBall c r)ᶜ ⊆ s
Result.success

Testing || Complex.abs_im_lt_abs : ∀ {z : ℂ}, |z.im| < Complex.abs z ↔ z.re ≠ 0
Result.exception ::
(deterministic) timeout at `«forward demodulation»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Trivialization.Prod.continuous_to_fun : ∀ {B : Type u_1} [inst : TopologicalSpace B] {F₁ : Type u_2} [inst_1 : TopologicalSpace F₁] {E₁ : B → Type u_3}
  [inst_2 : TopologicalSpace (Bundle.TotalSpace F₁ E₁)] {F₂ : Type u_4} [inst_3 : TopologicalSpace F₂]
  {E₂ : B → Type u_5} [inst_4 : TopologicalSpace (Bundle.TotalSpace F₂ E₂)]
  {e₁ : Trivialization F₁ Bundle.TotalSpace.proj} {e₂ : Trivialization F₂ Bundle.TotalSpace.proj},
  ContinuousOn (Trivialization.Prod.toFun' e₁ e₂) (Bundle.TotalSpace.proj ⁻¹' (e₁.baseSet ∩ e₂.baseSet))
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `p.snd`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || IsGLB.sInf_eq : ∀ {α : Type u_1} [inst : CompleteSemilatticeInf α] {s : Set α} {a : α}, IsGLB s a → sInf s = a
Result.success

Testing || le_of_forall_pos_sub_le : ∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α] [inst_2 : AddLeftMono α] [inst_3 : DenselyOrdered α]
  {a b : α}, (∀ (ε : α), 0 < ε → a - ε ≤ b) → a ≤ b
Result.success

Testing || TopCat.Presheaf.locally_surjective_iff_surjective_on_stalks : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.ConcreteCategory C] {X : TopCat}
  {ℱ 𝒢 : TopCat.Presheaf C X} [inst_2 : CategoryTheory.Limits.HasColimits C]
  [inst_3 : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)] (T : ℱ ⟶ 𝒢),
  TopCat.Presheaf.IsLocallySurjective T ↔ ∀ (x : ↑X), Function.Surjective ⇑((TopCat.Presheaf.stalkFunctor C x).map T)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WeierstrassCurve.variableChange_Δ : ∀ {R : Type u} [inst : CommRing R] (W : WeierstrassCurve R) (C : WeierstrassCurve.VariableChange R),
  (W.variableChange C).Δ = ↑C.u⁻¹ ^ 12 * W.Δ
Result.exception ::
Duper saturated

Testing || AlgEquiv.toRingEquiv_symm : ∀ {R : Type uR} {A₁ : Type uA₁} [inst : CommSemiring R] [inst_1 : Semiring A₁] [inst_2 : Algebra R A₁]
  (f : A₁ ≃ₐ[R] A₁), (↑f).symm = ↑f.symm
Result.success

Testing || GenContFract.zeroth_cont_eq_h_one : ∀ {K : Type u_1} {g : GenContFract K} [inst : DivisionRing K], g.conts 0 = { a := g.h, b := 1 }
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Stream' (GenContFract.Pair K) is not a `∀`

Testing || List.getElem_drop : ∀ {α : Type u_1} (L : List α) {i j : ℕ} {h : j < (List.drop i L).length}, (List.drop i L)[j] = L[i + j]
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀ (h : i + j < L.length),
  h✝² = ⋯, type of dependent ∀ bound variable is of sort `Prop`

Testing || ContinuousOn.mono_rng : ∀ {α : Type u_5} {β : Type u_6} {t₁ : TopologicalSpace α} {t₂ t₃ : TopologicalSpace β},
  t₂ ≤ t₃ → ∀ {s : Set α} {f : α → β}, ContinuousOn f s → ContinuousOn f s
Result.exception ::
Duper saturated

Testing || Set.image_mulSingle_uIcc_left : ∀ {ι : Type u_1} {α : ι → Type u_2} [inst : (i : ι) → Lattice (α i)] [inst_1 : DecidableEq ι]
  [inst_2 : (i : ι) → _root_.One (α i)] (i : ι) (a : α i),
  Pi.mulSingle i '' Set.uIcc a 1 = Set.uIcc (Pi.mulSingle i a) 1
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Function.update x_0 cifvar_5`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || StarAlgebra.elemental.self_mem : ∀ (R : Type u_1) {A : Type u_2} [inst : CommSemiring R] [inst_1 : StarRing R] [inst_2 : TopologicalSpace A]
  [inst_3 : Semiring A] [inst_4 : StarRing A] [inst_5 : TopologicalSemiring A] [inst_6 : ContinuousStar A]
  [inst_7 : Algebra R A] [inst_8 : StarModule R A] (x : A), x ∈ StarAlgebra.elemental R x
Result.exception ::
Duper saturated

Testing || Ordinal.sub_le_self : ∀ (a b : Ordinal.{u_4}), a - b ≤ a
Result.exception ::
Duper saturated

Testing || SemiconjBy.pow_right : ∀ {M : Type u_2} [inst : Monoid M] {a x y : M}, SemiconjBy a x y → ∀ (n : ℕ), SemiconjBy a (x ^ n) (y ^ n)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || AddSubgroup.quotientEquivSumOfLE'.proof_4 : ∀ {α : Type u_1} [inst : AddGroup α] {s t : AddSubgroup α} (f : α ⧸ t → α) (a : (α ⧸ t) × ↥t ⧸ s.addSubgroupOf t)
  (b c : ↥t),
  (QuotientAddGroup.leftRel (s.addSubgroupOf t)) b c →
    (QuotientAddGroup.leftRel s) ((fun b => f a.1 + ↑b) b) ((fun b => f a.1 + ↑b) c)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `QuotientAddGroup.leftRel x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Order.krullDim_nat : Order.krullDim ℕ = ⊤
Result.success

Testing || PNat.gcd_comm : ∀ {m n : ℕ+}, m.gcd n = n.gcd m
Result.exception ::
Duper saturated

Testing || TrivSqZeroExt.map_comp_inlAlgHom : ∀ {R' : Type u} {M : Type v} [inst : CommSemiring R'] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R' M]
  [inst_3 : _root_.Module R'ᵐᵒᵖ M] [inst_4 : IsCentralScalar R' M] {N : Type u_3} [inst_5 : AddCommMonoid N]
  [inst_6 : _root_.Module R' N] [inst_7 : _root_.Module R'ᵐᵒᵖ N] [inst_8 : IsCentralScalar R' N] (f : M →ₗ[R'] N),
  (TrivSqZeroExt.map f).comp (TrivSqZeroExt.inlAlgHom R' R' M) = TrivSqZeroExt.inlAlgHom R' R' N
Result.exception ::
Duper saturated

Testing || Matrix.toLinearMapₛₗ₂'_symm : ∀ {R : Type u_1} {R₁ : Type u_2} {S₁ : Type u_3} {R₂ : Type u_4} {S₂ : Type u_5} {N₂ : Type u_10} {n : Type u_11}
  {m : Type u_12} [inst : CommSemiring R] [inst_1 : AddCommMonoid N₂] [inst_2 : _root_.Module R N₂]
  [inst_3 : Semiring R₁] [inst_4 : Semiring R₂] [inst_5 : Semiring S₁] [inst_6 : Semiring S₂]
  [inst_7 : _root_.Module S₁ N₂] [inst_8 : _root_.Module S₂ N₂] [inst_9 : SMulCommClass S₁ R N₂]
  [inst_10 : SMulCommClass S₂ R N₂] [inst_11 : SMulCommClass S₂ S₁ N₂] (σ₁ : R₁ →+* S₁) (σ₂ : R₂ →+* S₂)
  [inst_12 : Fintype n] [inst_13 : Fintype m] [inst_14 : DecidableEq n] [inst_15 : DecidableEq m],
  (Matrix.toLinearMapₛₗ₂' R σ₁ σ₂).symm = LinearMap.toMatrixₛₗ₂' R
Result.success

Testing || AlgebraicGeometry.PresheafedSpace.Hom.ext : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {X Y : AlgebraicGeometry.PresheafedSpace C}
  (α β : X.Hom Y) (w : α.base = β.base),
  CategoryTheory.CategoryStruct.comp α.c (CategoryTheory.whiskerRight (CategoryTheory.eqToHom ⋯) X.presheaf) = β.c →
    α = β
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.CategoryStruct.id
  x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || DiscreteQuotient.leComap_id_iff : ∀ {X : Type u_2} [inst : TopologicalSpace X] {A A' : DiscreteQuotient X},
  DiscreteQuotient.LEComap (ContinuousMap.id X) A A' ↔ A ≤ A'
Result.success

Testing || String.Pos.mk_le_mk : ∀ {i₁ i₂ : ℕ}, { byteIdx := i₁ } ≤ { byteIdx := i₂ } ↔ i₁ ≤ i₂
Result.success

Testing || one_div_mul_add_mul_one_div_eq_one_div_add_one_div : ∀ {K : Type u_1} [inst : DivisionSemiring K] {a b : K}, a ≠ 0 → b ≠ 0 → 1 / a * (a + b) * (1 / b) = 1 / a + 1 / b
Result.success

Testing || MeasureTheory.Measure.restrict_add_restrict_compl : ∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α},
  MeasurableSet s → μ.restrict s + μ.restrict sᶜ = μ
Result.success

Testing || SupClosed.preimage : ∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} [inst : SemilatticeSup α] [inst_1 : SemilatticeSup β] {s : Set α}
  [inst_2 : FunLike F β α] [inst_3 : SupHomClass F β α], SupClosed s → ∀ (f : F), SupClosed (⇑f ⁻¹' s)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #3, (∀ x1 : #3, ((!8 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || ContMDiffAt.neg : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}
  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace 𝕜 E] {I : ModelWithCorners 𝕜 E H} {G : Type u_4}
  [inst_4 : TopologicalSpace G] [inst_5 : ChartedSpace H G] [inst_6 : AddGroup G] [inst_7 : LieAddGroup I G]
  {E' : Type u_5} [inst_8 : NormedAddCommGroup E'] [inst_9 : NormedSpace 𝕜 E'] {H' : Type u_6}
  [inst_10 : TopologicalSpace H'] {I' : ModelWithCorners 𝕜 E' H'} {M : Type u_7} [inst_11 : TopologicalSpace M]
  [inst_12 : ChartedSpace H' M] {n : ℕ∞} {f : M → G} {x₀ : M},
  ContMDiffAt I' I n f x₀ → ContMDiffAt I' I n (fun x => -f x) x₀
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Cardinal.lift_umax : Cardinal.lift.{max u v, u} = Cardinal.lift.{v, u}
Result.exception ::
Duper saturated

Testing || TypeVec.fst_diag : ∀ {n : ℕ} {α : TypeVec.{u_1} n}, TypeVec.comp TypeVec.prod.fst TypeVec.prod.diag = TypeVec.id
Result.exception ::
Duper saturated

Testing || Real.zero_rpow_le_one : ∀ (x : ℝ), 0 ^ x ≤ 1
Result.success

Testing || LieSubalgebra.isNilpotent_ad_of_isNilpotent_ad : ∀ {R : Type u} [inst : CommRing R] {L : Type v} [inst_1 : LieRing L] [inst_2 : LieAlgebra R L] (K : LieSubalgebra R L)
  {x : ↥K}, IsNilpotent ((LieAlgebra.ad R L) ↑x) → IsNilpotent ((LieAlgebra.ad R ↥K) x)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Grothendieck.grothendieckTypeToCat_unitIso_inv_app_fiber : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (G : CategoryTheory.Functor C (Type w))
  (X : CategoryTheory.Grothendieck (G.comp CategoryTheory.typeToCat)),
  ((CategoryTheory.Grothendieck.grothendieckTypeToCat G).unitIso.inv.app X).fiber = CategoryTheory.eqToHom ⋯
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: G.obj X.base ⟶ G.obj X.base is not a `∀`

Testing || MvPolynomial.sum_eval_eq_zero : ∀ {K : Type u_1} {σ : Type u_2} [inst : Fintype K] [inst_1 : Field K] [inst_2 : Fintype σ] [inst_3 : DecidableEq σ]
  (f : MvPolynomial σ K),
  f.totalDegree < (Fintype.card K - 1) * Fintype.card σ → ∑ x : σ → K, (MvPolynomial.eval x) f = 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.univ`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || convex_halfSpace_re_le : ∀ (r : ℝ), Convex ℝ {c | c.re ≤ r}
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || interior_halfspace : ∀ {n : ℕ} (p : ENNReal) (a : ℝ) (i : Fin n), interior {y | a ≤ y i} = {y | a < y i}
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In α →
  Prop, type of ∀ bound variable is not of sort `Prop`, and depends on bound variables

Testing || Pi.negPart_apply : ∀ {ι : Type u_2} {α : ι → Type u_3} [inst : (i : ι) → Lattice (α i)] [inst_1 : (i : ι) → AddGroup (α i)]
  (f : (i : ι) → α i) (i : ι), f⁻ i = (f i)⁻
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #1, ((!2 (x0 !4)) = (!0 x0))) is not type correct

Testing || AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structurePresheafInCommRing_map_apply : ∀ {R : Type u_1} {A : Type u_2} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (𝒜 : ℕ → Submodule R A)
  [inst_3 : GradedAlgebra 𝒜] {X Y : (TopologicalSpace.Opens ↑(ProjectiveSpectrum.top 𝒜))ᵒᵖ} (i : X ⟶ Y)
  (a : (AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structureSheafInType 𝒜).val.obj X),
  ((AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structurePresheafInCommRing 𝒜).map i) a =
    (AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structureSheafInType 𝒜).val.map i a
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: (AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structureSheafInType
          𝒜).val.obj
    X✝ ⟶
  (AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structureSheafInType 𝒜).val.obj Y✝ is not a `∀`

Testing || CategoryTheory.Adjunction.hasLimitsOfShape_of_equivalence : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {J : Type u} [inst_2 : CategoryTheory.Category.{v, u} J] (E : CategoryTheory.Functor D C) [inst_3 : E.IsEquivalence]
  [inst : CategoryTheory.Limits.HasLimitsOfShape J C], CategoryTheory.Limits.HasLimitsOfShape J D
Result.exception ::
Duper saturated

Testing || HasProd.update' : ∀ {α : Type u_4} {β : Type u_5} [inst : TopologicalSpace α] [inst_1 : CommMonoid α] [inst_2 : T2Space α]
  [inst_3 : ContinuousMul α] [inst_4 : DecidableEq β] {f : β → α} {a a' : α},
  HasProd f a → ∀ (b : β) (x : α), HasProd (Function.update f b x) a' → a * x = a' * f b
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Matrix.trace_transpose : ∀ {n : Type u_3} {R : Type u_6} [inst : Fintype n] [inst_1 : AddCommMonoid R] (A : Matrix n n R),
  A.transpose.trace = A.trace
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix n n R is not a `∀`

Testing || CategoryTheory.Cat.freeRefl_obj_str_comp : ∀ (V : CategoryTheory.ReflQuiv) ⦃a b c : CategoryTheory.Quotient CategoryTheory.Cat.FreeReflRel⦄
  (a_1 : CategoryTheory.Quotient.Hom CategoryTheory.Cat.FreeReflRel a b)
  (a_2 : CategoryTheory.Quotient.Hom CategoryTheory.Cat.FreeReflRel b c),
  CategoryTheory.CategoryStruct.comp a_1 a_2 = CategoryTheory.Quotient.comp CategoryTheory.Cat.FreeReflRel a_1 a_2
Result.success

Testing || TensorProduct.add_tmul : ∀ {R : Type u_1} [inst : CommSemiring R] {M : Type u_4} {N : Type u_5} [inst_1 : AddCommMonoid M]
  [inst_2 : AddCommMonoid N] [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R N] (m₁ m₂ : M) (n : N),
  (m₁ + m₂) ⊗ₜ[R] n = m₁ ⊗ₜ[R] n + m₂ ⊗ₜ[R] n
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `⟦x_1⟧`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || toZ_of_ge : ∀ {ι : Type u_1} [inst : LinearOrder ι] [inst_1 : SuccOrder ι] [inst_2 : IsSuccArchimedean ι] [inst_3 : PredOrder ι]
  {i0 i : ι} (hi : i0 ≤ i), toZ i0 i = ↑(Nat.find ⋯)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀ (h : i0 ≤ i),
  ⋯ = ⋯, type of dependent ∀ bound variable is of sort `Prop`

Testing || ContinuousAlternatingMap.ofSubsingleton_apply_toContinuousMultilinearMap : ∀ (R : Type u_1) (M : Type u_2) (N : Type u_4) {ι : Type u_6} [inst : Semiring R] [inst_1 : AddCommMonoid M]
  [inst_2 : _root_.Module R M] [inst_3 : TopologicalSpace M] [inst_4 : AddCommMonoid N] [inst_5 : _root_.Module R N]
  [inst_6 : TopologicalSpace N] [inst_7 : Subsingleton ι] (i : ι) (f : M →L[R] N),
  ((ContinuousAlternatingMap.ofSubsingleton R M N i) f).toContinuousMultilinearMap =
    (ContinuousMultilinearMap.ofSubsingleton R M N i) f
Result.success

Testing || TopologicalGroup.of_comm_of_nhds_one : ∀ {G : Type u} [inst : CommGroup G] [inst_1 : TopologicalSpace G],
  Filter.Tendsto (Function.uncurry fun x1 x2 => x1 * x2) (nhds 1 ×ˢ nhds 1) (nhds 1) →
    Filter.Tendsto (fun x => x⁻¹) (nhds 1) (nhds 1) →
      (∀ (x₀ : G), nhds x₀ = Filter.map (fun x => x₀ * x) (nhds 1)) → TopologicalGroup G
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Filter.ZeroAtFilter.boundedAtFilter : ∀ {α : Type u_2} {β : Type u_3} [inst : SeminormedAddGroup β] {l : Filter α} {f : α → β},
  l.ZeroAtFilter f → l.BoundedAtFilter f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_3 =o[x_1] fun _x => cifvar_19`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Turing.ListBlank.nth_mk : ∀ {Γ : Type u_1} [inst : Inhabited Γ] (l : List Γ) (n : ℕ), (Turing.ListBlank.mk l).nth n = l.getI n
Result.success

Testing || CategoryTheory.epi_iff_surjective : ∀ {X Y : Type u} (f : X ⟶ Y), CategoryTheory.Epi f ↔ Function.Surjective f
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (¬ ((!0 !1) ↔ (!2 !1))) is not type correct

Testing || Multiset.le_prod_of_submultiplicative_on_pred : ∀ {α : Type u_2} {β : Type u_3} [inst : CommMonoid α] [inst_1 : OrderedCommMonoid β] (f : α → β) (p : α → Prop),
  f 1 = 1 →
    p 1 →
      (∀ (a b : α), p a → p b → f (a * b) ≤ f a * f b) →
        (∀ (a b : α), p a → p b → p (a * b)) → ∀ (s : Multiset α), (∀ a ∈ s, p a) → f s.prod ≤ (Multiset.map f s).prod
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_6 a x_2 ≤ cifvar_6 a x_3`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Fin.sum_univ_six : ∀ {β : Type u_2} [inst : AddCommMonoid β] (f : Fin 6 → β), ∑ i : Fin 6, f i = f 0 + f 1 + f 2 + f 3 + f 4 + f 5
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.isRotated_singleton_iff : ∀ {α : Type u} {l : List α} {x : α}, l ~r [x] ↔ l = [x]
Result.exception ::
Duper saturated

Testing || CategoryTheory.Equivalence.changeInverse_counitIso_hom_app : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  (e : C ≌ D) {G : CategoryTheory.Functor D C} (iso : e.inverse ≅ G) (X : D),
  (e.changeInverse iso).counitIso.hom.app X =
    CategoryTheory.CategoryStruct.comp (e.functor.map (iso.inv.app X)) (e.counitIso.hom.app X)
Result.success

Testing || CategoryTheory.comp_eqToHom_heq : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {X Y Z : C} (f : X ⟶ Y) (h : Y = Z),
  HEq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom h)) f
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀ (p : X = X),
  CategoryTheory.eqToHom p = CategoryTheory.CategoryStruct.id X, type of dependent ∀ bound variable is of sort `Prop`

Testing || Multiset.toFinset_nsmul : ∀ {α : Type u_1} [inst : DecidableEq α] (s : Multiset α) (n : ℕ), n ≠ 0 → (n • s).toFinset = s.toFinset
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Quotient.out_eq' : ∀ {α : Sort u_1} {s₁ : Setoid α} (q : Quotient s₁), Quotient.mk'' q.out = q
Result.success

Testing || IsLocalizedModule.mk'_add : ∀ {R : Type u_1} [inst : CommSemiring R] {S : Submonoid R} {M : Type u_2} {M' : Type u_3} [inst_1 : AddCommMonoid M]
  [inst_2 : AddCommMonoid M'] [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R M'] (f : M →ₗ[R] M')
  [inst_5 : IsLocalizedModule S f] (m₁ m₂ : M) (s : ↥S),
  IsLocalizedModule.mk' f (m₁ + m₂) s = IsLocalizedModule.mk' f m₁ s + IsLocalizedModule.mk' f m₂ s
Result.success

Testing || IntermediateField.equivOfEq_symm : ∀ {F : Type u_1} [inst : Field F] {E : Type u_2} [inst_1 : Field E] [inst_2 : Algebra F E] {S T : IntermediateField F E}
  (h : S = T), (IntermediateField.equivOfEq h).symm = IntermediateField.equivOfEq ⋯
Result.success

Testing || MeasureTheory.eLpNormEssSup_const : ∀ {α : Type u_1} {F : Type u_3} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : NormedAddCommGroup F]
  (c : F), μ ≠ 0 → MeasureTheory.eLpNormEssSup (fun x => c) μ = ↑‖c‖₊
Result.success

Testing || Ideal.map_radical_of_surjective : ∀ {R : Type u_1} {S : Type u_2} [inst : CommRing R] [inst_1 : CommRing S] {f : R →+* S},
  Function.Surjective ⇑f → ∀ {I : Ideal R}, RingHom.ker f ≤ I → Ideal.map f I.radical = (Ideal.map f I).radical
Result.exception ::
Duper saturated

Testing || Submodule.smul_torsionBy : ∀ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M] (a : R)
  (x : ↥(Submodule.torsionBy R M a)), a • x = 0
Result.exception ::
Duper saturated

Testing || dite_ite_distrib_right : ∀ {α : Sort u_1} {p q : Prop} [inst : Decidable p] [inst_1 : Decidable q] {a b : p → α} {c : ¬p → α},
  dite p (fun hp => if q then a hp else b hp) c = if q then dite p a c else dite p b c
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Limits.cofan_mk_inj : ∀ {β : Type w} {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {f : β → C} (P : C) (p : (b : β) → f b ⟶ P)
  (j : β), (CategoryTheory.Limits.Cofan.mk P p).inj j = p j
Result.success

Testing || Mathlib.Tactic.Monoidal.evalHorizontalCompAux'_whisker : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.MonoidalCategory C] {f f' g g' h : C}
  {η : g ⟶ h} {θ : f' ⟶ g'}
  {ηθ : CategoryTheory.MonoidalCategory.tensorObj g f' ⟶ CategoryTheory.MonoidalCategory.tensorObj h g'}
  {η₁ :
    CategoryTheory.MonoidalCategory.tensorObj f (CategoryTheory.MonoidalCategory.tensorObj g f') ⟶
      CategoryTheory.MonoidalCategory.tensorObj f (CategoryTheory.MonoidalCategory.tensorObj h g')}
  {η₂ :
    CategoryTheory.MonoidalCategory.tensorObj f (CategoryTheory.MonoidalCategory.tensorObj g f') ⟶
      CategoryTheory.MonoidalCategory.tensorObj (CategoryTheory.MonoidalCategory.tensorObj f h) g'}
  {η₃ :
    CategoryTheory.MonoidalCategory.tensorObj (CategoryTheory.MonoidalCategory.tensorObj f g) f' ⟶
      CategoryTheory.MonoidalCategory.tensorObj (CategoryTheory.MonoidalCategory.tensorObj f h) g'},
  CategoryTheory.MonoidalCategory.tensorHom η θ = ηθ →
    CategoryTheory.MonoidalCategory.whiskerLeft f ηθ = η₁ →
      CategoryTheory.CategoryStruct.comp η₁ (CategoryTheory.MonoidalCategory.associator f h g').inv = η₂ →
        CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.associator f g f').hom η₂ = η₃ →
          CategoryTheory.MonoidalCategory.tensorHom (CategoryTheory.MonoidalCategory.whiskerLeft f η) θ = η₃
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.MonoidalCategory.whiskerLeft
  x_0 x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Subring.mem_bot : ∀ {R : Type u} [inst : Ring R] {x : R}, x ∈ ⊥ ↔ ∃ n, ↑n = x
Result.success

Testing || MeasurableSet.cylinder : ∀ {ι : Type u_2} {α : ι → Type u_1} [inst : (i : ι) → MeasurableSpace (α i)] (s : Finset ι)
  {S : Set ((i : { x // x ∈ s }) → α ↑i)}, MeasurableSet S → MeasurableSet (MeasureTheory.cylinder s S)
Result.exception ::
Duper saturated

Testing || IsSelfAdjoint.zpow : ∀ {R : Type u_1} [inst : Group R] [inst_1 : StarMul R] {x : R}, IsSelfAdjoint x → ∀ (n : ℤ), IsSelfAdjoint (x ^ n)
Result.success

Testing || CliffordAlgebra.ofBaseChange_comp_toBaseChange : ∀ {R : Type u_1} (A : Type u_2) {V : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : AddCommGroup V]
  [inst_3 : Algebra R A] [inst_4 : _root_.Module R V] [inst_5 : Invertible 2] (Q : QuadraticForm R V),
  (CliffordAlgebra.ofBaseChange A Q).comp (CliffordAlgebra.toBaseChange A Q) =
    AlgHom.id A (CliffordAlgebra (QuadraticForm.baseChange A Q))
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || uniformEquicontinuousOn_unique : ∀ {ι : Type u_1} {α : Type u_6} {β : Type u_8} [uα : UniformSpace α] [uβ : UniformSpace β] [inst : Unique ι]
  {F : ι → β → α} {S : Set β}, UniformEquicontinuousOn F S ↔ UniformContinuousOn (F default) S
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Metric.continuous_infNndist_pt : ∀ {α : Type u} [inst : PseudoMetricSpace α] (s : Set α), Continuous fun x => Metric.infNndist x s
Result.success

Testing || IntermediateField.pow_mem : ∀ {K : Type u_1} {L : Type u_2} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] (S : IntermediateField K L)
  {x : L}, x ∈ S → ∀ (n : ℤ), x ^ n ∈ S
Result.success

Testing || CochainComplex.HomComplex.Cochain.map_comp : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C]
  {F G : CochainComplex C ℤ} (K : CochainComplex C ℤ) {D : Type u_2} [inst_2 : CategoryTheory.Category.{u_3, u_2} D]
  [inst_3 : CategoryTheory.Preadditive D] {n₁ n₂ n₁₂ : ℤ} (z₁ : CochainComplex.HomComplex.Cochain F G n₁)
  (z₂ : CochainComplex.HomComplex.Cochain G K n₂) (h : n₁ + n₂ = n₁₂) (Φ : CategoryTheory.Functor C D)
  [inst_4 : Φ.Additive], (z₁.comp z₂ h).map Φ = (z₁.map Φ).comp (z₂.map Φ) h
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ModelWithCorners.toHomeomorph_apply : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] (I : ModelWithCorners 𝕜 E H)
  [inst_4 : I.Boundaryless] (a : H), I.toHomeomorph a = ↑I a
Result.success

Testing || isBot_iff_isMin : ∀ {α : Type u} [inst : Preorder α] {a : α} [inst_1 : IsDirected α fun x1 x2 => x1 ≥ x2], IsBot a ↔ IsMin a
Result.success

Testing || Cardinal.toPartENat_lift : ∀ (c : Cardinal.{v}), Cardinal.toPartENat (Cardinal.lift.{u, v} c) = Cardinal.toPartENat c
Result.exception ::
Duper saturated

Testing || AlgHom.range_comp_le_range : ∀ {R : Type u} {A : Type v} {B : Type w} {C : Type w'} [inst : CommSemiring R] [inst_1 : Semiring A]
  [inst_2 : Algebra R A] [inst_3 : Semiring B] [inst_4 : Algebra R B] [inst_5 : Semiring C] [inst_6 : Algebra R C]
  (f : A →ₐ[R] B) (g : B →ₐ[R] C), (g.comp f).range ≤ g.range
Result.exception ::
Duper saturated

Testing || DifferentiableWithinAt.const_cpow : ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] {f : E → ℂ} {x : E} {s : Set E} {c : ℂ},
  DifferentiableWithinAt ℂ f s x → c ≠ 0 ∨ f x ≠ 0 → DifferentiableWithinAt ℂ (fun x => c ^ f x) s x
Result.success

Testing || SetTheory.PGame.memₗ.congr_left : ∀ {x y : SetTheory.PGame}, x.Identical y → ∀ {w : SetTheory.PGame}, x.memₗ w ↔ y.memₗ w
Result.exception ::
Duper saturated

Testing || iSup_inf_eq : ∀ {α : Type u} {ι : Sort w} [inst : Order.Frame α] (f : ι → α) (a : α), (⨆ i, f i) ⊓ a = ⨆ i, f i ⊓ a
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a ∈ x_0 of λ binder contains bound variables

Testing || MulHom.coe_coe : ∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Mul M] [inst_1 : Mul N] [inst_2 : FunLike F M N]
  [inst_3 : MulHomClass F M N] (f : F), ⇑↑f = ⇑f
Result.exception ::
Duper saturated

Testing || PresheafOfModules.toSheaf_map_sheafificationHomEquiv_symm : ∀ {C : Type u'} [inst : CategoryTheory.Category.{v', u'} C] {J : CategoryTheory.GrothendieckTopology C}
  {R₀ : CategoryTheory.Functor Cᵒᵖ RingCat} {R : CategoryTheory.Sheaf J RingCat} (α : R₀ ⟶ R.val)
  [inst_1 : CategoryTheory.Presheaf.IsLocallyInjective J α] [inst_2 : CategoryTheory.Presheaf.IsLocallySurjective J α]
  [inst_3 : J.WEqualsLocallyBijective AddCommGrp] [inst_4 : CategoryTheory.HasWeakSheafify J AddCommGrp]
  {P : PresheafOfModules R₀} {F : SheafOfModules R}
  (g : P ⟶ (PresheafOfModules.restrictScalars α).obj ((SheafOfModules.forget R).obj F)),
  (SheafOfModules.toSheaf R).map ((PresheafOfModules.sheafificationHomEquiv α).symm g) =
    ((CategoryTheory.sheafificationAdjunction J AddCommGrp).homEquiv P.presheaf ((SheafOfModules.toSheaf R).obj F)).symm
      ((PresheafOfModules.toPresheaf R₀).map g)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || compl_bihimp_self : ∀ {α : Type u_2} [inst : HeytingAlgebra α] (a : α), bihimp aᶜ a = ⊥
Result.exception ::
Duper saturated

Testing || CategoryTheory.ShortComplex.RightHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork_φQ : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  (S : CategoryTheory.ShortComplex C) (hf : S.f = 0) (hg : S.g = 0) (c : CategoryTheory.Limits.KernelFork S.g)
  (hc : CategoryTheory.Limits.IsLimit c),
  (CategoryTheory.ShortComplex.RightHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc).φQ =
    CategoryTheory.CategoryStruct.id (CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork S hf c hc).Q
Result.success

Testing || Basis.card_le_card_of_linearIndependent : ∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  [inst_3 : StrongRankCondition R] {ι : Type u_1} [inst_4 : Fintype ι],
  Basis ι R M →
    ∀ {ι' : Type u_2} [inst_5 : Fintype ι'] {v : ι' → M}, LinearIndependent R v → Fintype.card ι' ≤ Fintype.card ι
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `List.Perm.length_eq`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Orientation.rotation_trans : ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : Fact (Module.finrank ℝ V = 2)]
  (o : Orientation ℝ V (Fin 2)) (θ₁ θ₂ : Real.Angle), (o.rotation θ₁).trans (o.rotation θ₂) = o.rotation (θ₂ + θ₁)
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || IsPrimitiveRoot.sub_one_norm_isPrimePow : ∀ {n : ℕ+} {K : Type u} {L : Type v} [inst : Field L] {ζ : L} [inst_1 : Field K] [inst_2 : Algebra K L],
  IsPrimitiveRoot ζ ↑n →
    IsPrimePow ↑n →
      ∀ [inst_3 : IsCyclotomicExtension {n} K L],
        Irreducible (Polynomial.cyclotomic (↑n) K) → n ≠ 2 → (Algebra.norm K) (ζ - 1) = ↑(↑n).minFac
Result.exception ::
Auto.Monomorphization.FVarRep.constInst2FVarId :: Cannot find canonicalized instance of ConstInst ⦗⦗ Fact ⦘⦘

Testing || Stream'.tail_eq_drop : ∀ {α : Type u} (s : Stream' α), s.tail = Stream'.drop 1 s
Result.success

Testing || UniformEquiv.piCongrRight_apply : ∀ {ι : Type u_4} {β₁ : ι → Type u_5} {β₂ : ι → Type u_6} [inst : (i : ι) → UniformSpace (β₁ i)]
  [inst_1 : (i : ι) → UniformSpace (β₂ i)] (F : (i : ι) → β₁ i ≃ᵤ β₂ i) (a : (i : ι) → β₁ i) (i : ι),
  (UniformEquiv.piCongrRight F) a i = (F i) (a i)
Result.exception ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || Matrix.mulVec_empty : ∀ {α : Type u} {m' : Type uₘ} [inst : NonUnitalNonAssocSemiring α] (A : Matrix m' (Fin 0) α) (v : Fin 0 → α),
  A.mulVec v = 0
Result.success

Testing || MvPolynomial.isHomogeneous_C : ∀ (σ : Type u_1) {R : Type u_3} [inst : CommSemiring R] (r : R), (MvPolynomial.C r).IsHomogeneous 0
Result.exception ::
Duper saturated

Testing || NonUnitalStarSubalgebra.mem_map : ∀ {F : Type v'} {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : NonUnitalNonAssocSemiring A]
  [inst_2 : _root_.Module R A] [inst_3 : Star A] [inst_4 : NonUnitalNonAssocSemiring B] [inst_5 : _root_.Module R B]
  [inst_6 : Star B] [inst_7 : FunLike F A B] [inst_8 : NonUnitalAlgHomClass F R A B] [inst_9 : StarHomClass F A B]
  {S : NonUnitalStarSubalgebra R A} {f : F} {y : B}, y ∈ NonUnitalStarSubalgebra.map f S ↔ ∃ x ∈ S, f x = y
Result.success

Testing || uniqueDiffWithinAt_Iio : ∀ (a : ℝ), UniqueDiffWithinAt ℝ (Set.Iio a) a
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #0, (∀ x1 : #1, ((!6 (!0 x0) x1) = (!0 x0 x1)))) is not type correct

Testing || strictMonoOn_Ici_of_pred_lt : ∀ {α : Type u_1} {β : Type u_2} [inst : PartialOrder α] [inst_1 : Preorder β] {ψ : α → β} [inst_2 : PredOrder α]
  [inst_3 : IsPredArchimedean α] {n : α}, (∀ (m : α), n < m → ψ (Order.pred m) < ψ m) → StrictMonoOn ψ (Set.Ici n)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Order.succ m`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || groupCohomology.twoCocycles_ext : ∀ {k G : Type u} [inst : CommRing k] [inst_1 : Group G] {A : Rep k G} {f₁ f₂ : ↥(groupCohomology.twoCocycles A)},
  (∀ (g h : G), f₁ (g, h) = f₂ (g, h)) → f₁ = f₂
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || BitVec.getMsbD_one : ∀ {w i : ℕ}, (1#w).getMsbD i = (decide (i = w - 1) && decide (0 < w))
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `BitVec.ofNat x_0 cifvar_4`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || NormedSpace.exp_zero : ∀ {𝕂 : Type u_1} {𝔸 : Type u_2} [inst : Field 𝕂] [inst_1 : Ring 𝔸] [inst_2 : Algebra 𝕂 𝔸] [inst_3 : TopologicalSpace 𝔸]
  [inst_4 : TopologicalRing 𝔸], NormedSpace.exp 𝕂 0 = 1
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: FormalMultilinearSeries 𝕂 𝔸 𝔸 is not a `∀`

Testing || MeromorphicOn.inv_iff : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {s : 𝕜 → 𝕜} {U : Set 𝕜}, MeromorphicOn s⁻¹ U ↔ MeromorphicOn s U
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WithLp.prod_norm_equiv_symm : ∀ {α : Type u_2} {β : Type u_3} [inst : SeminormedAddCommGroup α] [inst_1 : SeminormedAddCommGroup β] (f : α × β),
  ‖(WithLp.equiv ⊤ (α × β)).symm f‖ = ‖f‖
Result.success

Testing || Ordinal.add_omega0_opow : ∀ {a b : Ordinal.{u}}, a < Ordinal.omega0 ^ b → a + Ordinal.omega0 ^ b = Ordinal.omega0 ^ b
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Module.AEval.isTorsion_of_aeval_eq_zero : ∀ {R : Type u_1} {M : Type u_3} {A : Type u_4} {a : A} [inst : CommSemiring R] [inst_1 : NoZeroDivisors R]
  [inst_2 : Semiring A] [inst_3 : Algebra R A] [inst_4 : AddCommMonoid M] [inst_5 : _root_.Module A M]
  [inst_6 : _root_.Module R M] [inst_7 : IsScalarTower R A M] {p : Polynomial R},
  (Polynomial.aeval a) p = 0 → p ≠ 0 → Module.IsTorsion (Polynomial R) (Module.AEval R M a)
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MeasureTheory.ae_toFiniteAux : ∀ {α : Type u_1} {mα : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : MeasureTheory.SFinite μ],
  MeasureTheory.ae μ.toFiniteAux = MeasureTheory.ae μ
Result.exception ::
Duper saturated

Testing || Topology.IsEmbedding.restrictPreimage : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β} (s : Set β),
  Topology.IsEmbedding f → Topology.IsEmbedding (s.restrictPreimage f)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instTopologicalSpaceSubtype`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AddSubmonoid.unop_closure : ∀ {M : Type u_2} [inst : AddZeroClass M] (s : Set Mᵃᵒᵖ),
  (AddSubmonoid.closure s).unop = AddSubmonoid.closure (AddOpposite.op ⁻¹' s)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Monoid.Coprod.fst_apply_inl : ∀ {M : Type u_1} {N : Type u_2} [inst : Monoid M] [inst_1 : Monoid N] (x : M),
  Monoid.Coprod.fst (Monoid.Coprod.inl x) = x
Result.success

Testing || SemidirectProduct.rightHom_comp_inr : ∀ {N : Type u_1} {G : Type u_2} [inst : Group N] [inst_1 : Group G] {φ : G →* MulAut N},
  SemidirectProduct.rightHom.comp SemidirectProduct.inr = MonoidHom.id G
Result.success

Testing || Equiv.uniformEmbedding : ∀ {α : Type u_1} {β : Type u_2} [inst : UniformSpace α] [inst_1 : UniformSpace β] (f : α ≃ β),
  UniformContinuous ⇑f → UniformContinuous ⇑f.symm → IsUniformEmbedding ⇑f
Result.success

Testing || Set.LeftInvOn.eq : ∀ {α : Type u_1} {β : Type u_2} {s : Set α} {f : α → β} {f' : β → α},
  Set.LeftInvOn f' f s → ∀ {x : α}, x ∈ s → f' (f x) = x
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #1, (∀ x1 : #1, ((!4 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || Multiset.mem_powersetAux : ∀ {α : Type u_1} {l : List α} {s : Multiset α}, s ∈ Multiset.powersetAux l ↔ s ≤ ↑l
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Topology.IsEmbedding.t2Space : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] [inst_2 : T2Space Y]
  {f : X → Y}, Topology.IsEmbedding f → T2Space X
Result.success

Testing || Option.isSome_unattach : ∀ {α : Type u_1} {p : α → Prop} {o : Option { x // p x }}, o.unattach.isSome = o.isSome
Result.success

Testing || AddChar.zmod_char_ne_one_iff : ∀ {C : Type v} [inst : CommMonoid C] (n : ℕ) [inst_1 : NeZero n] (ψ : AddChar (ZMod n) C), ψ ≠ 1 ↔ ψ 1 ≠ 1
Result.exception ::
Duper saturated

Testing || IsAddUnit.add : ∀ {M : Type u_1} [inst : AddMonoid M] {a b : M}, IsAddUnit a → IsAddUnit b → IsAddUnit (a + b)
Result.exception ::
Duper saturated

Testing || Polynomial.eval₂_C_X : ∀ {R : Type u} [inst : Semiring R] {p : Polynomial R}, Polynomial.eval₂ Polynomial.C Polynomial.X p = p
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MeasureTheory.AEEqFun.pair_eq_mk : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α}
  [inst_1 : TopologicalSpace β] [inst_2 : TopologicalSpace γ] (f : α →ₘ[μ] β) (g : α →ₘ[μ] γ),
  f.pair g = MeasureTheory.AEEqFun.mk (fun x => (↑f x, ↑g x)) ⋯
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `MeasureTheory.AEEqFun.aestronglyMeasurable
  x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Multiset.card_mono : ∀ {α : Type u_1}, Monotone ⇑Multiset.card
Result.exception ::
Duper saturated

Testing || ContinuousMap.coe_copy : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (f : C(X, Y)) (f' : X → Y)
  (h : f' = ⇑f), ⇑(f.copy f' h) = f'
Result.exception ::
Duper saturated

Testing || Module.mapEvalEquiv_symm_apply : ∀ (R : Type u_1) (M : Type u_2) [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  [inst_3 : Module.IsReflexive R M] (W'' : Submodule R (Module.Dual R (Module.Dual R M))),
  (Module.mapEvalEquiv R M).symm W'' = Submodule.comap (Module.Dual.eval R M) W''
Result.success

Testing || ExceptCpsT.run_throw : ∀ {m : Type u_1 → Type u_2} {ε β : Type u_1} {e : ε} [inst : Monad m], (throw e).run = pure (Except.error e)
Result.success

Testing || Polynomial.hasseDeriv_X : ∀ {R : Type u_1} [inst : Semiring R] (k : ℕ), 1 < k → (Polynomial.hasseDeriv k) Polynomial.X = 0
Result.success

Testing || Array.get?_eq_get?_toList : ∀ {α : Type u_1} (a : Array α) (i : ℕ), a.get? i = a.toList.get? i
Result.success

Testing || Matroid.spanning_iff_exists_base_subset : ∀ {α : Type u_2} {M : Matroid α} {S : Set α}, autoParam (S ⊆ M.E) _auto✝ → (M.Spanning S ↔ ∃ B, M.Base B ∧ B ⊆ S)
Result.success

Testing || Sum.bnot_isRight : ∀ {α : Type u_1} {β : Type u_2} (x : α ⊕ β), (!decide (x.isRight = x.isLeft)) = true
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Function.zero_of_even_and_odd : ∀ {α : Type u_3} {β : Type u_4} [inst : AddCommGroup β] [inst_1 : NoZeroSMulDivisors ℕ β] {f : α → β} [inst_2 : Neg α],
  Function.Even f → Function.Odd f → f = 0
Result.exception ::
Duper saturated

Testing || groupCohomology.mem_oneCocycles_def : ∀ {k G : Type u} [inst : CommRing k] [inst_1 : Group G] {A : Rep k G} (f : G → CoeSort.coe A),
  f ∈ groupCohomology.oneCocycles A ↔ ∀ (g h : G), (A.ρ g) (f h) - f (g * h) + f g = 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Rep.instAddCommGroupCoe x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Real.mul_lt_sin : ∀ {x : ℝ}, 0 < x → x < Real.pi / 2 → 2 / Real.pi * x < Real.sin x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `GroupWithZero.toMonoidWithZero`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Finsupp.neLocus_neg : ∀ {α : Type u_1} {N : Type u_3} [inst : DecidableEq α] [inst_1 : DecidableEq N] [inst_2 : AddGroup N] (f g : α →₀ N),
  (-f).neLocus g = f.neLocus (-g)
Result.success

Testing || LinearMap.hasBasis_weakBilin : ∀ {𝕜 : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedField 𝕜] [inst_1 : AddCommGroup E]
  [inst_2 : _root_.Module 𝕜 E] [inst_3 : AddCommGroup F] [inst_4 : _root_.Module 𝕜 F] (B : E →ₗ[𝕜] F →ₗ[𝕜] 𝕜),
  (nhds 0).HasBasis B.toSeminormFamily.basisSets id
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `WeakBilin.instAddCommGroup x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MeasureTheory.snorm'_lt_top_of_snorm'_lt_top_of_exponent_le : ∀ {α : Type u_1} {E : Type u_2} {m : MeasurableSpace α} [inst : NormedAddCommGroup E] {μ : MeasureTheory.Measure α}
  {f : α → E} {p q : ℝ} [inst_1 : MeasureTheory.IsFiniteMeasure μ],
  MeasureTheory.AEStronglyMeasurable f μ →
    MeasureTheory.eLpNorm' f q μ < ⊤ → 0 ≤ p → p ≤ q → MeasureTheory.eLpNorm' f p μ < ⊤
Result.success

Testing || Algebra.TensorProduct.assoc_symm_tmul : ∀ (R : Type uR) {A : Type uA} {B : Type uB} {C : Type uC} [inst : CommSemiring R] [inst_1 : Semiring A]
  [inst_2 : Algebra R A] [inst_3 : Semiring B] [inst_4 : Algebra R B] [inst_5 : Semiring C] [inst_6 : Algebra R C]
  (a : A) (b : B) (c : C), (Algebra.TensorProduct.assoc R A B C).symm (a ⊗ₜ[R] b ⊗ₜ[R] c) = (a ⊗ₜ[R] b) ⊗ₜ[R] c
Result.success

Testing || MeasureTheory.integral_add : ∀ {α : Type u_1} {G : Type u_5} [inst : NormedAddCommGroup G] [inst_1 : NormedSpace ℝ G] {m : MeasurableSpace α}
  {μ : MeasureTheory.Measure α} {f g : α → G},
  MeasureTheory.Integrable f μ →
    MeasureTheory.Integrable g μ → ∫ (a : α), f a + g a ∂μ = ∫ (a : α), f a ∂μ + ∫ (a : α), g a ∂μ
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Classical.propDecidable
  (cifvar_0 x_1 x_0)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Finset.filter_empty : ∀ {α : Type u_1} (p : α → Prop) [inst : DecidablePred p], Finset.filter p ∅ = ∅
Result.success

Testing || ContinuousLinearMap.exist_extension_of_finiteDimensional_range : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : IsRCLikeNormedField 𝕜] {E : Type u_2} {F : Type u_3}
  [inst_2 : SeminormedAddCommGroup E] [inst_3 : NormedSpace 𝕜 E] [inst_4 : NormedAddCommGroup F]
  [inst_5 : NormedSpace 𝕜 F] {p : Submodule 𝕜 E} (f : ↥p →L[𝕜] F) [inst_6 : FiniteDimensional 𝕜 ↥(LinearMap.range f)],
  ∃ g, f = g.comp p.subtypeL
Result.exception ::
Duper saturated

Testing || MulDissociated.of_inv : ∀ {α : Type u_1} [inst : CommGroup α] {s : Set α}, MulDissociated s⁻¹ → MulDissociated s
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Equiv.Perm.support_cycleOf_eq_nil_iff : ∀ {α : Type u_2} {f : Equiv.Perm α} {x : α} [inst : DecidableEq α] [inst_1 : Fintype α],
  (f.cycleOf x).support = ∅ ↔ x ∉ f.support
Result.success

Testing || Pell.exists_of_not_isSquare : ∀ {d : ℤ}, 0 < d → ¬IsSquare d → ∃ x y, x ^ 2 - d * y ^ 2 = 1 ∧ y ≠ 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `AddCommGroupWithOne.toAddCommGroup`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.biproduct_ι_comp_leftDistributor_hom_assoc : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  [inst_2 : CategoryTheory.MonoidalCategory C] [inst_3 : CategoryTheory.MonoidalPreadditive C]
  [inst_4 : CategoryTheory.Limits.HasFiniteBiproducts C] {J : Type} [inst_5 : Fintype J] (X : C) (f : J → C) (j : J)
  {Z : C} (h : (⨁ fun j => CategoryTheory.MonoidalCategory.tensorObj X (f j)) ⟶ Z),
  CategoryTheory.CategoryStruct.comp
      (CategoryTheory.MonoidalCategory.whiskerLeft X (CategoryTheory.Limits.biproduct.ι f j))
      (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftDistributor X f).hom h) =
    CategoryTheory.CategoryStruct.comp
      (CategoryTheory.Limits.biproduct.ι (fun j => CategoryTheory.MonoidalCategory.tensorObj X (f j)) j) h
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_20.π j✝`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || UniformSpace.Completion.continuous_dist : ∀ {α : Type u} {β : Type v} [inst : PseudoMetricSpace α] [inst_1 : TopologicalSpace β]
  {f g : β → UniformSpace.Completion α}, Continuous f → Continuous g → Continuous fun x => dist (f x) (g x)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Continuous x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || RingEquiv.piEquivPiSubtypeProd_symm_apply : ∀ {ι : Type u_7} (p : ι → Prop) [inst : DecidablePred p] (Y : ι → Type u_8)
  [inst_1 : (i : ι) → NonUnitalNonAssocSemiring (Y i)] (f : ((i : { x // p x }) → Y ↑i) × ((i : { x // ¬p x }) → Y ↑i))
  (x : ι), (RingEquiv.piEquivPiSubtypeProd p Y).symm f x = if h : p x then f.1 ⟨x, h⟩ else f.2 ⟨x, h⟩
Result.exception ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || CochainComplex.HomComplex.Cocycle.δ_eq_zero : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C]
  {F G : CochainComplex C ℤ} {n : ℤ} (z : CochainComplex.HomComplex.Cocycle F G n) (m : ℤ),
  CochainComplex.HomComplex.δ n m ↑z = 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CochainComplex.HomComplex.δ
  cifvar_12 x_0 z`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MulEquiv.comapSubgroup_apply : ∀ {G : Type u_1} [inst : Group G] {H : Type u_5} [inst_1 : Group H] (f : G ≃* H) (H_1 : Subgroup H),
  f.comapSubgroup H_1 = Subgroup.comap (↑f) H_1
Result.success

Testing || EquivLike.coe_symm_comp_self : ∀ {α : Sort u} {β : Sort v} {F : Sort u_1} [inst : EquivLike F α β] (e : F), ⇑(↑e).symm ∘ ⇑e = id
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Functor.relativelyRepresentable.symmetry_snd_assoc : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {F : CategoryTheory.Functor C D} {Y : D} {b : C} {f' : F.obj b ⟶ Y} (hf' : F.relativelyRepresentable f') {a : C}
  {g : F.obj a ⟶ Y} (hg : F.relativelyRepresentable g) [inst_2 : F.Full] [inst_3 : F.Faithful] {Z : C} (h : b ⟶ Z),
  CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (CategoryTheory.CategoryStruct.comp (hg.snd f') h) =
    CategoryTheory.CategoryStruct.comp (hf'.fst' g) h
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.MorphismProperty D is not a `∀`

Testing || AddMonoid.Coprod.snd_apply_inr : ∀ {M : Type u_1} {N : Type u_2} [inst : AddMonoid M] [inst_1 : AddMonoid N] (x : N),
  AddMonoid.Coprod.snd (AddMonoid.Coprod.inr x) = x
Result.success

Testing || CategoryTheory.Limits.ι_comp_colimitRightOpIsoUnopLimit_hom_assoc : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {J : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} J]
  (F : CategoryTheory.Functor Jᵒᵖ C) [inst_2 : CategoryTheory.Limits.HasLimit F] (j : J) {Z : Cᵒᵖ}
  (h : Opposite.op (CategoryTheory.Limits.limit F) ⟶ Z),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F.rightOp j)
      (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitRightOpIsoUnopLimit F).hom h) =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F (Opposite.op j)).op h
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.Limits.colimit.ι
  (cifvar_43 cifvar_1) x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MeasureTheory.lintegral_singleton : ∀ {α : Type u_1} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : MeasurableSingletonClass α]
  (f : α → ENNReal) (a : α), ∫⁻ (x : α) in {a}, f x ∂μ = f a * μ {a}
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ContinuousMultilinearMap.norm_def : ∀ {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} [inst : NontriviallyNormedField 𝕜]
  [inst_1 : (i : ι) → SeminormedAddCommGroup (E i)] [inst_2 : (i : ι) → NormedSpace 𝕜 (E i)]
  [inst_3 : SeminormedAddCommGroup G] [inst_4 : NormedSpace 𝕜 G] [inst_5 : Fintype ι]
  (f : ContinuousMultilinearMap 𝕜 E G), ‖f‖ = sInf {c | 0 ≤ c ∧ ∀ (m : (i : ι) → E i), ‖f m‖ ≤ c * ∏ i : ι, ‖m i‖}
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `inst✝⁴ i`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.nil_product : ∀ {α : Type u_1} {β : Type u_2} (l : List β), [] ×ˢ l = []
Result.success

Testing || Std.DHashMap.getKeyD_erase : ∀ {α : Type u} {β : α → Type v} {x : BEq α} {x_1 : Hashable α} {m : Std.DHashMap α β} [inst : EquivBEq α]
  [inst : LawfulHashable α] {k a fallback : α},
  (m.erase k).getKeyD a fallback = if (k == a) = true then fallback else m.getKeyD a fallback
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Std.DHashMap.getKeyD.proof_1 m✝`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Set.iSup_iInf_of_monotone : ∀ {ι : Type u_1} {ι' : Type u_2} {α : Type u_3} [inst : Finite ι] [inst : Preorder ι'] [inst_1 : Nonempty ι']
  [inst_2 : IsDirected ι' fun x1 x2 => x1 ≤ x2] [inst_3 : Order.Frame α] {f : ι → ι' → α},
  (∀ (i : ι), Monotone (f i)) → ⨆ j, ⨅ i, f i j = ⨅ i, ⨆ j, f i j
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x✝ ∈ Set.univ of λ binder contains bound variables

Testing || Set.biUnion_le_eq_iUnion : ∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] {s : α → Set β}, ⋃ n, ⋃ m, ⋃ (_ : m ≤ n), s m = ⋃ n, s n
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type m ≤ n✝ of λ binder contains bound variables

Testing || CategoryTheory.Functor.LaxMonoidal.μ_natural_right : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u₂}
  [inst_2 : CategoryTheory.Category.{v₂, u₂} D] [inst_3 : CategoryTheory.MonoidalCategory D]
  (F : CategoryTheory.Functor C D) [inst_4 : F.LaxMonoidal] {X Y : C} (X' : C) (f : X ⟶ Y),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.whiskerLeft (F.obj X') (F.map f))
      (CategoryTheory.Functor.LaxMonoidal.μ F X' Y) =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.LaxMonoidal.μ F X' X)
      (F.map (CategoryTheory.MonoidalCategory.whiskerLeft X' f))
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.MonoidalCategory.whiskerLeft
  (cifvar_16 (cifvar_17 cifvar_18) x_0) (cifvar_4 x_1)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MulEquiv.toCommGrpIso_inv : ∀ {X Y : CommGrp} (e : ↑X ≃* ↑Y), e.toCommGrpIso.inv = e.symm.toMonoidHom
Result.success

Testing || ContinuousMap.one_apply : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] [inst_2 : _root_.One β]
  (x : α), 1 x = 1
Result.success

Testing || Submonoid.LocalizationMap.mk'_sec : ∀ {M : Type u_1} [inst : CommMonoid M] {S : Submonoid M} {N : Type u_2} [inst_1 : CommMonoid N]
  (f : S.LocalizationMap N) (z : N), f.mk' (f.sec z).1 (f.sec z).2 = z
Result.exception ::
Auto.Reif.resolveTy :: Unable to resolve ∀ (y : ↥S), IsUnit (f.toMonoidHom ↑y)

Testing || ZMod.exists : ∀ {n : ℕ} {P : ZMod n → Prop}, (∃ x, P x) ↔ ∃ x, P ↑x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `ZMod.commRing x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.getD_map : ∀ {α : Type u} {β : Type v} (l : List α) (d : α) {n : ℕ} (f : α → β), (List.map f l).getD n (f d) = f (l.getD n d)
Result.success

Testing || Antitone.ge_of_tendsto : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : Preorder α] [inst_2 : OrderClosedTopology α]
  [inst_3 : SemilatticeInf β] {f : β → α} {a : α},
  Antitone f → Filter.Tendsto f Filter.atBot (nhds a) → ∀ (b : β), f b ≤ a
Result.success

Testing || Function.Semiconj.surjOn_range : ∀ {α : Type u_1} {β : Type u_2} {fa : α → α} {fb : β → β} {f : α → β},
  Function.Semiconj f fa fb → Function.Surjective fa → Set.SurjOn fb (Set.range f) (Set.range f)
Result.success

Testing || ConvexOn.slope_le_of_hasDerivWithinAt_Iio : ∀ {S : Set ℝ} {f : ℝ → ℝ} {x y f' : ℝ},
  ConvexOn ℝ S f → x ∈ S → y ∈ S → x < y → HasDerivWithinAt f f' (Set.Iio y) y → slope f x y ≤ f'
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instDistribLatticeOfLinearOrder`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Cardinal.beth_pos : ∀ (o : Ordinal.{u_1}), 0 < Cardinal.beth o
Result.exception ::
Duper saturated

Testing || le_hasProd_of_le_prod : ∀ {ι : Type u_1} {α : Type u_3} [inst : Preorder α] [inst_1 : CommMonoid α] [inst_2 : TopologicalSpace α] {a c : α}
  {f : ι → α} [inst_3 : ClosedIciTopology α], HasProd f a → (∀ (s : Finset ι), c ≤ ∏ i ∈ s, f i) → c ≤ a
Result.success

Testing || exists_compact_superset : ∀ {X : Type u_1} [inst : TopologicalSpace X] [inst_1 : WeaklyLocallyCompactSpace X] {K : Set X},
  IsCompact K → ∃ K', IsCompact K' ∧ K ⊆ interior K'
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x ∈ t of λ binder contains bound variables

Testing || Option.mem_dite_none_left : ∀ {α : Type u_1} {p : Prop} {x : α} [inst : Decidable p] {l : ¬p → Option α},
  (x ∈ if h : p then none else l h) ↔ ∃ (h : ¬p), x ∈ l h
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MeasureTheory.HasFiniteIntegral.smul : ∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : NormedAddCommGroup β]
  {𝕜 : Type u_5} [inst_1 : NormedAddCommGroup 𝕜] [inst_2 : SMulZeroClass 𝕜 β] [inst_3 : BoundedSMul 𝕜 β] (c : 𝕜)
  {f : α → β}, MeasureTheory.HasFiniteIntegral f μ → MeasureTheory.HasFiniteIntegral (c • f) μ
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Ordinal.nadd_lt_nadd_right : ∀ {b c : Ordinal.{u}}, b < c → ∀ (a : Ordinal.{u}), b.nadd a < c.nadd a
Result.exception ::
Duper saturated

Testing || ArithmeticFunction.vonMangoldt.LFunctionResidueClassAux_real : ∀ {q : ℕ} {a : ZMod q} [inst : NeZero q],
  IsUnit a →
    ∀ {x : ℝ},
      1 < x →
        ArithmeticFunction.vonMangoldt.LFunctionResidueClassAux a ↑x =
          ↑(ArithmeticFunction.vonMangoldt.LFunctionResidueClassAux a ↑x).re
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || edist_zero_left : ∀ {E : Type u_5} [inst : SeminormedAddGroup E] (a : E), edist 0 a = ↑‖a‖₊
Result.success

Testing || SimpleGraph.EdgeDisjointTriangles.farFromTriangleFree : ∀ {α : Type u_1} {𝕜 : Type u_3} [inst : LinearOrderedField 𝕜] {G : SimpleGraph α} {ε : 𝕜} [inst_1 : Fintype α]
  [inst_2 : DecidableRel G.Adj] [inst_3 : DecidableEq α],
  G.EdgeDisjointTriangles → ε * ↑(Fintype.card α ^ 2) ≤ ↑(G.cliqueFinset 3).card → G.FarFromTriangleFree ε
Result.success

Testing || AddSubgroup.index_map_of_injective : ∀ {G : Type u_1} {G' : Type u_2} [inst : AddGroup G] [inst_1 : AddGroup G'] (H : AddSubgroup G) {f : G →+ G'},
  Function.Injective ⇑f → (AddSubgroup.map f H).index = H.index * f.range.index
Result.success

Testing || MeasureTheory.integrableOn_Ici_iff_integrableAtFilter_atTop : ∀ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]
  {f : X → E} {μ : MeasureTheory.Measure X} {a : X} [inst_3 : LinearOrder X] [inst_4 : CompactIccSpace X],
  MeasureTheory.IntegrableOn f (Set.Ici a) μ ↔
    MeasureTheory.IntegrableAtFilter f Filter.atTop μ ∧ MeasureTheory.LocallyIntegrableOn f (Set.Ici a) μ
Result.exception ::
Duper saturated

Testing || Submodule.copy_eq : ∀ {R : Type u} {M : Type v} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]
  (S : Submodule R M) (s : Set M) (hs : s = ↑S), S.copy s hs = S
Result.exception ::
Duper saturated

Testing || LinearMap.BilinMap.toQuadraticMap_add : ∀ {R : Type u_3} {M : Type u_4} {N : Type u_5} [inst : CommSemiring R] [inst_1 : AddCommMonoid M]
  [inst_2 : _root_.Module R M] [inst_3 : AddCommMonoid N] [inst_4 : _root_.Module R N]
  (B₁ B₂ : LinearMap.BilinMap R M N), (B₁ + B₂).toQuadraticMap = B₁.toQuadraticMap + B₂.toQuadraticMap
Result.success

Testing || AddSubgroup.leftCosetEquivAddSubgroup.proof_4 : ∀ {α : Type u_1} [inst : AddGroup α] {s : AddSubgroup α} (g : α) (x : ↥s),
  (fun x => ⟨-g + ↑x, ⋯⟩) ((fun x => ⟨g + ↑x, ⋯⟩) x) = x
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀ (h : ↑x✝ ∈ ↑s ∧ g +ᵥ ↑x✝ = g + ↑x✝),
  ⋯ = ⋯, type of dependent ∀ bound variable is of sort `Prop`

Testing || Matrix.mulVec_add : ∀ {m : Type u_2} {n : Type u_3} {α : Type v} [inst : NonUnitalNonAssocSemiring α] [inst_1 : Fintype n]
  (A : Matrix m n α) (x y : n → α), A.mulVec (x + y) = A.mulVec x + A.mulVec y
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Matrix.dotProduct x_1
  (cifvar_7 x_2 x_3)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || ContDiff.contDiffWithinAt : ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {s : Set E}
  {f : E → F} {x : E} {n : WithTop ℕ∞}, ContDiff 𝕜 n f → ContDiffWithinAt 𝕜 n f s x
Result.success

Testing || Algebra.algebraMap_ofSubsemiring_apply : ∀ {R : Type u} [inst : CommSemiring R] (S : Subsemiring R) (x : ↥S), (algebraMap (↥S) R) x = ↑x
Result.success

Testing || ProbabilityTheory.IdentDistrib.integral_eq : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : MeasurableSpace α] [inst_1 : MeasurableSpace β]
  [inst_2 : MeasurableSpace γ] {μ : MeasureTheory.Measure α} {ν : MeasureTheory.Measure β} {f : α → γ} {g : β → γ}
  [inst_3 : NormedAddCommGroup γ] [inst_4 : NormedSpace ℝ γ] [inst_5 : BorelSpace γ],
  ProbabilityTheory.IdentDistrib f g μ ν → ∫ (x : α), f x ∂μ = ∫ (x : β), g x ∂ν
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `IsClosed x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || convex_ball : ∀ {E : Type u_1} [inst : SeminormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] (a : E) (r : ℝ),
  Convex ℝ (Metric.ball a r)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #0, (∀ x1 : (#1 → #2), ((!7 x0 x1) → (∀ x2 : #2, (!0 (!4 (λx3 : #1, ((!5 x0 x3) ∧ (!8 (x1 x3) x2))))))))) is not type correct

Testing || Auto.Embedding.Lam.LamValid.imp_self : ∀ {lctx : ℕ → Embedding.Lam.LamSort} {t : Embedding.Lam.LamTerm} {lval : Embedding.Lam.LamValuation},
  Embedding.Lam.LamWF lval.toLamTyVal
      { lctx := lctx, rterm := t, rty := Embedding.Lam.LamSort.base Embedding.Lam.LamBaseSort.prop } →
    Embedding.Lam.LamValid lval lctx (t.mkImp t)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Set.right_eq_inter : ∀ {α : Type u} {s t : Set α}, t = s ∩ t ↔ t ⊆ s
Result.success

Testing || Pointed.Iso.mk_hom_toFun : ∀ {α β : Pointed} (e : α.X ≃ β.X) (he : e α.point = β.point) (a : α.X), (Pointed.Iso.mk e he).hom.toFun a = e a
Result.success

Testing || CategoryTheory.Limits.biproduct.lift_eq : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C] {J : Type}
  [inst_2 : Fintype J] {f : J → C} [inst_3 : CategoryTheory.Limits.HasBiproduct f] {T : C} {g : (j : J) → T ⟶ f j},
  CategoryTheory.Limits.biproduct.lift g =
    ∑ j : J, CategoryTheory.CategoryStruct.comp (g j) (CategoryTheory.Limits.biproduct.ι f j)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `g j`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Set.toFinset_congr : ∀ {α : Type u_1} {s t : Set α} [inst : Fintype ↑s] [inst_1 : Fintype ↑t], s = t → s.toFinset = t.toFinset
Result.exception ::
Duper saturated

Testing || Bimon_.comp_hom' : ∀ (C : Type u₁) [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C]
  [inst_2 : CategoryTheory.BraidedCategory C] {M N K : Bimon_ C} (f : M ⟶ N) (g : N ⟶ K),
  (CategoryTheory.CategoryStruct.comp f g).hom = CategoryTheory.CategoryStruct.comp f.hom g.hom
Result.success

Testing || Subgroup.exists_pow_mem_of_relindex_ne_zero : ∀ {G : Type u_1} [inst : Group G] {H K : Subgroup G},
  H.relindex K ≠ 0 → ∀ {a : G}, a ∈ K → ∃ n, 0 < n ∧ n ≤ H.relindex K ∧ a ^ n ∈ H ⊓ K
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Submonoid.exponent_top : ∀ (G : Type u) [inst : Monoid G], Monoid.exponent ↥⊤ = Monoid.exponent G
Result.exception ::
Duper saturated

Testing || WeierstrassCurve.ψ_neg : ∀ {R : Type r} [inst : CommRing R] (W : WeierstrassCurve R) (n : ℤ), W.ψ (-n) = -W.ψ n
Result.success

Testing || Std.HashMap.getKey?_eq_some_getKey : ∀ {α : Type u} {β : Type v} {x : BEq α} {x_1 : Hashable α} {m : Std.HashMap α β} [inst : EquivBEq α]
  [inst : LawfulHashable α] {a : α} {h' : a ∈ m}, m.getKey? a = some (m.getKey a h')
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀ (h : a✝² ∈ m✝.inner),
  m✝.getKey a✝² h = m✝.inner.getKey a✝² h, type of dependent ∀ bound variable is of sort `Prop`

Testing || Part.left_dom_of_inter_dom : ∀ {α : Type u_1} [inst : Inter α] {a b : Part α}, (a ∩ b).Dom → a.Dom
Result.exception ::
Duper saturated

Testing || AddUnits.val_neg_ofNSMulEqZero : ∀ {M : Type u_1} [inst : AddMonoid M] (a : M) (n : ℕ) (ha : n • a = 0) (hn : n ≠ 0),
  ↑(-AddUnits.ofNSMulEqZero a n ha hn) = (n - 1) • a
Result.success

Testing || CategoryTheory.GrothendieckTopology.sheafifyCompIso_inv_eq_sheafifyLift : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w₁}
  [inst_1 : CategoryTheory.Category.{max v u, w₁} D] {E : Type w₂} [inst_2 : CategoryTheory.Category.{max v u, w₂} E]
  (F : CategoryTheory.Functor D E)
  [inst_3 :
    ∀ (α β : Type (max v u)) (fst snd : β → α),
      CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) D]
  [inst_4 :
    ∀ (α β : Type (max v u)) (fst snd : β → α),
      CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WalkingMulticospan fst snd) E]
  [inst_5 : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (J.Cover X)ᵒᵖ D]
  [inst_6 : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (J.Cover X)ᵒᵖ E]
  [inst_7 : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (J.Cover X)ᵒᵖ F]
  [inst_8 :
    ∀ (X : C) (W : J.Cover X) (P : CategoryTheory.Functor Cᵒᵖ D),
      CategoryTheory.Limits.PreservesLimit (W.index P).multicospan F]
  (P : CategoryTheory.Functor Cᵒᵖ D) [inst_9 : CategoryTheory.ConcreteCategory D]
  [inst_10 : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget D)]
  [inst_11 : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape (J.Cover X)ᵒᵖ (CategoryTheory.forget D)]
  [inst_12 : (CategoryTheory.forget D).ReflectsIsomorphisms],
  (J.sheafifyCompIso F P).inv = J.sheafifyLift (CategoryTheory.whiskerRight (J.toSheafify P) F) ⋯
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_2.instPreorderCover x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork_ι : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  (S : CategoryTheory.ShortComplex C) (hf : S.f = 0) (c : CategoryTheory.Limits.KernelFork S.g)
  (hc : CategoryTheory.Limits.IsLimit c),
  (CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork S hf c hc).ι = CategoryTheory.Limits.Fork.ι c
Result.success

Testing || finGaloisGroupMap.map_comp : ∀ {k : Type u_1} {K : Type u_2} [inst : Field k] [inst_1 : Field K] [inst_2 : Algebra k K]
  {L₁ L₂ L₃ : (FiniteGaloisIntermediateField k K)ᵒᵖ} (f : L₁ ⟶ L₂) (g : L₂ ⟶ L₃),
  finGaloisGroupMap (CategoryTheory.CategoryStruct.comp f g) =
    CategoryTheory.CategoryStruct.comp (finGaloisGroupMap f) (finGaloisGroupMap g)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.left_mem_of_mk_mem_sym2 : ∀ {α : Type u_1} {xs : List α} {a b : α}, s(a, b) ∈ xs.sym2 → a ∈ xs
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Filter.tendsto_of_subseq_tendsto : ∀ {α : Type u_3} {ι : Type u_6} {x : ι → α} {f : Filter α} {l : Filter ι} [inst : l.IsCountablyGenerated],
  (∀ (ns : ℕ → ι), Filter.Tendsto ns Filter.atTop l → ∃ ms, Filter.Tendsto (fun n => x (ns (ms n))) Filter.atTop f) →
    Filter.Tendsto x l f
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : (Nat → #3), (∀ x1 : #2, (∀ x2 : #4, (∀ x3 : #5, ((!4 x0 x1 x2) → ((!8 x2 x3) → (!19 (λx4 : Nat, (!10 x3 (x0 x4))) x1))))))) is not type correct

Testing || Polynomial.eq_X_sub_C_of_splits_of_single_root : ∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) {x : K} {h : Polynomial K},
  Polynomial.Splits i h →
    (Polynomial.map i h).roots = {i x} → h = Polynomial.C h.leadingCoeff * (Polynomial.X - Polynomial.C x)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.map_id' : ∀ {α : Type u_1} (l : List α), List.map (fun a => a) l = l
Result.success

Testing || AntitoneOn.map_inf : ∀ {α : Type u} {β : Type v} {f : α → β} {s : Set α} {x y : α} [inst : LinearOrder α] [inst_1 : SemilatticeSup β],
  AntitoneOn f s → x ∈ s → y ∈ s → f (x ⊓ y) = f x ⊔ f y
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In α →
  Prop, type of ∀ bound variable is not of sort `Prop`, and depends on bound variables

Testing || limsInf_nhds : ∀ {α : Type u_2} [inst : ConditionallyCompleteLinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]
  (a : α), (nhds a).limsInf = a
Result.exception ::
Duper saturated

Testing || List.map_subset : ∀ {α : Type u_1} {β : Type u_2} {l₁ l₂ : List α} (f : α → β), l₁ ⊆ l₂ → List.map f l₁ ⊆ List.map f l₂
Result.exception ::
(deterministic) timeout at `fluidSup`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || HasFDerivAt.mul_const' : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {x : E} {𝔸 : Type u_5} [inst_3 : NormedRing 𝔸] [inst_4 : NormedAlgebra 𝕜 𝔸] {a : E → 𝔸}
  {a' : E →L[𝕜] 𝔸}, HasFDerivAt a a' x → ∀ (b : 𝔸), HasFDerivAt (fun y => a y * b) (a'.smulRight b) x
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Finset.card_dvd_card_add_right : ∀ {α : Type u_2} [inst : AddGroup α] [inst_1 : DecidableEq α] {s t : Finset α},
  ((fun x => x +ᵥ t) '' ↑s).PairwiseDisjoint id → t.card ∣ (s + t).card
Result.success

Testing || Convex.norm_image_sub_le_of_norm_fderiv_le' : ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {𝕜 : Type u_3} {G : Type u_4}
  [inst_2 : NontriviallyNormedField 𝕜] [inst_3 : IsRCLikeNormedField 𝕜] [inst_4 : NormedSpace 𝕜 E]
  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace 𝕜 G] {f : E → G} {C : ℝ} {s : Set E} {x y : E} {φ : E →L[𝕜] G},
  (∀ x ∈ s, DifferentiableAt 𝕜 f x) →
    (∀ x ∈ s, ‖fderiv 𝕜 f x - φ‖ ≤ C) → Convex ℝ s → x ∈ s → y ∈ s → ‖f y - f x - φ (y - x)‖ ≤ C * ‖y - x‖
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!22 !23 !24) = !0) is not type correct

Testing || Complex.cpow_one : ∀ (x : ℂ), x ^ 1 = x
Result.success

Testing || NonUnitalSubalgebra.copy_eq : ∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : NonUnitalNonAssocSemiring A] [inst_2 : _root_.Module R A]
  (S : NonUnitalSubalgebra R A) (s : Set A) (hs : s = ↑S), S.copy s hs = S
Result.exception ::
Duper saturated

Testing || List.nodup_permutations : ∀ {α : Type u_1} (s : List α), s.Nodup → s.permutations.Nodup
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Subgroup.pow_mem_of_index_ne_zero_of_dvd : ∀ {G : Type u_1} [inst : Group G] {H : Subgroup G},
  H.index ≠ 0 → ∀ (a : G) {n : ℕ}, (∀ (m : ℕ), 0 < m → m ≤ H.index → m ∣ n) → a ^ n ∈ H
Result.success

Testing || natAbs_nsmul_eq_zero : ∀ {G : Type u_3} [inst : AddGroup G] {a : G} {n : ℤ}, n.natAbs • a = 0 ↔ n • a = 0
Result.exception ::
Duper saturated

Testing || Stream'.WSeq.map_comp : ∀ {α : Type u} {β : Type v} {γ : Type w} (f : α → β) (g : β → γ) (s : Stream'.WSeq α),
  Stream'.WSeq.map (g ∘ f) s = Stream'.WSeq.map g (Stream'.WSeq.map f s)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ExistsContDiffBumpBase.y_neg : ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E]
  [inst_3 : MeasurableSpace E] [inst_4 : BorelSpace E] (D : ℝ) (x : E),
  ExistsContDiffBumpBase.y D (-x) = ExistsContDiffBumpBase.y D x
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!15 !35 !36) = !0) is not type correct

Testing || IsAddCyclic.unique_zsmul_zmod : ∀ {α : Type u_1} {a : α} [inst : AddGroup α] [inst_1 : Fintype α],
  (∀ (x : α), x ∈ AddSubgroup.zmultiples a) → ∀ (x : α), ∃! n, x = n.val • a
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `ZMod.commRing x_2`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Matroid.basis_empty_iff : ∀ {α : Type u_1} {I : Set α} (M : Matroid α), M.Basis I ∅ ↔ I = ∅
Result.success

Testing || contMDiffAt_iff : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners 𝕜 E H} {M : Type u_4}
  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] {E' : Type u_5} [inst_6 : NormedAddCommGroup E']
  [inst_7 : NormedSpace 𝕜 E'] {H' : Type u_6} [inst_8 : TopologicalSpace H'] {I' : ModelWithCorners 𝕜 E' H'}
  {M' : Type u_7} [inst_9 : TopologicalSpace M'] [inst_10 : ChartedSpace H' M'] {n : ℕ∞} {f : M → M'} {x : M},
  ContMDiffAt I I' n f x ↔
    ContinuousAt f x ∧
      ContDiffWithinAt 𝕜 (↑n) (↑(extChartAt I' (f x)) ∘ f ∘ ↑(extChartAt I x).symm) (Set.range ↑I) (↑(extChartAt I x) x)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #0, (∀ x1 : #1, (∀ x2 : #2, (∀ x3 : (#3 → #4), (∀ x4 : #3, ((!19 (!29 x1 x0 x2) x3 x4) = (!0 x1 x0 x2 x3 x4))))))) is not type correct

Testing || MeasureTheory.IsFundamentalDomain.mk' : ∀ {G : Type u_1} {α : Type u_3} [inst : Group G] [inst_1 : MulAction G α] [inst_2 : MeasurableSpace α] {s : Set α}
  {μ : MeasureTheory.Measure α},
  MeasureTheory.NullMeasurableSet s μ → (∀ (x : α), ∃! g, g • x ∈ s) → MeasureTheory.IsFundamentalDomain G s μ
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((∃ x0 : #0, ((!14 x0) ∧ (!15 (!16 !2) !1 x0))) = (!0 !1 !2)) is not type correct

Testing || not_summable_of_ratio_norm_eventually_ge : ∀ {α : Type u_2} [inst : SeminormedAddCommGroup α] {f : ℕ → α} {r : ℝ},
  1 < r → (∃ᶠ (n : ℕ) in Filter.atTop, ‖f n‖ ≠ 0) → (∀ᶠ (n : ℕ) in Filter.atTop, r * ‖f n‖ ≤ ‖f (n + 1)‖) → ¬Summable f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Filter.atTop`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || InnerProductGeometry.sin_angle_add_mul_norm_of_inner_eq_zero : ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] {x y : V},
  inner x y = 0 → Real.sin (InnerProductGeometry.angle x (x + y)) * ‖x + y‖ = ‖y‖
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Preorder.toLT`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || ContinuousAt.finset_inf_apply : ∀ {L : Type u_1} {X : Type u_2} [inst : TopologicalSpace L] [inst_1 : TopologicalSpace X] {ι : Type u_3}
  [inst_2 : SemilatticeInf L] [inst_3 : OrderTop L] [inst_4 : ContinuousInf L] {s : Finset ι} {f : ι → X → L} {x : X},
  (∀ i ∈ s, ContinuousAt (f i) x) → ContinuousAt (fun a => s.inf fun x => f x a) x
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Elapsed time: 261846 ms

Summary:

0 E CategoryTheory.IsFilteredOrEmpty.of_isRightAdjoint
1 S IsCoprime.of_mul_add_right_left
2 S CategoryTheory.evaluation_obj_obj
3 S add_le_of_le_tsub_right_of_le
4 E Matrix.Nondegenerate.exists_not_ortho_of_ne_zero
5 S NonUnitalSubring.closure_eq_of_le
6 S UInt32.intCast_def
7 E MeasureTheory.SignedMeasure.rnDeriv_sub
8 E List.foldlIdx_eq_foldlIdxSpec
9 S Subring.coe_zero
10 S Std.DHashMap.Internal.Raw₀.getKey?_eq_getKey?ₘ
11 E Multiset.map_univ_coeEmbedding
12 E Ring.multichoose_zero_right'
13 E Filter.EventuallyEq.gradient
14 E Matrix.PosSemidef.eq_of_sq_eq_sq
15 S minpoly.coeff_zero_ne_zero
16 E List.cons_subperm_of_not_mem_of_mem
17 E LinearMap.BilinForm.IsSymm.eq
18 E CategoryTheory.Limits.IsImage.isoExt_inv_m
19 E Equiv.curry_apply
20 E dif_neg
21 E Ordinal.one_CNF
22 S ContinuousAffineMap.sub_contLinear
23 S AddEquiv.instEquivLike.proof_2
24 E List.mapIdx_set
25 E SetTheory.PGame.insertRight_le
26 E nhdsAdjoint_nhds
27 E instUniqueAddUnitsOfSubsingleton.proof_1
28 E Cardinal.mk_coe_finset
29 E CategoryTheory.Sieve.pullback_ofObjects_eq_top
30 S Set.iUnion_option
31 E Ergodic.ae_empty_or_univ_of_preimage_ae_le'
32 E MeasureTheory.Measure.rnDeriv_smul_right_of_ne_top
33 E PartialHomeomorph.coe_trans_symm
34 S Set.bounded_lt_Iic
35 E MeasureTheory.eLpNorm_const_smul_le
36 E CategoryTheory.Iso.isIso_inv
37 E IntermediateField.adjoin_univ
38 S NonemptyInterval.snd_add
39 E CategoryTheory.Bicategory.RightExtension.w_assoc
40 S Disjoint.subset_compl_left
41 E IsAntichain.flip
42 E LowerAdjoint.closure_iUnion_closure
43 S Subsemiring.mem_closure_iff
44 S Real.deriv_cos
45 E Pell.IsFundamental.mul_inv_x_lt_x
46 S Complex.cos_conj
47 E MeasureTheory.Supermartingale.set_integral_le
48 E AddAction.pretransitive_iff_unique_quotient_of_nonempty
49 E InnerProductGeometry.norm_sub_eq_add_norm_of_angle_eq_pi
50 S Finset.union_sdiff_cancel_left
51 E Module.Presentation.finite
52 E LowerSet.mem_iInf₂_iff
53 S Finsupp.smul_single'
54 S Commute.inv
55 S Finset.Nonempty.piFinset_const
56 E List.cons_sublist_cons'
57 E Set.image_subset_sups_right
58 S FractionalIdeal.mem_extended_iff
59 S Bimod.regular_actRight
60 E TrivSqZeroExt.map_comp_map
61 E StrictConvexOn.slope_lt_of_hasDerivAt
62 E AddUnits.min_val
63 S FreeCommRing.isSupported_add
64 E IsPGroup.exists_fixed_point_of_prime_dvd_card_of_fixed_point
65 S ContDiffBump.neg
66 E IsAddSubgroup.normalizer_isAddSubgroup
67 E SubmonoidClass.finsupp_prod_mem
68 E BitVec.sub_add_bmod_cancel
69 E Set.einfsep_iUnion_mem_option
70 E bddAbove_neg
71 E Sat.Fmla.subsumes_left
72 S OrderHom.snd_coe
73 S Quaternion.imK_snd_dualNumberEquiv
74 E AddCommMagma.IsRightCancelAdd.toIsCancelAdd
75 E Finset.sum_smul_vsub_const_eq_affineCombination_vsub
76 E CategoryTheory.Limits.hasTerminalChangeUniverse
77 E Algebra.IsStandardSmooth.localization_away
78 E IsCoprime.dvd_of_dvd_mul_right
79 S UInt32.toUInt16_toNat
80 S Std.Tactic.BVDecide.Normalize.Bool.or_elim
81 S MeasureTheory.SimpleFunc.pair_apply
82 E _private.Mathlib.NumberTheory.FermatPsp.0.Nat.b_id_helper
83 S ofLex_inj
84 S compactlySupported_eq_top
85 E LinearIsometry.map_orthogonalProjection'
86 E ProbabilityTheory.Kernel.iIndepSets.ae_isProbabilityMeasure
87 S Real.exp_ne_zero
88 E Profinite.NobelingProof.GoodProducts.maxToGood_injective
89 E StrictConvexOn.map_sum_eq_iff'
90 E RightCancelSemigroup.ext
91 S Finset.diffs_union_right
92 E CategoryTheory.Functor.relativelyRepresentable.symmetryIso_hom
93 S Fin.rev_sub
94 E Std.Tactic.BVDecide.BVBinPred.eval_ult
95 E List.sum_pos
96 E Ordinal.comp_familyOfBFamily'
97 E star_natCast_smul
98 E SetTheory.PGame.fuzzy_of_fuzzy_of_equiv
99 E LocallyConvexSpace.ofBases
100 E EulerProduct.eulerProduct
101 E Mathlib.Vector.get_ofFn
102 S CategoryTheory.ShortComplex.sub_τ₁
103 E MeasureTheory.Martingale.stoppedValue_ae_eq_restrict_eq
104 S Complex.sameRay_of_arg_eq
105 E CategoryTheory.Limits.initial.to_comp
106 S BoundedLatticeHom.id_comp
107 S Differentiable.analyticAt
108 E CompleteOrthogonalIdempotents.option
109 S QuaternionAlgebra.neg_mk
110 E Filter.eventually_gt_atTop
111 S NNReal.iSup_mul_le
112 E Padic.AddValuation.map_add
113 S PNat.mod_add_div'
114 E CategoryTheory.SingleFunctors.shiftIso_add'
115 S imaginaryPart_eq_neg_I_smul_skewAdjointPart
116 S Submodule.toAddSubmonoid_eq
117 E DFinsupp.equivFunOnFintype_symm_coe
118 E _private.Mathlib.NumberTheory.Padics.Hensel.0.newton_seq_dist
119 S Multiset.disjoint_add_right
120 E List.Perm.symm
121 S CompleteLat.Iso.mk_hom_toFun
122 E PartENat.card_eq_zero_iff_empty
123 S NonemptyInterval.pure_fst
124 E AlternatingMap.coe_multilinearMap_injective
125 S FreeCommRing.isSupported_sub
126 S MeasureTheory.ae_of_all
127 E CoxeterSystem.not_isRightDescent_iff
128 E RingHom.liftOfRightInverse_comp_apply
129 S LinearIndependent.total_ne_of_not_mem_support
130 E CategoryTheory.Limits.Cocones.precomposeEquivalence_unitIso
131 E AntivaryOn.of_neg_right
132 E DedekindDomain.ProdAdicCompletions.IsFiniteAdele.mul
133 E Int.bitwise_or
134 S Filter.eventuallyLE_congr
135 S ProbabilityTheory.Kernel.compProd_apply
136 S List.cons_head!_tail
137 S hasSum_geometric_of_abs_lt_one
138 E PolynomialModule.eval_map'
139 E WittVector.mul_polyOfInterest_aux1
140 E Filter.Tendsto.inv_tendsto_zero
141 E Submodule.convex
142 E Submodule.quotientPi_apply
143 S FirstOrder.Language.Formula.equivSentence_inf
144 S TrivSqZeroExt.isUnit_or_isNilpotent
145 E ZMod.val_add_of_le
146 S MvPowerSeries.order_le
147 S AffineMap.snd_linear
148 S LinearEquiv.coe_coe
149 S LinearEquiv.sumArrowLequivProdArrow_symm_apply_inr
150 E Finset.Nontrivial.pow
151 E WeierstrassCurve.Affine.Point.some_add_some_of_Yne
152 S isCoprime_mul_unit_right_left
153 S ciInf_le_of_le'
154 E RingHom.map_mulVec
155 E Ordinal.dvd_of_mod_eq_zero
156 E Profinite.projective_of_extrDisc
157 E FirstOrder.Language.Substructure.mem_inf
158 E ModuleCat.ExtendScalars.map'_id
159 E Real.sin_zero
160 S CategoryTheory.Sigma.inclCompMap_inv_app
161 S div_mul_cancel_left
162 E AlgebraicGeometry.IsOpenImmersion.app_eq_invApp_app_of_comp_eq_aux
163 E MeasureTheory.OuterMeasure.mkMetric_top
164 S Std.DHashMap.Internal.Raw₀.getKey?_eq_none
165 E WithTop.pow_right_strictMono
166 S ofBoolRing_symm_eq
167 E MvPolynomial.C_dvd_iff_zmod
168 E CategoryTheory.MonoidalCategory.whiskerLeftIso_trans
169 S EReal.coe_ennreal_le_coe_ennreal_iff
170 S NonUnitalSubring.coe_bot
171 E innerDualCone_eq_iInter_innerDualCone_singleton
172 E Set.iUnion_sub_left_image
173 S SetTheory.PGame.lf_of_lf_of_le
174 E MeasureTheory.eLpNorm_trim_ae
175 E List.Perm.subset
176 E Complex.differentiableAt_cos
177 S CategoryTheory.Functor.Iteration.truncFunctor_obj
178 S RelEmbedding.map_rel_iff
179 S SymAlg.sym_ne_zero_iff
180 E AlgebraicGeometry.StructureSheaf.stalkSpecializes_stalk_to_fiber
181 S Complex.abs_im_eq_abs
182 E Ordinal.principal_swap_iff
183 E MeasureTheory.Martingale.stoppedValue_ae_eq_restrict_eq
184 S PartialEquiv.restr_univ
185 E MeasureTheory.AEFinStronglyMeasurable.ae_nonneg_of_forall_setIntegral_nonneg
186 E Std.Tactic.BVDecide.LRAT.Internal.DefaultFormula.limplies_of_assignmentsInvariant
187 S CategoryTheory.Square.Hom.comp_τ₄
188 S Eq.congr_left
189 E LieAlgebra.exists_isRegular_of_finrank_le_card
190 E leftInverse_add_left_sub
191 E MeasurableSpace.generateFrom_measurableSet
192 E MeasureTheory.Measure.measure_isMulInvariant_eq_smul_of_isCompact_closure
193 E Profinite.NobelingProof.GoodProducts.linearIndependentAux
194 S BddAbove.isBoundedUnder_of_range
195 E FractionalIdeal.num_eq_zero_iff
196 E Finset.ruzsa_covering_mul
197 S Matrix.head_cons
198 S Set.image_neg_Ici
199 E Set.natCard_div_le
200 E Finset.mem_disjSum
201 E CategoryTheory.pseudofunctorOfIsLocallyDiscrete_mapComp
202 E Std.DHashMap.getKey_insert_self
203 S map_symmDiff
204 E BoundedContinuousFunction.norm_lt_iff_of_compact
205 S WithTop.sum_eq_top_iff
206 E Real.le_sSup_iff
207 E Associated.prod
208 E Fin.cycleRange_zero
209 E HolorIndex.cast_type
210 S UpperHalfPlane.coe_mk
211 E Nat.one_lt_pow_iff
212 E MeasureTheory.FiniteMeasure.null_iff_toMeasure_null
213 E min_mul_min_le_min_mul_mul'
214 E List.smul_sum
215 E LinearMap.compQuadraticMap_polar
216 E lowerBounds_infClosure
217 S Ordinal.lsub_le
218 S Subsemigroup.comap_top
219 S CofiniteTopology.continuous_of
220 S LE.le.add_eq_left
221 E ContMDiffAt.clm_comp
222 E CategoryTheory.regularTopology.isSheafFor_regular_of_projective
223 E QuotSMulTop.map_comp
224 S MeasureTheory.IntegrableOn.union
225 S Int.lt_mul_of_ediv_lt
226 S MeasureTheory.SimpleFunc.GCongr.mk_le_mk
227 E cfcₙHomSuperset_id'
228 E ContinuousMap.sup_mem_subalgebra_closure
229 S IsFractionRing.associated_num_den_inv
230 E Con.le_comap_conGen
231 S TopologicalSpace.CompactOpens.coe_mk
232 E Metric.cthickening_thickening_subset
233 S mul_right_eq_self₀
234 E AlgHom.ker_rangeRestrict
235 E AlgHom.map_smul_of_tower
236 E wellFoundedGT_antisymmetrization_iff
237 S frontier_Icc
238 E Set.compl_singleton_eq
239 E ContinuousMap.dist_le_iff_of_nonempty
240 E MeasureTheory.IsFundamentalDomain.measure_ne_zero
241 S AffineSubspace.sOppSide_lineMap_right
242 E Projectivization.map_injective
243 E Submodule.le_comap_single_pi
244 S deriv_update
245 E Submonoid.map_iInf
246 S Combinatorics.Subspace.coe_apply
247 E FreeSemigroup.ext
248 S SetTheory.PGame.one_leftMoves
249 E OrderIso.equivalence_unitIso
250 S Module.reflection_apply
251 E CategoryTheory.ComonadHom.ext'
252 E NumberField.InfinitePlace.comap_surjective
253 E Substring.ValidFor.drop
254 E ZMod.pow_div_two_eq_neg_one_or_one
255 E CauchyFilter.denseRange_pureCauchy
256 E mem_tangentCone_of_openSegment_subset
257 S WeierstrassCurve.Ψ₂Sq_eq
258 S Monoid.exponent_pos
259 E Nat.clog_of_two_le
260 S NonemptyInterval.fst_nsmul
261 E AddSubgroup.comap.proof_1
262 E Order.pred_iterate_le
263 E OrderHom.map_lfp_comp
264 S Subgroup.le_topologicalClosure
265 S CategoryTheory.Functor.mapHomotopyCategory_obj
266 E list_sum_mem
267 S Codisjoint.symm
268 S Nat.succ_iterate
269 S Lean.Omega.Int.lt_of_not_le
270 E Matrix.mul_submatrix_one
271 E QuadraticModuleCat.toIsometry_id
272 S InnerProductSpace.Core.inner_sub_left
273 S Nat.mul_lt_mul_of_lt_of_le'
274 S SmoothPartitionOfUnity.toPartitionOfUnity_toFun
275 S Submodule.quotDualCoannihilatorToDual_apply
276 E IsCompact.nhdsSet_inf_eq_biSup
277 E exists_disjoint_smul_of_isCompact
278 E exists_setIndependent_of_sSup_atoms_eq_top
279 E NNReal.mk_one
280 S leOnePart_le_one'
281 S Functor.mapEquiv_symm_apply
282 E OrderEmbedding.preimage_Ioi
283 S CentroidHom.toEnd_pow
284 E List.ofFn_mul'
285 E Set.iUnion_nonempty_self
286 S CategoryTheory.ShortComplex.RightHomologyMapData.smul_φH
287 E EMetric.ball_mem_nhds
288 E SymplecticGroup.symplectic_det
289 E tendsto_ceil_left_pure_ceil
290 E Finset.cons_induction
291 E MvPolynomial.coe_eq_zero_iff
292 E CategoryTheory.Comma.toIdPUnitEquiv_counitIso_hom_app
293 E aeSeq.prop_of_mem_aeSeqSet
294 E List.Nodup.isCycleOn_formPerm
295 E CategoryTheory.Limits.image.ι_zero'
296 S Bornology.IsCobounded.closedBall_compl_subset
297 E Complex.abs_im_lt_abs
298 E Trivialization.Prod.continuous_to_fun
299 S IsGLB.sInf_eq
300 S le_of_forall_pos_sub_le
301 E TopCat.Presheaf.locally_surjective_iff_surjective_on_stalks
302 E WeierstrassCurve.variableChange_Δ
303 S AlgEquiv.toRingEquiv_symm
304 E GenContFract.zeroth_cont_eq_h_one
305 E List.getElem_drop
306 E ContinuousOn.mono_rng
307 E Set.image_mulSingle_uIcc_left
308 E StarAlgebra.elemental.self_mem
309 E Ordinal.sub_le_self
310 E SemiconjBy.pow_right
311 E AddSubgroup.quotientEquivSumOfLE'.proof_4
312 S Order.krullDim_nat
313 E PNat.gcd_comm
314 E TrivSqZeroExt.map_comp_inlAlgHom
315 S Matrix.toLinearMapₛₗ₂'_symm
316 E AlgebraicGeometry.PresheafedSpace.Hom.ext
317 S DiscreteQuotient.leComap_id_iff
318 S String.Pos.mk_le_mk
319 S one_div_mul_add_mul_one_div_eq_one_div_add_one_div
320 S MeasureTheory.Measure.restrict_add_restrict_compl
321 E SupClosed.preimage
322 E ContMDiffAt.neg
323 E Cardinal.lift_umax
324 E TypeVec.fst_diag
325 S Real.zero_rpow_le_one
326 E LieSubalgebra.isNilpotent_ad_of_isNilpotent_ad
327 E CategoryTheory.Grothendieck.grothendieckTypeToCat_unitIso_inv_app_fiber
328 E MvPolynomial.sum_eval_eq_zero
329 E convex_halfSpace_re_le
330 E interior_halfspace
331 E Pi.negPart_apply
332 E AlgebraicGeometry.ProjectiveSpectrum.StructureSheaf.structurePresheafInCommRing_map_apply
333 E CategoryTheory.Adjunction.hasLimitsOfShape_of_equivalence
334 E HasProd.update'
335 E Matrix.trace_transpose
336 S CategoryTheory.Cat.freeRefl_obj_str_comp
337 E TensorProduct.add_tmul
338 E toZ_of_ge
339 S ContinuousAlternatingMap.ofSubsingleton_apply_toContinuousMultilinearMap
340 E TopologicalGroup.of_comm_of_nhds_one
341 E Filter.ZeroAtFilter.boundedAtFilter
342 S Turing.ListBlank.nth_mk
343 E CategoryTheory.epi_iff_surjective
344 E Multiset.le_prod_of_submultiplicative_on_pred
345 E Fin.sum_univ_six
346 E List.isRotated_singleton_iff
347 S CategoryTheory.Equivalence.changeInverse_counitIso_hom_app
348 E CategoryTheory.comp_eqToHom_heq
349 E Multiset.toFinset_nsmul
350 S Quotient.out_eq'
351 S IsLocalizedModule.mk'_add
352 S IntermediateField.equivOfEq_symm
353 S MeasureTheory.eLpNormEssSup_const
354 E Ideal.map_radical_of_surjective
355 E Submodule.smul_torsionBy
356 E dite_ite_distrib_right
357 S CategoryTheory.Limits.cofan_mk_inj
358 E Mathlib.Tactic.Monoidal.evalHorizontalCompAux'_whisker
359 S Subring.mem_bot
360 E MeasurableSet.cylinder
361 S IsSelfAdjoint.zpow
362 E CliffordAlgebra.ofBaseChange_comp_toBaseChange
363 E uniformEquicontinuousOn_unique
364 S Metric.continuous_infNndist_pt
365 S IntermediateField.pow_mem
366 E CochainComplex.HomComplex.Cochain.map_comp
367 S ModelWithCorners.toHomeomorph_apply
368 S isBot_iff_isMin
369 E Cardinal.toPartENat_lift
370 E AlgHom.range_comp_le_range
371 S DifferentiableWithinAt.const_cpow
372 E SetTheory.PGame.memₗ.congr_left
373 E iSup_inf_eq
374 E MulHom.coe_coe
375 E PresheafOfModules.toSheaf_map_sheafificationHomEquiv_symm
376 E compl_bihimp_self
377 S CategoryTheory.ShortComplex.RightHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork_φQ
378 E Basis.card_le_card_of_linearIndependent
379 E Orientation.rotation_trans
380 E IsPrimitiveRoot.sub_one_norm_isPrimePow
381 S Stream'.tail_eq_drop
382 E UniformEquiv.piCongrRight_apply
383 S Matrix.mulVec_empty
384 E MvPolynomial.isHomogeneous_C
385 S NonUnitalStarSubalgebra.mem_map
386 E uniqueDiffWithinAt_Iio
387 E strictMonoOn_Ici_of_pred_lt
388 E groupCohomology.twoCocycles_ext
389 E BitVec.getMsbD_one
390 E NormedSpace.exp_zero
391 E MeromorphicOn.inv_iff
392 S WithLp.prod_norm_equiv_symm
393 E Ordinal.add_omega0_opow
394 E Module.AEval.isTorsion_of_aeval_eq_zero
395 E MeasureTheory.ae_toFiniteAux
396 E Topology.IsEmbedding.restrictPreimage
397 E AddSubmonoid.unop_closure
398 S Monoid.Coprod.fst_apply_inl
399 S SemidirectProduct.rightHom_comp_inr
400 S Equiv.uniformEmbedding
401 E Set.LeftInvOn.eq
402 E Multiset.mem_powersetAux
403 S Topology.IsEmbedding.t2Space
404 S Option.isSome_unattach
405 E AddChar.zmod_char_ne_one_iff
406 E IsAddUnit.add
407 E Polynomial.eval₂_C_X
408 E MeasureTheory.AEEqFun.pair_eq_mk
409 E Multiset.card_mono
410 E ContinuousMap.coe_copy
411 S Module.mapEvalEquiv_symm_apply
412 S ExceptCpsT.run_throw
413 S Polynomial.hasseDeriv_X
414 S Array.get?_eq_get?_toList
415 S Matroid.spanning_iff_exists_base_subset
416 E Sum.bnot_isRight
417 E Function.zero_of_even_and_odd
418 E groupCohomology.mem_oneCocycles_def
419 E Real.mul_lt_sin
420 S Finsupp.neLocus_neg
421 E LinearMap.hasBasis_weakBilin
422 S MeasureTheory.snorm'_lt_top_of_snorm'_lt_top_of_exponent_le
423 S Algebra.TensorProduct.assoc_symm_tmul
424 E MeasureTheory.integral_add
425 S Finset.filter_empty
426 E ContinuousLinearMap.exist_extension_of_finiteDimensional_range
427 E MulDissociated.of_inv
428 S Equiv.Perm.support_cycleOf_eq_nil_iff
429 E Pell.exists_of_not_isSquare
430 E CategoryTheory.biproduct_ι_comp_leftDistributor_hom_assoc
431 E UniformSpace.Completion.continuous_dist
432 E RingEquiv.piEquivPiSubtypeProd_symm_apply
433 E CochainComplex.HomComplex.Cocycle.δ_eq_zero
434 S MulEquiv.comapSubgroup_apply
435 E EquivLike.coe_symm_comp_self
436 E CategoryTheory.Functor.relativelyRepresentable.symmetry_snd_assoc
437 S AddMonoid.Coprod.snd_apply_inr
438 E CategoryTheory.Limits.ι_comp_colimitRightOpIsoUnopLimit_hom_assoc
439 E MeasureTheory.lintegral_singleton
440 E ContinuousMultilinearMap.norm_def
441 S List.nil_product
442 E Std.DHashMap.getKeyD_erase
443 E Set.iSup_iInf_of_monotone
444 E Set.biUnion_le_eq_iUnion
445 E CategoryTheory.Functor.LaxMonoidal.μ_natural_right
446 S MulEquiv.toCommGrpIso_inv
447 S ContinuousMap.one_apply
448 E Submonoid.LocalizationMap.mk'_sec
449 E ZMod.exists
450 S List.getD_map
451 S Antitone.ge_of_tendsto
452 S Function.Semiconj.surjOn_range
453 E ConvexOn.slope_le_of_hasDerivWithinAt_Iio
454 E Cardinal.beth_pos
455 S le_hasProd_of_le_prod
456 E exists_compact_superset
457 E Option.mem_dite_none_left
458 E MeasureTheory.HasFiniteIntegral.smul
459 E Ordinal.nadd_lt_nadd_right
460 E ArithmeticFunction.vonMangoldt.LFunctionResidueClassAux_real
461 S edist_zero_left
462 S SimpleGraph.EdgeDisjointTriangles.farFromTriangleFree
463 S AddSubgroup.index_map_of_injective
464 E MeasureTheory.integrableOn_Ici_iff_integrableAtFilter_atTop
465 E Submodule.copy_eq
466 S LinearMap.BilinMap.toQuadraticMap_add
467 E AddSubgroup.leftCosetEquivAddSubgroup.proof_4
468 E Matrix.mulVec_add
469 S ContDiff.contDiffWithinAt
470 S Algebra.algebraMap_ofSubsemiring_apply
471 E ProbabilityTheory.IdentDistrib.integral_eq
472 E convex_ball
473 E Auto.Embedding.Lam.LamValid.imp_self
474 S Set.right_eq_inter
475 S Pointed.Iso.mk_hom_toFun
476 E CategoryTheory.Limits.biproduct.lift_eq
477 E Set.toFinset_congr
478 S Bimon_.comp_hom'
479 E Subgroup.exists_pow_mem_of_relindex_ne_zero
480 E Submonoid.exponent_top
481 S WeierstrassCurve.ψ_neg
482 E Std.HashMap.getKey?_eq_some_getKey
483 E Part.left_dom_of_inter_dom
484 S AddUnits.val_neg_ofNSMulEqZero
485 E CategoryTheory.GrothendieckTopology.sheafifyCompIso_inv_eq_sheafifyLift
486 S CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork_ι
487 E finGaloisGroupMap.map_comp
488 E List.left_mem_of_mk_mem_sym2
489 E Filter.tendsto_of_subseq_tendsto
490 E Polynomial.eq_X_sub_C_of_splits_of_single_root
491 S List.map_id'
492 E AntitoneOn.map_inf
493 E limsInf_nhds
494 E List.map_subset
495 E HasFDerivAt.mul_const'
496 S Finset.card_dvd_card_add_right
497 E Convex.norm_image_sub_le_of_norm_fderiv_le'
498 S Complex.cpow_one
499 E NonUnitalSubalgebra.copy_eq
500 E List.nodup_permutations
501 S Subgroup.pow_mem_of_index_ne_zero_of_dvd
502 E natAbs_nsmul_eq_zero
503 E Stream'.WSeq.map_comp
504 E ExistsContDiffBumpBase.y_neg
505 E IsAddCyclic.unique_zsmul_zmod
506 S Matroid.basis_empty_iff
507 E contMDiffAt_iff
508 E MeasureTheory.IsFundamentalDomain.mk'
509 E not_summable_of_ratio_norm_eventually_ge
510 E InnerProductGeometry.sin_angle_add_mul_norm_of_inner_eq_zero
511 E ContinuousAt.finset_inf_apply
