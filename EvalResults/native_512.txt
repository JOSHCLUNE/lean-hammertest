Config = {maxHeartbeats := 65536, timeout := 10, solverConfig := native, logFile := evalAutoOut.txt}

Testing || FiniteDimensional.trans : ∀ (F : Type u_1) (K : Type u_2) (A : Type u_3) [inst : DivisionRing F] [inst_1 : DivisionRing K]
  [inst_2 : AddCommGroup A] [inst_3 : _root_.Module F K] [inst_4 : _root_.Module K A] [inst_5 : _root_.Module F A]
  [inst_6 : IsScalarTower F K A] [inst_7 : FiniteDimensional F K] [inst_8 : FiniteDimensional K A],
  FiniteDimensional F A
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Module.Finite cifvar_6 cifvar_7`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Complex.instIsComplete : CauSeq.IsComplete ℂ ⇑Complex.abs
Result.exception ::
Duper saturated

Testing || ContDiffOn.norm_sq : ∀ (𝕜 : Type u_1) {E : Type u_2} [inst : RCLike 𝕜] [inst_1 : NormedAddCommGroup E] [inst : InnerProductSpace 𝕜 E]
  [inst : NormedSpace ℝ E] {G : Type u_4} [inst_2 : NormedAddCommGroup G] [inst_3 : NormedSpace ℝ G] {f : G → E}
  {s : Set G} {n : WithTop ℕ∞}, ContDiffOn ℝ n f s → ContDiffOn ℝ n (fun y => ‖f y‖ ^ 2) s
Result.exception ::
Duper saturated

Testing || PartialHomeomorph.isOpen_image_iff_of_subset_source : ∀ {X : Type u_1} {Y : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (e : PartialHomeomorph X Y)
  {s : Set X}, s ⊆ e.source → (IsOpen (↑e '' s) ↔ IsOpen s)
Result.exception ::
Duper saturated

Testing || CategoryTheory.Functor.IsEventuallyConstantTo.coneπApp_eq_id : ∀ {J : Type u_1} {C : Type u_2} [inst : CategoryTheory.Category.{u_4, u_1} J]
  [inst_1 : CategoryTheory.Category.{u_3, u_2} C] {F : CategoryTheory.Functor J C} {i₀ : J}
  (h : F.IsEventuallyConstantTo i₀) [inst_2 : CategoryTheory.IsCofiltered J],
  h.coneπApp i₀ = CategoryTheory.CategoryStruct.id (F.obj i₀)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀ (h : F.IsEventuallyConstantTo i₀),
  CategoryTheory.CategoryStruct.comp (h.isoMap (CategoryTheory.IsCofiltered.minToLeft i₀ i₀) ⋯).inv
      (F.map (CategoryTheory.IsCofiltered.minToRight i₀ i₀)) =
    h.coneπApp i₀, type of dependent ∀ bound variable is of sort `Prop`

Testing || CompHausLike.hasPullbacksOfInclusions : ∀ {P : TopCat → Prop} [inst : CompHausLike.HasExplicitFiniteCoproducts P],
  (∀ ⦃X Y B : CompHausLike P⦄ (f : X ⟶ B) (g : Y ⟶ B),
      Topology.IsOpenEmbedding ⇑f → CompHausLike.HasExplicitPullback f g) →
    CompHausLike.HasExplicitPullbacksOfInclusions P
Result.exception ::
Duper saturated

Testing || List.mem_flatten : ∀ {α : Type u_1} {a : α} {L : List (List α)}, a ∈ L.flatten ↔ ∃ l ∈ L, a ∈ l
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Polynomial.cyclotomic_two : ∀ (R : Type u_1) [inst : Ring R], Polynomial.cyclotomic 2 R = Polynomial.X + 1
Result.success

Testing || BoxIntegral.Box.dist_le_distortion_mul : ∀ {ι : Type u_1} [inst : Fintype ι] (I : BoxIntegral.Box ι) (i : ι),
  dist I.lower I.upper ≤ ↑I.distortion * (I.upper i - I.lower i)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `OrderedAddCommGroup.toAddCommGroup`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || mul_le_of_le_of_le_one_of_nonneg : ∀ {α : Type u_3} {a b c : α} [inst : MulOneClass α] [inst_1 : _root_.Zero α] [inst_2 : Preorder α]
  [inst_3 : PosMulMono α], b ≤ c → a ≤ 1 → 0 ≤ b → b * a ≤ c
Result.success

Testing || CategoryTheory.Limits.hasCoequalizers_of_hasPushouts_and_binary_coproducts : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasBinaryCoproducts C]
  [inst_2 : CategoryTheory.Limits.HasPushouts C], CategoryTheory.Limits.HasCoequalizers C
Result.exception ::
Duper saturated

Testing || Function.OfArity.uncurry_two_eq_uncurry : ∀ {α β : Type u} (f : Function.OfArity α β 2), f.uncurry = Function.uncurry f ∘ ⇑(finTwoArrowEquiv α)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In Matrix.vecHead a✝³ →
  Function.FromTypes (Matrix.vecTail a✝³)
    a✝², type of ∀ bound variable is not of sort `Prop`, and depends on bound variables

Testing || mem_own_rightAddCoset : ∀ {α : Type u_1} [inst : AddMonoid α] (s : AddSubmonoid α) (a : α), a ∈ AddOpposite.op a +ᵥ ↑s
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #1, (∀ x1 : #1, ((!0 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || Ideal.isHomogeneous_iff_forall_subset : ∀ {ι : Type u_1} {σ : Type u_2} {A : Type u_3} [inst : Semiring A] [inst_1 : SetLike σ A]
  [inst_2 : AddSubmonoidClass σ A] (𝒜 : ι → σ) [inst_3 : DecidableEq ι] [inst_4 : AddMonoid ι] [inst_5 : GradedRing 𝒜]
  (I : Ideal A), Ideal.IsHomogeneous 𝒜 I ↔ ∀ (i : ι), ↑I ⊆ ⇑(GradedRing.proj 𝒜 i) ⁻¹' ↑I
Result.exception ::
Duper saturated

Testing || AlgebraicGeometry.Scheme.evaluation_naturality : ∀ {X Y : AlgebraicGeometry.Scheme} (f : X ⟶ Y) {V : Y.Opens} (x : ↑↑X.toPresheafedSpace) (hx : f.base x ∈ V),
  CategoryTheory.CategoryStruct.comp (Y.evaluation V (f.base x) hx) (AlgebraicGeometry.Scheme.Hom.residueFieldMap f x) =
    CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f V)
      (X.evaluation ((TopologicalSpace.Opens.map f.base).obj V) x hx)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.SingleObj.mapHom_comp : ∀ {M : Type u} [inst : Monoid M] {N : Type v} [inst_1 : Monoid N] (f : M →* N) {P : Type w} [inst_2 : Monoid P]
  (g : N →* P),
  (CategoryTheory.SingleObj.mapHom M P) (g.comp f) =
    ((CategoryTheory.SingleObj.mapHom M N) f).comp ((CategoryTheory.SingleObj.mapHom N P) g)
Result.success

Testing || isAddUnit_of_add_isAddUnit_right : ∀ {M : Type u_1} [inst : AddCommMonoid M] {x y : M}, IsAddUnit (x + y) → IsAddUnit y
Result.success

Testing || PMF.toOuterMeasure_uniformOfFintype_apply : ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : Nonempty α] (s : Set α),
  (PMF.uniformOfFintype α).toOuterMeasure s = ↑(Fintype.card ↑s) / ↑(Fintype.card α)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀ (hs : Finset.univ.Nonempty),
  PMF.uniformOfFintype α = PMF.uniformOfFinset Finset.univ hs, type of dependent ∀ bound variable is of sort `Prop`

Testing || AlgebraicTopology.DoldKan.Γ₀.Obj.map_on_summand : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  (K : ChainComplex C ℕ) [inst_2 : CategoryTheory.Limits.HasFiniteCoproducts C] {Δ Δ' : SimplexCategoryᵒᵖ}
  (A : SimplicialObject.Splitting.IndexSet Δ) (θ : Δ ⟶ Δ') {Δ'' : SimplexCategory} {e : Opposite.unop Δ' ⟶ Δ''}
  {i : Δ'' ⟶ Opposite.unop A.fst} [inst_3 : CategoryTheory.Epi e] [inst_4 : CategoryTheory.Mono i],
  CategoryTheory.CategoryStruct.comp e i = CategoryTheory.CategoryStruct.comp θ.unop A.e →
    CategoryTheory.CategoryStruct.comp (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan Δ).inj A)
        ((AlgebraicTopology.DoldKan.Γ₀.obj K).map θ) =
      CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.Γ₀.Obj.Termwise.mapMono K i)
        (((AlgebraicTopology.DoldKan.Γ₀.splitting K).cofan Δ').inj (SimplicialObject.Splitting.IndexSet.mk e))
Result.exception ::
Duper saturated

Testing || CircleDeg1Lift.le_iterate_of_add_int_le_map : ∀ (f : CircleDeg1Lift) {x : ℝ} {m : ℤ}, x + ↑m ≤ f x → ∀ (n : ℕ), x + ↑n * ↑m ≤ (⇑f)^[n] x
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ProbabilityTheory.Kernel.iIndepFun.meas_biInter : ∀ {α : Type u_1} {Ω : Type u_2} {ι : Type u_3} {β : ι → Type u_4} {mβ : (i : ι) → MeasurableSpace (β i)}
  {_mα : MeasurableSpace α} {_mΩ : MeasurableSpace Ω} {κ : ProbabilityTheory.Kernel α Ω} {μ : MeasureTheory.Measure α}
  {s : ι → Set Ω} {S : Finset ι} {f : (x : ι) → Ω → β x},
  ProbabilityTheory.Kernel.iIndepFun mβ f κ μ →
    (∀ i ∈ S, MeasurableSet (s i)) → ∀ᵐ (a : α) ∂μ, (κ a) (⋂ i ∈ S, s i) = ∏ i ∈ S, (κ a) (s i)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `f x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Functor.comp_obj : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {E : Type u₃} [inst_2 : CategoryTheory.Category.{v₃, u₃} E] (F : CategoryTheory.Functor C D)
  (G : CategoryTheory.Functor D E) (X : C), (F.comp G).obj X = G.obj (F.obj X)
Result.success

Testing || genericPoint_closure : ∀ (α : Type u_1) [inst : TopologicalSpace α] [inst_1 : QuasiSober α] [inst_2 : IrreducibleSpace α],
  closure {genericPoint α} = Set.univ
Result.exception ::
Duper saturated

Testing || AddMonoidHom.noncommCoprod.proof_2 : ∀ {M : Type u_1} {N : Type u_2} {P : Type u_3} [inst : AddZeroClass M] [inst_1 : AddZeroClass N] [inst_2 : AddMonoid P]
  (f : M →+ P) (g : N →+ P) (comm : ∀ (m : M) (n : N), AddCommute (f m) (g n)) (x y : M × N),
  ((↑f).noncommCoprod (↑g) comm).toFun (x + y) =
    ((↑f).noncommCoprod (↑g) comm).toFun x + ((↑f).noncommCoprod (↑g) comm).toFun y
Result.success

Testing || Finset.coe_mem : ∀ {α : Type u_1} {s : Finset α} (x : ↑↑s), ↑x ∈ s
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #0, (∀ x1 : #1, ((!4 (!6 (!7 x0)) x1) = (!0 x0 x1)))) is not type correct

Testing || Real.nat_cast_lt_toNNReal : ∀ {r : ℝ} {n : ℕ}, ↑n < r.toNNReal ↔ ↑n < r
Result.success

Testing || AddMonoidAlgebra.lift_apply : ∀ {k : Type u₁} {G : Type u₂} [inst : CommSemiring k] [inst_1 : AddMonoid G] {A : Type u₃} [inst_2 : Semiring A]
  [inst_3 : Algebra k A] (F : Multiplicative G →* A) (f : MonoidAlgebra k G),
  ((AddMonoidAlgebra.lift k G A) F) f = Finsupp.sum f fun a b => b • F (Multiplicative.ofAdd a)
Result.exception ::
Duper saturated

Testing || Finset.sup_singleton : ∀ {α : Type u_2} {β : Type u_3} [inst : SemilatticeSup α] [inst_1 : OrderBot α] {f : β → α} {b : β}, {b}.sup f = f b
Result.success

Testing || Complex.I_mul_im : ∀ (z : ℂ), (Complex.I * z).im = z.re
Result.exception ::
Duper saturated

Testing || Option.orElse_none' : ∀ {α : Type u_1} (x : Option α), (x.orElse fun x => none) = x
Result.exception ::
Duper saturated

Testing || Module.Flat.iff_lTensor_exact : ∀ {R : Type u} {M : Type v} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M],
  Module.Flat R M ↔
    ∀ ⦃N N' N'' : Type (max u v)⦄ [inst_3 : AddCommGroup N] [inst_4 : AddCommGroup N'] [inst_5 : AddCommGroup N'']
      [inst_6 : _root_.Module R N] [inst_7 : _root_.Module R N'] [inst_8 : _root_.Module R N''] ⦃f : N →ₗ[R] N'⦄
      ⦃g : N' →ₗ[R] N''⦄, Function.Exact ⇑f ⇑g → Function.Exact ⇑(LinearMap.lTensor M f) ⇑(LinearMap.lTensor M g)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `AddCommGroup.toAddCommMonoid`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Int.emod_negSucc : ∀ (m : ℕ) (n : ℤ), Int.negSucc m % n = Int.subNatNat n.natAbs (m % n.natAbs).succ
Result.success

Testing || Set.preimage_injective : ∀ {α : Type u} {β : Type v} {f : α → β}, Function.Injective (Set.preimage f) ↔ Function.Surjective f
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || HurwitzZeta.completedCosZeta_one_sub : ∀ (a : UnitAddCircle) (s : ℂ), HurwitzZeta.completedCosZeta a (1 - s) = HurwitzZeta.completedHurwitzZetaEven a s
Result.success

Testing || List.TFAE.out : ∀ {l : List Prop},
  l.TFAE →
    ∀ (n₁ n₂ : ℕ) {a b : Prop}, autoParam (l.get? n₁ = some a) _auto✝ → autoParam (l.get? n₂ = some b) _auto✝¹ → (a ↔ b)
Result.exception ::
Duper saturated

Testing || CommRingCat.Under.equalizerFork'_ι : ∀ {R : CommRingCat} {A B : Type u} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra (↑R) A]
  [inst_3 : Algebra (↑R) B] (f g : A →ₐ[↑R] B),
  (CommRingCat.Under.equalizerFork' f g).ι = (AlgHom.equalizer f g).val.toUnder
Result.success

Testing || OrderIso.map_csSup' : ∀ {α : Type u_1} {β : Type u_2} [inst : ConditionallyCompleteLattice α] [inst_1 : ConditionallyCompleteLattice β]
  (e : α ≃o β) {s : Set α}, s.Nonempty → BddAbove s → e (sSup s) = sSup (⇑e '' s)
Result.success

Testing || Nat.ofDigits_lt_base_pow_length : ∀ {b : ℕ} {l : List ℕ}, 1 < b → (∀ x ∈ l, x < b) → Nat.ofDigits b l < b ^ l.length
Result.exception ::
Duper saturated

Testing || EMetric.preimage_add_left_ball : ∀ {G : Type v} [inst : AddGroup G] [inst_1 : PseudoEMetricSpace G] [inst_2 : IsometricVAdd G G] (a b : G) (r : ENNReal),
  (fun x => a + x) ⁻¹' EMetric.ball b r = EMetric.ball (-a + b) r
Result.success

Testing || Cardinal.induction_on_pi : ∀ {ι : Type u} {p : (ι → Cardinal.{v}) → Prop} (f : ι → Cardinal.{v}),
  (∀ (f : ι → Type v), p fun i => Cardinal.mk (f i)) → p f
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Turing.PartrecToTM2.tr_move : ∀ (p : Turing.PartrecToTM2.Γ' → Bool) (k₁ k₂ : Turing.PartrecToTM2.K') (q : Turing.PartrecToTM2.Λ'),
  Turing.PartrecToTM2.tr (Turing.PartrecToTM2.Λ'.move p k₁ k₂ q) =
    Turing.PartrecToTM2.pop' k₁
      (Turing.TM2.Stmt.branch (fun s => s.elim true p) (Turing.TM2.Stmt.goto fun x => q)
        (Turing.PartrecToTM2.push' k₂ (Turing.TM2.Stmt.goto fun x => Turing.PartrecToTM2.Λ'.move p k₁ k₂ q)))
Result.success

Testing || Array.reflBEq_iff : ∀ {α : Type u_1} [inst : BEq α], ReflBEq (Array α) ↔ ReflBEq α
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || LinearMap.finiteDimensional : ∀ {K : Type u_1} [inst : Field K] {V : Type u_2} [inst_1 : AddCommGroup V] [inst_2 : _root_.Module K V]
  [inst_3 : FiniteDimensional K V] {W : Type u_3} [inst_4 : AddCommGroup W] [inst_5 : _root_.Module K W]
  [inst_6 : FiniteDimensional K W], FiniteDimensional K (V →ₗ[K] W)
Result.success

Testing || sum_conjClasses_card_eq_card : ∀ (G : Type u_1) [inst : Group G] [inst_1 : Fintype (ConjClasses G)] [inst_2 : Fintype G]
  [inst_3 : (x : ConjClasses G) → Fintype ↑x.carrier], ∑ x : ConjClasses G, x.carrier.toFinset.card = Fintype.card G
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `inst✝ x`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || nonempty_Prop : ∀ {p : Prop}, Nonempty p ↔ p
Result.success

Testing || WithTop.instOrderedSub : ∀ {α : Type u_1} [inst : CanonicallyOrderedAddCommMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α],
  OrderedSub (WithTop α)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `WithTop.instSub`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Ideal.comap_map_mk : ∀ {R : Type u} [inst : CommRing R] {I J : Ideal R},
  I ≤ J → Ideal.comap (Ideal.Quotient.mk I) (Ideal.map (Ideal.Quotient.mk I) J) = J
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Ideal.Quotient.commRing x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Std.DHashMap.Internal.Raw₀.contains_insertIfNew : ∀ {α : Type u} {β : α → Type v} (m : Std.DHashMap.Internal.Raw₀ α β) [inst : BEq α] [inst_1 : Hashable α]
  [inst_2 : EquivBEq α] [inst_3 : LawfulHashable α],
  (↑m).WF → ∀ {k a : α} {v : β k}, (m.insertIfNew k v).contains a = (k == a || m.contains a)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.ShortComplex.opcyclesMap'_g'_assoc : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  {S₁ S₂ : CategoryTheory.ShortComplex C} (φ : S₁ ⟶ S₂) (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) {Z : C}
  (h : S₂.X₃ ⟶ Z),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap' φ h₁ h₂)
      (CategoryTheory.CategoryStruct.comp h₂.g' h) =
    CategoryTheory.CategoryStruct.comp h₁.g' (CategoryTheory.CategoryStruct.comp φ.τ₃ h)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.p`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || act_rel_of_act_rel_of_rel_act_rel : ∀ {M : Type u_1} {N : Type u_2} {μ : M → N → N} {r : N → N → Prop} [inst : ContravariantClass M N μ r]
  [inst : IsTrans N r] (m : M) {a b c : N}, r (μ m a) b → r (μ m b) (μ m c) → r (μ m a) c
Result.success

Testing || hasContinuousInv₀_of_hasSmoothInv₀ : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {H : Type u_2} [inst_1 : TopologicalSpace H] {E : Type u_3}
  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace 𝕜 E] {I : ModelWithCorners 𝕜 E H} {G : Type u_4}
  [inst_4 : TopologicalSpace G] [inst_5 : ChartedSpace H G] [inst_6 : Inv G] [inst_7 : _root_.Zero G]
  [inst : SmoothInv₀ I G], HasContinuousInv₀ G
Result.exception ::
Duper saturated

Testing || BitVec.msb_eq_getLsbD_last : ∀ {w : ℕ} (x : BitVec w), x.msb = x.getLsbD (w - 1)
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WittVector.mul_polyOfInterest_aux5 : ∀ (p : ℕ) [hp : Fact (Nat.Prime p)] (n : ℕ),
  ↑p ^ (n + 1) * WittVector.polyOfInterest p n = WittVector.remainder p n - WittVector.wittPolyProdRemainder p (n + 1)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.MorphismProperty.pullback_fst : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {P : CategoryTheory.MorphismProperty C}
  [inst_1 : P.IsStableUnderBaseChange] {X Y S : C} (f : X ⟶ S) (g : Y ⟶ S)
  [inst_2 : CategoryTheory.Limits.HasPullback f g], P g → P (CategoryTheory.Limits.pullback.fst f g)
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.MorphismProperty C is not a `∀`

Testing || Eq.ge : ∀ {α : Type u_2} [inst : Preorder α] {x y : α}, x = y → y ≤ x
Result.success

Testing || Set.infinite_prod : ∀ {α : Type u_1} {β : Type u_2} {s : Set α} {t : Set β},
  (s ×ˢ t).Infinite ↔ s.Infinite ∧ t.Nonempty ∨ t.Infinite ∧ s.Nonempty
Result.success

Testing || IsLocalization.submonoid_map_le_is_unit : ∀ {R : Type u_1} [inst : CommRing R] (M : Submonoid R) (S : Type u_2) [inst_1 : CommRing S] [inst_2 : Algebra R S]
  [inst_3 : IsLocalization M S], Submonoid.map (algebraMap R S) M ≤ IsUnit.submonoid S
Result.exception ::
Duper saturated

Testing || instNontrivialStalkPresheafSmoothSheaf : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {EM : Type u_2} [inst_1 : NormedAddCommGroup EM]
  [inst_2 : NormedSpace 𝕜 EM] {HM : Type u_3} [inst_3 : TopologicalSpace HM] (IM : ModelWithCorners 𝕜 EM HM)
  {E : Type u_4} [inst_4 : NormedAddCommGroup E] [inst_5 : NormedSpace 𝕜 E] {H : Type u_5} [inst_6 : TopologicalSpace H]
  (I : ModelWithCorners 𝕜 E H) {M : Type u} [inst_7 : TopologicalSpace M] [inst_8 : ChartedSpace HM M] (N : Type u)
  [inst_9 : TopologicalSpace N] [inst_10 : ChartedSpace H N] [inst_11 : Nontrivial N] (x : M),
  Nontrivial ((smoothSheaf IM I M N).presheaf.stalk x)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `smoothSheaf.eval x_0 x_1 cifvar_1
  x_2`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Limits.colimitYonedaHomIsoLimitOp_π_apply : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{u₂, u₁} C] {I : Type v₁} [inst_1 : CategoryTheory.Category.{v₂, v₁} I]
  (D : CategoryTheory.Functor I C) (F : CategoryTheory.Functor Cᵒᵖ (Type u₂))
  [inst_2 : CategoryTheory.Limits.HasColimit (D.comp CategoryTheory.yoneda)]
  [inst_3 : CategoryTheory.Limits.HasLimitsOfShape Iᵒᵖ (Type (max u₁ u₂))]
  (f : CategoryTheory.Limits.colimit (D.comp CategoryTheory.yoneda) ⟶ F) (i : Iᵒᵖ),
  CategoryTheory.Limits.limit.π (D.op.comp (F.comp CategoryTheory.uliftFunctor.{u₁, u₂})) i
      ((CategoryTheory.Limits.colimitYonedaHomIsoLimitOp D F).hom f) =
    {
      down :=
        f.app (Opposite.op (D.obj (Opposite.unop i)))
          ((CategoryTheory.Limits.colimit.ι (D.comp CategoryTheory.yoneda) (Opposite.unop i)).app
            (Opposite.op (D.obj (Opposite.unop i))) (CategoryTheory.CategoryStruct.id (D.obj (Opposite.unop i)))) }
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: (CategoryTheory.Limits.colimit (D.comp CategoryTheory.yoneda) ⟶ F) ⟶
  CategoryTheory.Limits.limit (D.op.comp (F.comp CategoryTheory.uliftFunctor.{u₁, u₂})) is not a `∀`

Testing || Asymptotics.isEquivalent_iff_exists_eq_mul : ∀ {α : Type u_1} {β : Type u_2} [inst : NormedField β] {u v : α → β} {l : Filter α},
  Asymptotics.IsEquivalent l u v ↔ ∃ φ, ∃ (_ : Filter.Tendsto φ l (nhds 1)), u =ᶠ[l] φ * v
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Filter.Tendsto φ l
  (nhds 1) of λ binder contains bound variables

Testing || norm_add_sq_real : ∀ {F : Type u_3} [inst : SeminormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] (x y : F),
  ‖x + y‖ ^ 2 = ‖x‖ ^ 2 + 2 * inner x y + ‖y‖ ^ 2
Result.exception ::
Duper saturated

Testing || Polynomial.natDegree_pos_of_not_isUnit_of_dvd_monic : ∀ {R : Type u} [inst : CommSemiring R] {a p : Polynomial R}, p.Monic → ¬IsUnit a → a ∣ p → 0 < a.natDegree
Result.success

Testing || MeasureTheory.SimpleFunc.measurableSet_preimage : ∀ {α : Type u_1} {β : Type u_2} [inst : MeasurableSpace α] (f : MeasureTheory.SimpleFunc α β) (s : Set β),
  MeasurableSet (⇑f ⁻¹' s)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || EMetric.tendsto_nhds_nhds : ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β} {a : α} {b : β},
  Filter.Tendsto f (nhds a) (nhds b) ↔ ∀ ε > 0, ∃ δ > 0, ∀ ⦃x : α⦄, edist x a < δ → edist (f x) b < ε
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || QuadraticModuleCat.forget₂_map : ∀ {R : Type u} [inst : CommRing R] (X Y : QuadraticModuleCat R) (f : X ⟶ Y),
  (CategoryTheory.forget₂ (QuadraticModuleCat R) (ModuleCat R)).map f = ModuleCat.ofHom f.toIsometry.toLinearMap
Result.success

Testing || ZeroHom.comp.proof_1 : ∀ {M : Type u_3} {N : Type u_2} {P : Type u_1} [inst : _root_.Zero M] [inst_1 : _root_.Zero N] [inst_2 : _root_.Zero P]
  (hnp : ZeroHom N P) (hmn : ZeroHom M N), hnp (hmn 0) = 0
Result.success

Testing || Turing.PartrecToTM2.supports_insert : ∀ {K S : Finset Turing.PartrecToTM2.Λ'} {q : Turing.PartrecToTM2.Λ'},
  Turing.PartrecToTM2.Supports (insert q K) S ↔
    Turing.TM2.SupportsStmt S (Turing.PartrecToTM2.tr q) ∧ Turing.PartrecToTM2.Supports K S
Result.exception ::
(deterministic) timeout at `«forward demodulation»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ContinuousLinearEquiv.isOpen : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : SeminormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F]
  [inst_5 : CompleteSpace E], IsOpen (Set.range ContinuousLinearEquiv.toContinuousLinearMap)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : (#1 → #2), (∀ x1 : (#2 → Prop), ((∀ x2 : #2, ((!6 (!2 x0) x2) → (x1 x2))) ↔ (∀ x2 : #1, (x1 (x0 x2)))))) is not type correct

Testing || MeasureTheory.StronglyMeasurable.measurableSet_mulSupport : ∀ {α : Type u_1} {β : Type u_2} {f : α → β} {m : MeasurableSpace α} [inst : _root_.One β] [inst_1 : TopologicalSpace β]
  [inst_2 : TopologicalSpace.MetrizableSpace β],
  MeasureTheory.StronglyMeasurable f → MeasurableSet (Function.mulSupport f)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Measurable x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || DirichletCharacter.isMultiplicative_toArithmeticFunction : ∀ {N : ℕ} {R : Type u_1} [inst : CommMonoidWithZero R] (χ : DirichletCharacter R N),
  (toArithmeticFunction fun x => χ ↑x).IsMultiplicative
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || mem_perms_of_finset_iff : ∀ {α : Type u_1} [inst : DecidableEq α] {s : Finset α} {f : Equiv.Perm α},
  f ∈ permsOfFinset s ↔ ∀ {x : α}, f x ≠ x → x ∈ s
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || _private.Mathlib.Data.Real.Pi.Irrational.0.is_integer : ∀ {p : Polynomial ℤ} (a b : ℤ) {k : ℕ},
  p.natDegree ≤ k → ∃ z, Polynomial.eval₂ (Int.castRingHom ℝ) (↑a / ↑b) p * ↑b ^ k = ↑z
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Order.height_eq_top_iff : ∀ {α : Type u_1} [inst : Preorder α] {x : α}, Order.height x = ⊤ ↔ ∀ (n : ℕ), ∃ p, RelSeries.last p = x ∧ p.length = n
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `OrderTop.toTop`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.getD_map : ∀ {α : Type u} {β : Type v} (l : List α) (d : α) {n : ℕ} (f : α → β), (List.map f l).getD n (f d) = f (l.getD n d)
Result.success

Testing || FiniteDimensional.exists_is_basis_integral : ∀ (A : Type u_1) (K : Type u_2) [inst : CommRing A] [inst_1 : Field K] [inst_2 : Algebra A K]
  [inst_3 : IsFractionRing A K] (L : Type u_3) [inst_4 : Field L] [inst_5 : Algebra K L] [inst_6 : Algebra A L]
  [inst_7 : IsScalarTower A K L] [inst_8 : FiniteDimensional K L] [inst_9 : IsDomain A],
  ∃ s b, ∀ (x : { x // x ∈ s }), IsIntegral A (b x)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Basis { x // x ∈ s } K L of λ binder contains bound variables

Testing || LinearMap.prod_eq_inf_comap : ∀ {R : Type u} {M : Type v} {M₂ : Type w} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : AddCommMonoid M₂]
  [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R M₂] (p : Submodule R M) (q : Submodule R M₂),
  p.prod q = Submodule.comap (LinearMap.fst R M M₂) p ⊓ Submodule.comap (LinearMap.snd R M M₂) q
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `LinearMap.instFunLike`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || HahnSeries.toPowerSeriesAlg_apply : ∀ (R : Type u_2) [inst : CommSemiring R] {A : Type u_3} [inst_1 : Semiring A] [inst_2 : Algebra R A]
  (f : HahnSeries ℕ A), (HahnSeries.toPowerSeriesAlg R) f = PowerSeries.mk f.coeff
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (¬ ((!0 !1 !2) = (!3 (!4 !2)))) is not type correct

Testing || Order.Iic_pred_of_not_isMin : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : PredOrder α] {a : α}, ¬IsMin a → Set.Iic (Order.pred a) = Set.Iio a
Result.exception ::
Duper saturated

Testing || Complex.abs_of_nonneg : ∀ {r : ℝ}, 0 ≤ r → Complex.abs ↑r = r
Result.success

Testing || eventually_uniformity_iterate_comp_subset : ∀ {α : Type ua} [inst : UniformSpace α] {s : Set (α × α)},
  s ∈ uniformity α → ∀ (n : ℕ), ∀ᶠ (t : Set (α × α)) in (uniformity α).smallSets, (fun x => compRel t x)^[n] t ⊆ s
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Set (α × α) is not a `∀`

Testing || Sum.Lex.Icc_inr_inr : ∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : OrderTop α] [inst_3 : OrderBot β]
  [inst_4 : LocallyFiniteOrder α] [inst_5 : LocallyFiniteOrder β] (b₁ b₂ : β),
  Finset.Icc (Sum.inrₗ b₁) (Sum.inrₗ b₂) =
    Finset.map (Function.Embedding.inr.trans toLex.toEmbedding) (Finset.Icc b₁ b₂)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀ (inj' : Function.Injective Sum.inr),
  Function.Embedding.inr = { toFun := Sum.inr, inj' := inj' }, type of dependent ∀ bound variable is of sort `Prop`

Testing || AlgebraicGeometry.LocallyRingedSpace.stalkMap_inv_hom_assoc : ∀ {X Y : AlgebraicGeometry.LocallyRingedSpace} (e : X ≅ Y) (x : ↑X.toTopCat) {Z : CommRingCat}
  (h : X.presheaf.stalk x ⟶ Z),
  CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.LocallyRingedSpace.Hom.stalkMap e.inv (e.hom.base x))
      (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.LocallyRingedSpace.Hom.stalkMap e.hom x) h) =
    CategoryTheory.CategoryStruct.comp (X.presheaf.stalkSpecializes ⋯) h
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Nat.even_sub : ∀ {m n : ℕ}, n ≤ m → (Even (m - n) ↔ (Even m ↔ Even n))
Result.success

Testing || List.mem_of_mem_inter_right : ∀ {α : Type u_1} {l₁ l₂ : List α} {a : α} [inst : DecidableEq α], a ∈ l₁ ∩ l₂ → a ∈ l₂
Result.success

Testing || Set.Finite.toFinset_insert : ∀ {α : Type u} [inst : DecidableEq α] {s : Set α} {a : α} (hs : (insert a s).Finite), hs.toFinset = insert a ⋯.toFinset
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.instInsert`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || QuotientAddGroup.quotientEquivSelf.proof_3 : ∀ (α : Type u_1) (x : α), x = x
Result.success

Testing || List.eq_nil_of_map_eq_nil : ∀ {α : Type u_1} {β : Type u_2} {f : α → β} {l : List α}, List.map f l = [] → l = []
Result.success

Testing || NumberField.InfinitePlace.comap_id : ∀ {K : Type u_2} [inst : Field K] (w : NumberField.InfinitePlace K), w.comap (RingHom.id K) = w
Result.success

Testing || RelIso.cast_trans : ∀ {α β γ : Type u} {r : α → α → Prop} {s : β → β → Prop} {t : γ → γ → Prop} (h₁ : α = β) (h₁' : β = γ) (h₂ : HEq r s)
  (h₂' : HEq s t), (RelIso.cast h₁ h₂).trans (RelIso.cast h₁' h₂') = RelIso.cast ⋯ ⋯
Result.exception ::
Duper saturated

Testing || Set.nontrivial_of_lt : ∀ {α : Type u} {s : Set α} [inst : Preorder α] {x y : α}, x ∈ s → y ∈ s → x < y → s.Nontrivial
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #1, (∀ x1 : #1, ((!0 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || CategoryTheory.Groupoid.Free.of_eq : ∀ {V : Type u} [inst : Quiver V],
  CategoryTheory.Groupoid.Free.of V =
    Quiver.Symmetrify.of ⋙q CategoryTheory.Paths.of ⋙q
      (CategoryTheory.Quotient.functor CategoryTheory.Groupoid.Free.redStep).toPrefunctor
Result.success

Testing || Antitone.iUnion_comp_tendsto_atBot : ∀ {α : Type u_3} {β : Type u_4} {γ : Type u_5} [inst : Preorder β] {l : Filter α} [inst_1 : l.NeBot] {s : β → Set γ},
  Antitone s → ∀ {f : α → β}, Filter.Tendsto f l Filter.atBot → ⋃ a, s (f a) = ⋃ b, s b
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Filter.atBot`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Filter.map_sigma_mk_comap : ∀ {α : Type u_1} {β : Type u_2} {π : α → Type u_6} {π' : β → Type u_7} {f : α → β},
  Function.Injective f →
    ∀ (g : (a : α) → π a → π' (f a)) (a : α) (l : Filter (π' (f a))),
      Filter.map (Sigma.mk a) (Filter.comap (g a) l) = Filter.comap (Sigma.map f g) (Filter.map (Sigma.mk (f a)) l)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Sigma.mk i`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || ProbabilityTheory.mgf_smul_left : ∀ {Ω : Type u_1} {m : MeasurableSpace Ω} {X : Ω → ℝ} {μ : MeasureTheory.Measure Ω} {t : ℝ} (α : ℝ),
  ProbabilityTheory.mgf (α • X) μ t = ProbabilityTheory.mgf X μ (α * t)
Result.exception ::
(deterministic) timeout at `«forward demodulation»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.ShortComplex.SnakeInput.L₃_exact : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Abelian C]
  (S : CategoryTheory.ShortComplex.SnakeInput C), S.L₃.Exact
Result.exception ::
Duper saturated

Testing || PartialHomeomorph.eventually_left_inverse' : ∀ {X : Type u_1} {Y : Type u_3} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (e : PartialHomeomorph X Y)
  {x : Y}, x ∈ e.target → ∀ᶠ (y : X) in nhds (↑e.symm x), ↑e.symm (↑e y) = y
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #1, (∀ x1 : #1, ((!0 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || CategoryTheory.ComposableArrows.homMk₃_app_zero : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {f g : CategoryTheory.ComposableArrows C 3}
  (app₀ : f.obj' 0 ⋯ ⟶ g.obj' 0 ⋯) (app₁ : f.obj' 1 ⋯ ⟶ g.obj' 1 ⋯) (app₂ : f.obj' 2 ⋯ ⟶ g.obj' 2 ⋯)
  (app₃ : f.obj' 3 ⋯ ⟶ g.obj' 3 ⋯)
  (w₀ :
    CategoryTheory.CategoryStruct.comp (f.map' 0 1 ⋯ ⋯) app₁ = CategoryTheory.CategoryStruct.comp app₀ (g.map' 0 1 ⋯ ⋯))
  (w₁ :
    CategoryTheory.CategoryStruct.comp (f.map' 1 2 ⋯ ⋯) app₂ = CategoryTheory.CategoryStruct.comp app₁ (g.map' 1 2 ⋯ ⋯))
  (w₂ :
    CategoryTheory.CategoryStruct.comp (f.map' 2 3 ⋯ ⋯) app₃ =
      CategoryTheory.CategoryStruct.comp app₂ (g.map' 2 3 ⋯ ⋯)),
  (CategoryTheory.ComposableArrows.homMk₃ app₀ app₁ app₂ app₃ w₀ w₁ w₂).app 0 = app₀
Result.exception ::
Auto.Lemma.rewriteUMonoRigid? :: Motive fun _a =>
  CategoryTheory.CategoryStruct.comp (f.map (CategoryTheory.homOfLE ⋯)) app₁ =
    CategoryTheory.CategoryStruct.comp app₀ (g.map (CategoryTheory.homOfLE ⋯)) is not type correct

Testing || ProbabilityTheory.Kernel.condKernelCountable_apply : ∀ {α : Type u_1} {β : Type u_2} {Ω : Type u_3} {mα : MeasurableSpace α} {mβ : MeasurableSpace β}
  {mΩ : MeasurableSpace Ω} [inst : Countable α] (κCond : α → ProbabilityTheory.Kernel β Ω)
  (h_atom : ∀ (x y : α), x ∈ measurableAtom y → κCond x = κCond y) (p : α × β),
  (ProbabilityTheory.Kernel.condKernelCountable κCond h_atom) p = (κCond p.1) p.2
Result.success

Testing || MonoidHom.submonoidComap_apply_coe : ∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] (f : M →* N) (N' : Submonoid N)
  (x : ↥(Submonoid.comap f N')), ↑((f.submonoidComap N') x) = f ↑x
Result.success

Testing || Batteries.instTransCmpFlipOrdering : ∀ {α : Sort u_1} {cmp : α → α → Ordering} [inst : Batteries.TransCmp cmp], Batteries.TransCmp (flip cmp)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || LinearMap.BilinForm.nondegenerate_of_det_ne_zero : ∀ {M₂ : Type u_4} [inst : AddCommGroup M₂] {A : Type u_5} [inst_1 : CommRing A] [inst_2 : IsDomain A]
  [inst_3 : _root_.Module A M₂] (B₃ : LinearMap.BilinForm A M₂) {ι : Type u_6} [inst_4 : DecidableEq ι]
  [inst_5 : Fintype ι] (b : Basis ι A M₂), ((BilinForm.toMatrix b) B₃).det ≠ 0 → B₃.Nondegenerate
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (¬ ((!1 !2 (!3 (!4 !5) !6)) = !7)) is not type correct

Testing || NumberField.Units.dirichletUnitTheorem.unitLattice_span_eq_top : ∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K], Submodule.span ℝ ↑(NumberField.Units.unitLattice K) = ⊤
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || translate_neg_right : ∀ {α : Type u_2} {G : Type u_5} [inst : AddCommGroup G] [inst_1 : Neg α] (a : G) (f : G → α),
  translate a (-f) = -translate a f
Result.exception ::
Duper saturated

Testing || ContDiff.of_succ : ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}
  {n : WithTop ℕ∞}, ContDiff 𝕜 (n + 1) f → ContDiff 𝕜 n f
Result.success

Testing || Matrix.det_updateCol_add_self : ∀ {n : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (A : Matrix n n R)
  {i j : n}, i ≠ j → (A.updateCol i fun k => A k i + A k j).det = A.det
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix n n R is not a `∀`

Testing || uniformContinuous_const : ∀ {α : Type ua} {β : Type ub} [inst : UniformSpace α] [inst_1 : UniformSpace β] {b : β}, UniformContinuous fun x => b
Result.success

Testing || CategoryTheory.Adjunction.compPreadditiveYonedaIso_hom_app_app_apply : ∀ {C : Type u₁} {D : Type u₂} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  [inst_2 : CategoryTheory.Preadditive C] [inst_3 : CategoryTheory.Preadditive D] {F : CategoryTheory.Functor C D}
  {G : CategoryTheory.Functor D C} (adj : F ⊣ G) [inst_4 : F.Additive] (X : Cᵒᵖ) (Y : D)
  (a : ULift.{max v₁ v₂, v₁} (Opposite.unop X ⟶ G.obj Y)),
  ((adj.compPreadditiveYonedaIso.hom.app Y).app X) a =
    { down := (adj.homEquiv (Opposite.unop X) Y).symm (AddEquiv.ulift a) }
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ContinuousLinearEquiv.compContinuousMultilinearMapL_apply : ∀ {𝕜 : Type u} {ι : Type v} {E : ι → Type wE} {G : Type wG} {G' : Type wG'} [inst : NontriviallyNormedField 𝕜]
  [inst_1 : (i : ι) → SeminormedAddCommGroup (E i)] [inst_2 : (i : ι) → NormedSpace 𝕜 (E i)]
  [inst_3 : SeminormedAddCommGroup G] [inst_4 : NormedSpace 𝕜 G] [inst_5 : SeminormedAddCommGroup G']
  [inst_6 : NormedSpace 𝕜 G'] [inst_7 : Fintype ι] (g : G ≃L[𝕜] G') (f : ContinuousMultilinearMap 𝕜 E G),
  (ContinuousLinearEquiv.compContinuousMultilinearMapL E g) f = (↑g).compContinuousMultilinearMap f
Result.success

Testing || conjneg_conjneg : ∀ {G : Type u_2} {R : Type u_3} [inst : AddGroup G] [inst_1 : CommSemiring R] [inst_2 : StarRing R] (f : G → R),
  conjneg (conjneg f) = f
Result.exception ::
Duper saturated

Testing || ProbabilityTheory.Kernel.IsSFiniteKernel.snd : ∀ {α : Type u_1} {β : Type u_2} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} {γ : Type u_4}
  {mγ : MeasurableSpace γ} (κ : ProbabilityTheory.Kernel α (β × γ)) [inst : ProbabilityTheory.IsSFiniteKernel κ],
  ProbabilityTheory.IsSFiniteKernel κ.snd
Result.success

Testing || CategoryTheory.preserves_mono_of_preservesLimit : ∀ {C : Type u₁} {D : Type u₂} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  (F : CategoryTheory.Functor C D) {X Y : C} (f : X ⟶ Y)
  [inst_2 : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f f) F] [inst_3 : CategoryTheory.Mono f],
  CategoryTheory.Mono (F.map f)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_20 x_0).map
  (cifvar_9 x_1 x_2)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AddGroupNormClass.toNormedAddGroup.proof_1 : ∀ {F : Type u_2} {α : Type u_1} [inst : FunLike F α ℝ] [inst_1 : AddGroup α] [inst_2 : AddGroupNormClass F α ℝ] (f : F)
  {x y : α}, dist x y = 0 → x = y
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #1, (∀ x1 : #1, ((!11 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || PadicInt.nonarchimedean : ∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (q r : ℤ_[p]), ‖q + r‖ ≤ ‖q‖ ⊔ ‖r‖
Result.success

Testing || CategoryTheory.Pretriangulated.instIsHomologicalOppositeAddCommGrpObjFunctorPreadditiveYoneda : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  [inst_2 : CategoryTheory.HasShift C ℤ] [inst_3 : CategoryTheory.Limits.HasZeroObject C]
  [inst_4 : ∀ (n : ℤ), (CategoryTheory.shiftFunctor C n).Additive] [inst_5 : CategoryTheory.Pretriangulated C] (B : C),
  (CategoryTheory.preadditiveYoneda.obj B).IsHomological
Result.exception ::
Duper saturated

Testing || StrictConvexOn.lt_on_open_segment' : ∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_5} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]
  [inst_2 : LinearOrderedAddCommMonoid β] [inst_3 : SMul 𝕜 E] [inst_4 : _root_.Module 𝕜 β] [inst_5 : OrderedSMul 𝕜 β]
  {s : Set E} {f : E → β},
  StrictConvexOn 𝕜 s f →
    ∀ {x y : E}, x ∈ s → y ∈ s → x ≠ y → ∀ {a b : 𝕜}, 0 < a → 0 < b → a + b = 1 → f (a • x + b • y) < f x ⊔ f y
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Preorder.toLE`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || OrderedCommGroup.toMulLeftReflectLE : ∀ (α : Type u) [inst : OrderedCommGroup α], MulLeftReflectLE α
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || neg_of_smul_neg_right' : ∀ {α : Type u_1} {β : Type u_2} {a : α} {b : β} [inst : _root_.Zero α] [inst_1 : _root_.Zero β]
  [inst_2 : SMulWithZero α β] [inst_3 : LinearOrder α] [inst_4 : LinearOrder β] [inst_5 : PosSMulMono α β],
  a • b < 0 → 0 ≤ b → a < 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `SMulZeroClass.toSMul`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Std.DHashMap.Internal.Raw₀.size_le_size_insert : ∀ {α : Type u} {β : α → Type v} (m : Std.DHashMap.Internal.Raw₀ α β) [inst : BEq α] [inst_1 : Hashable α]
  [inst_2 : EquivBEq α] [inst_3 : LawfulHashable α], (↑m).WF → ∀ {k : α} {v : β k}, (↑m).size ≤ (↑(m.insert k v)).size
Result.exception ::
Duper saturated

Testing || CategoryTheory.Zigzag.of_zag : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {j₁ j₂ : J},
  CategoryTheory.Zag j₁ j₂ → CategoryTheory.Zigzag j₁ j₂
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || HomogeneousIdeal.toIdeal_iSup₂ : ∀ {ι : Type u_1} {σ : Type u_2} {A : Type u_3} [inst : Semiring A] [inst_1 : DecidableEq ι] [inst_2 : AddMonoid ι]
  [inst_3 : SetLike σ A] [inst_4 : AddSubmonoidClass σ A] {𝒜 : ι → σ} [inst_5 : GradedRing 𝒜] {κ : Sort u_4}
  {κ' : κ → Sort u_5} (s : (i : κ) → κ' i → HomogeneousIdeal 𝒜), (⨆ i, ⨆ j, s i j).toIdeal = ⨆ i, ⨆ j, (s i j).toIdeal
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type κ' i✝ of λ binder contains bound variables

Testing || CategoryTheory.GrothendieckTopology.sheafifyLift_unique : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (J : CategoryTheory.GrothendieckTopology C) {D : Type w}
  [inst_1 : CategoryTheory.Category.{max v u, w} D]
  [inst_2 :
    ∀ (P : CategoryTheory.Functor Cᵒᵖ D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)]
  [inst_3 : ∀ (X : C), CategoryTheory.Limits.HasColimitsOfShape (J.Cover X)ᵒᵖ D] {P Q : CategoryTheory.Functor Cᵒᵖ D}
  (η : P ⟶ Q) (hQ : CategoryTheory.Presheaf.IsSheaf J Q) (γ : J.sheafify P ⟶ Q),
  CategoryTheory.CategoryStruct.comp (J.toSheafify P) γ = η → γ = J.sheafifyLift η hQ
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_2.instPreorderCover x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Asymptotics.IsBigO.eventually_integrableOn : ∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] {g : α → F} {l : Filter α} {ι : Type u_4}
  [inst_1 : MeasurableSpace ι] {f : ι × α → E} {s : Set ι} {μ : MeasureTheory.Measure ι} [inst_2 : Norm F],
  f =O[Filter.principal s ×ˢ l] (g ∘ Prod.snd) →
    (∀ᶠ (x : α) in l, MeasureTheory.AEStronglyMeasurable (fun i => f (i, x)) (μ.restrict s)) →
      MeasurableSet s → μ s < ⊤ → ∀ᶠ (x : α) in l, MeasureTheory.IntegrableOn (fun i => f (i, x)) s μ
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : (#12 → Prop), (∀ x1 : #16, ((!31 (λx2 : #12, (x0 x2)) x1) → (∃ x2 : #17, ((!32 x1 x2) ∧ (∀ x3 : #12, ((!33 x2 x3) → (x0 x3)))))))) is not type correct

Testing || Associates.le_singleton_iff : ∀ {A : Type u_2} [inst : CommRing A] [inst_1 : IsDedekindDomain A] (x : A) (n : ℕ) (I : Ideal A),
  Associates.mk I ^ n ≤ Associates.mk (Ideal.span {x}) ↔ x ∈ I ^ n
Result.success

Testing || Subgroup.op_iInf : ∀ {ι : Sort u_1} {G : Type u_2} [inst : Group G] (S : ι → Subgroup G), (iInf S).op = ⨅ i, (S i).op
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || mul_nsmul' : ∀ {M : Type u_2} [inst : AddMonoid M] (a : M) (m n : ℕ), (m * n) • a = m • n • a
Result.success

Testing || Multiset.coe_eq_singleton : ∀ {α : Type u_1} {l : List α} {a : α}, ↑l = {a} ↔ l = [a]
Result.success

Testing || Polynomial.opRingEquiv_op_monomial : ∀ {R : Type u_1} [inst : Semiring R] (n : ℕ) (r : R),
  (Polynomial.opRingEquiv R) (MulOpposite.op ((Polynomial.monomial n) r)) = (Polynomial.monomial n) (MulOpposite.op r)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Classical.decEq
  (cifvar_38 cifvar_39) b cifvar_33`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Monotone.map_liminf_of_continuousAt : ∀ {ι : Type u_1} {R : Type u_4} {S : Type u_5} {F : Filter ι} [inst : F.NeBot]
  [inst : ConditionallyCompleteLinearOrder R] [inst_1 : TopologicalSpace R] [inst_2 : OrderTopology R]
  [inst_3 : ConditionallyCompleteLinearOrder S] [inst_4 : TopologicalSpace S] [inst_5 : OrderTopology S] {f : R → S},
  Monotone f →
    ∀ (a : ι → R),
      ContinuousAt f (Filter.liminf a F) →
        autoParam (Filter.IsCoboundedUnder (fun x1 x2 => x1 ≥ x2) F a) _auto✝ →
          autoParam (Filter.IsBoundedUnder (fun x1 x2 => x1 ≥ x2) F a) _auto✝¹ →
            f (Filter.liminf a F) = Filter.liminf (f ∘ a) F
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `ConditionallyCompleteLinearOrder.toConditionallyCompleteLattice`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Set.ball_empty_iff : ∀ {α : Type u} {p : α → Prop}, (∀ x ∈ ∅, p x) ↔ True
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #0, ((!0 !2 x0) = (!2 x0))) is not type correct

Testing || AddSubmonoid.prod_le_iff : ∀ {N : Type u_2} [inst : AddZeroClass N] {M : Type u_5} [inst_1 : AddZeroClass M] {s : AddSubmonoid M}
  {t : AddSubmonoid N} {u : AddSubmonoid (M × N)},
  s.prod t ≤ u ↔ AddSubmonoid.map (AddMonoidHom.inl M N) s ≤ u ∧ AddSubmonoid.map (AddMonoidHom.inr M N) t ≤ u
Result.exception ::
Duper saturated

Testing || Real.sin_pos_of_mem_Ioo : ∀ {x : ℝ}, x ∈ Set.Ioo 0 Real.pi → 0 < Real.sin x
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #1, (∀ x1 : #1, ((!0 (!7 x0) x1) = (!5 x0 x1)))) is not type correct

Testing || Equiv.Perm.commute_of_mem_cycleFactorsFinset_commute : ∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : Fintype α] (k g : Equiv.Perm α),
  (∀ c ∈ g.cycleFactorsFinset, Commute k c) → Commute k g
Result.exception ::
Duper saturated

Testing || Submonoid.prod_eq_bot_iff : ∀ {M : Type u_1} {N : Type u_2} [inst : MulOneClass M] [inst_1 : MulOneClass N] {s : Submonoid M} {t : Submonoid N},
  s.prod t = ⊥ ↔ s = ⊥ ∧ t = ⊥
Result.exception ::
Duper saturated

Testing || SatisfiesM_Option_eq : ∀ {α : Type u_1} {p : α → Prop} {x : Option α}, SatisfiesM p x ↔ ∀ (a : α), x = some a → p a
Result.exception ::
Duper saturated

Testing || WeierstrassCurve.variableChange_Δ : ∀ {R : Type u} [inst : CommRing R] (W : WeierstrassCurve R) (C : WeierstrassCurve.VariableChange R),
  (W.variableChange C).Δ = ↑C.u⁻¹ ^ 12 * W.Δ
Result.exception ::
Duper saturated

Testing || RelEmbedding.toEmbedding_inj : ∀ {α : Type u_1} {β : Type u_2} {r : α → α → Prop} {s : β → β → Prop} {f g : r ↪r s},
  f.toEmbedding = g.toEmbedding ↔ f = g
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x_0 ↪r x_1 of λ binder contains bound variables

Testing || Fin.rev_bot : ∀ {n : ℕ} [inst : NeZero n], ⊥.rev = ⊤
Result.success

Testing || CategoryTheory.Limits.hasBiproductsOfShape_finite : ∀ {J : Type w} (C : Type uC) [inst : CategoryTheory.Category.{uC', uC} C]
  [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C] [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C]
  [inst_3 : Finite J], CategoryTheory.Limits.HasBiproductsOfShape J C
Result.exception ::
Duper saturated

Testing || Std.DHashMap.Internal.List.getValueCast!_eraseKey_self : ∀ {α : Type u} {β : α → Type v} [inst : BEq α] [inst_1 : LawfulBEq α] {l : List ((a : α) × β a)} {k : α}
  [inst_2 : Inhabited (β k)],
  Std.DHashMap.Internal.List.DistinctKeys l →
    Std.DHashMap.Internal.List.getValueCast! k (Std.DHashMap.Internal.List.eraseKey k l) = default
Result.exception ::
Duper saturated

Testing || tsum_const_smul : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : Monoid γ] [inst_1 : TopologicalSpace α]
  [inst_2 : AddCommMonoid α] [inst_3 : DistribMulAction γ α] [inst_4 : ContinuousConstSMul γ α] {f : β → α}
  [inst_5 : T2Space α] (b : γ), Summable f → ∑' (i : β), b • f i = b • ∑' (i : β), f i
Result.success

Testing || Finset.subset_singleton_iff : ∀ {α : Type u_1} {s : Finset α} {a : α}, s ⊆ {a} ↔ s = ∅ ∨ s = {a}
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #0, (∀ x1 : #0, ((!5 (!9 (!10 x0)) (!9 (!10 x1))) = (!0 x0 x1)))) is not type correct

Testing || PowerSeries.WithPiTopology.continuous_constantCoeff : ∀ (R : Type u_1) [inst : TopologicalSpace R] [inst_1 : Semiring R], Continuous ⇑(PowerSeries.constantCoeff R)
Result.exception ::
Duper saturated

Testing || Submodule.comap_surjective_of_injective : ∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]
  {σ₁₂ : R →+* R₂} {F : Type u_9} [inst_6 : FunLike F M M₂] [inst_7 : SemilinearMapClass F σ₁₂ M M₂]
  [inst_8 : RingHomSurjective σ₁₂] {f : F}, Function.Injective ⇑f → Function.Surjective (Submodule.comap f)
Result.exception ::
Duper saturated

Testing || Ordnode.Valid'.of_lt : ∀ {α : Type u_1} [inst : Preorder α] {t : Ordnode α} {x : α} {o₁ : WithBot α} {o₂ : WithTop α},
  Ordnode.Valid' o₁ t o₂ → Ordnode.nil.Bounded o₁ ↑x → Ordnode.All (fun x_1 => x_1 < x) t → Ordnode.Valid' o₁ t ↑x
Result.exception ::
(deterministic) timeout at `«forward demodulation»`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Heyting.Regular.coe_injective : ∀ {α : Type u_1} [inst : HeytingAlgebra α], Function.Injective Heyting.Regular.val
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Subtype x_0 of λ binder contains bound variables

Testing || CauchySeq.prod : ∀ {α : Type u} {β : Type v} [uniformSpace : UniformSpace α] {γ : Type u_1} [inst : UniformSpace β] [inst_1 : Preorder γ]
  {u : γ → α} {v : γ → β}, CauchySeq u → CauchySeq v → CauchySeq fun x => (u x, v x)
Result.exception ::
Duper saturated

Testing || exists_le_le : ∀ {α : Type u} [inst : LE α] [inst_1 : IsDirected α fun x1 x2 => x1 ≥ x2] (a b : α), ∃ c ≤ a, c ≤ b
Result.success

Testing || List.init_eq_of_concat_eq : ∀ {α : Type u_1} {a b : α} {l₁ l₂ : List α}, l₁.concat a = l₂.concat b → l₁ = l₂
Result.exception ::
Duper saturated

Testing || Fin.ofNat'_sub : ∀ {n : ℕ} [inst : NeZero n] (x : ℕ) (y : Fin n), Fin.ofNat' n x - y = Fin.ofNat' n (n - ↑y + x)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Equiv.Perm.SameCycle.extendDomain : ∀ {α : Type u_2} {β : Type u_3} {g : Equiv.Perm α} {x y : α} {p : β → Prop} [inst : DecidablePred p]
  {f : α ≃ Subtype p}, g.SameCycle x y → (g.extendDomain f).SameCycle ↑(f x) ↑(f y)
Result.success

Testing || CategoryTheory.IsUniversalColimit.of_mapCocone : ∀ {J : Type v'} [inst : CategoryTheory.Category.{u', v'} J] {C : Type u} [inst_1 : CategoryTheory.Category.{v, u} C]
  {D : Type u_2} [inst_2 : CategoryTheory.Category.{u_3, u_2} D] (G : CategoryTheory.Functor C D)
  {F : CategoryTheory.Functor J C} {c : CategoryTheory.Limits.Cocone F}
  [inst_3 : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan G]
  [inst_4 : CategoryTheory.Limits.ReflectsColimitsOfShape J G],
  CategoryTheory.IsUniversalColimit (G.mapCocone c) → CategoryTheory.IsUniversalColimit c
Result.exception ::
Duper saturated

Testing || hasSum_single : ∀ {α : Type u_1} {β : Type u_2} [inst : AddCommMonoid α] [inst_1 : TopologicalSpace α] {f : β → α} (b : β),
  (∀ (b' : β), b' ≠ b → f b' = 0) → HasSum f (f b)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MagmaCat.ofHom_apply : ∀ {X Y : Type u} [inst : Mul X] [inst_1 : Mul Y] (f : X →ₙ* Y) (x : X), (MagmaCat.ofHom f) x = f x
Result.success

Testing || ContMDiffMap.mdifferentiableAt : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners 𝕜 E H} {M : Type u_4}
  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] {E' : Type u_5} [inst_6 : NormedAddCommGroup E']
  [inst_7 : NormedSpace 𝕜 E'] {H' : Type u_6} [inst_8 : TopologicalSpace H'] {I' : ModelWithCorners 𝕜 E' H'}
  {M' : Type u_7} [inst_9 : TopologicalSpace M'] [inst_10 : ChartedSpace H' M'] (f : ContMDiffMap I I' M M' ⊤) {x : M},
  MDifferentiableAt I I' (⇑f) x
Result.exception ::
Duper saturated

Testing || MeasureTheory.levyProkhorovDist_self : ∀ {Ω : Type u_1} [inst : MeasurableSpace Ω] [inst_1 : PseudoEMetricSpace Ω] (μ : MeasureTheory.Measure Ω),
  MeasureTheory.levyProkhorovDist μ μ = 0
Result.exception ::
Duper saturated

Testing || AddHom.fst_comp_prod : ∀ {M : Type u_3} {N : Type u_4} {P : Type u_5} [inst : Add M] [inst_1 : Add N] [inst_2 : Add P] (f : M →ₙ+ N)
  (g : M →ₙ+ P), (AddHom.fst N P).comp (f.prod g) = f
Result.success

Testing || AddMonoidHom.coe_ofClosureMEqTopLeft : ∀ {M : Type u_1} {N : Type u_2} [inst : AddMonoid M] [inst_1 : AddMonoid N] {s : Set M} (f : M → N)
  (hs : AddSubmonoid.closure s = ⊤) (h1 : f 0 = 0) (hmul : ∀ x ∈ s, ∀ (y : M), f (x + y) = f x + f y),
  ⇑(AddMonoidHom.ofClosureMEqTopLeft f hs h1 hmul) = f
Result.exception ::
Duper saturated

Testing || CategoryTheory.ShortComplex.Exact.epi_f : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_3, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  {S : CategoryTheory.ShortComplex C}, S.Exact → S.g = 0 → CategoryTheory.Epi S.f
Result.exception ::
Duper saturated

Testing || AddMonoidHom.inverse.proof_3 : ∀ {A : Type u_1} {B : Type u_2} [inst : AddMonoid A] [inst_1 : AddMonoid B] (f : A →+ B) (g : B → A)
  (h₁ : Function.LeftInverse g ⇑f), ((↑f).inverse g h₁).toFun 0 = 0
Result.success

Testing || Auto.Embedding.Lam.LamEquiv.congr : ∀ {lval : Embedding.Lam.LamValuation} {lctx : ℕ → Embedding.Lam.LamSort} {argTy resTy : Embedding.Lam.LamSort}
  {fn₁ fn₂ arg₁ arg₂ : Embedding.Lam.LamTerm},
  Embedding.Lam.LamEquiv lval lctx (argTy.func resTy) fn₁ fn₂ →
    Embedding.Lam.LamEquiv lval lctx argTy arg₁ arg₂ →
      Embedding.Lam.LamEquiv lval lctx resTy (Embedding.Lam.LamTerm.app argTy fn₁ arg₁)
        (Embedding.Lam.LamTerm.app argTy fn₂ arg₂)
Result.exception ::
Duper saturated

Testing || CategoryTheory.SingleFunctors.shiftIso_add'_inv_app : ∀ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_7, u_1} C]
  [inst_1 : CategoryTheory.Category.{u_6, u_2} D] {A : Type u_5} [inst_2 : AddMonoid A]
  [inst_3 : CategoryTheory.HasShift D A] (F : CategoryTheory.SingleFunctors C D A) (n m mn : A) (hnm : m + n = mn)
  (a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') (X : C),
  (F.shiftIso mn a a'' ⋯).inv.app X =
    CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').inv.app X)
      (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((F.shiftIso m a' a'' ha'').inv.app X))
        ((CategoryTheory.shiftFunctorAdd' D m n mn hnm).inv.app ((F.functor a'').obj X)))
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Duper.rule15bTheorem : ∀ (b : Bool), (!!b) = b
Result.success

Testing || Multiset.card_coe : ∀ {α : Type u_1} [inst : DecidableEq α] (m : Multiset α), Fintype.card m.ToType = m.card
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_1.toEnumFinset`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.pairwise_iff : ∀ {α : Type u} (R : α → α → Prop) (a : List α),
  List.Pairwise R a ↔ a = [] ∨ ∃ a_1 l, (∀ a' ∈ l, R a_1 a') ∧ List.Pairwise R l ∧ a = a_1 :: l
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || AddSubgroup.isOpen_of_isClosed_of_finiteIndex : ∀ {G : Type u} [inst : AddGroup G] [inst_1 : TopologicalSpace G] [inst_2 : ContinuousAdd G] (H : AddSubgroup G)
  [inst_3 : H.FiniteIndex], IsClosed ↑H → IsOpen ↑H
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `QuotientAddGroup.leftRel x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || parallelogram_law_with_norm : ∀ (𝕜 : Type u_1) {E : Type u_2} [inst : RCLike 𝕜] [inst_1 : SeminormedAddCommGroup E] [inst : InnerProductSpace 𝕜 E]
  (x y : E), ‖x + y‖ * ‖x + y‖ + ‖x - y‖ * ‖x - y‖ = 2 * (‖x‖ * ‖x‖ + ‖y‖ * ‖y‖)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `InnerProductSpace.toInner`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MvPolynomial.eval₂_map : ∀ {R : Type u} {S₁ : Type v} {S₂ : Type w} {σ : Type u_1} [inst : CommSemiring R] [inst_1 : CommSemiring S₁]
  [inst_2 : CommSemiring S₂] (f : R →+* S₁) (g : σ → S₂) (φ : S₁ →+* S₂) (p : MvPolynomial σ R),
  MvPolynomial.eval₂ φ g ((MvPolynomial.map f) p) = MvPolynomial.eval₂ (φ.comp f) g p
Result.success

Testing || Set.indicator_le_indicator : ∀ {α : Type u_2} {M : Type u_3} [inst : Preorder M] [inst_1 : _root_.Zero M] {s : Set α} {f g : α → M} {a : α},
  f a ≤ g a → s.indicator f a ≤ s.indicator g a
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!8 (!0 (!1 !2)) (!3 !2)) = (!0 (!1 !2) (!3 !2))) is not type correct

Testing || AddHom.restrict_apply : ∀ {M : Type u_1} {σ : Type u_4} [inst : Add M] {N : Type u_5} [inst_1 : Add N] [inst_2 : SetLike σ M]
  [inst_3 : AddMemClass σ M] (f : M →ₙ+ N) {S : σ} (x : ↥S), (f.restrict S) x = f ↑x
Result.success

Testing || Part.ωSup_eq_none : ∀ {α : Type u_2} {c : OmegaCompletePartialOrder.Chain (Part α)}, (¬∃ a, Part.some a ∈ c) → Part.ωSup c = Part.none
Result.exception ::
Duper saturated

Testing || SimpleGraph.Connected.mono : ∀ {V : Type u} {G G' : SimpleGraph V}, G ≤ G' → G.Connected → G'.Connected
Result.exception ::
Duper saturated

Testing || CochainComplex.mappingCone.lift_snd : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_3, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  {F G : CochainComplex C ℤ} (φ : F ⟶ G) [inst_2 : HomologicalComplex.HasHomotopyCofiber φ] {K : CochainComplex C ℤ}
  (α : CochainComplex.HomComplex.Cocycle K F 1) (β : CochainComplex.HomComplex.Cochain K G 0)
  (eq : CochainComplex.HomComplex.δ 0 1 β + (↑α).comp (CochainComplex.HomComplex.Cochain.ofHom φ) ⋯ = 0),
  (CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.lift φ α β eq)).comp
      (CochainComplex.mappingCone.snd φ) ⋯ =
    β
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CochainComplex.HomComplex.δ.proof_1
  cifvar_23 (cifvar_28 x✝¹)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Submonoid.mem_prod : ∀ {N : Type u_2} [inst : MulOneClass N] {M : Type u_5} [inst_1 : MulOneClass M] {s : Submonoid M} {t : Submonoid N}
  {p : M × N}, p ∈ s.prod t ↔ p.1 ∈ s ∧ p.2 ∈ t
Result.exception ::
Duper saturated

Testing || CategoryTheory.sheafifyMap_sheafifyLift : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] (J : CategoryTheory.GrothendieckTopology C) {D : Type u_1}
  [inst_1 : CategoryTheory.Category.{u_2, u_1} D] [inst_2 : CategoryTheory.HasWeakSheafify J D]
  {P Q R : CategoryTheory.Functor Cᵒᵖ D} (η : P ⟶ Q) (γ : Q ⟶ R) (hR : CategoryTheory.Presheaf.IsSheaf J R),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.sheafifyMap J η) (CategoryTheory.sheafifyLift J γ hR) =
    CategoryTheory.sheafifyLift J (CategoryTheory.CategoryStruct.comp η γ) hR
Result.exception ::
Duper saturated

Testing || UniformOnFun.toFun_zero : ∀ {α : Type u_1} {β : Type u_2} {𝔖 : Set (Set α)} [inst : _root_.Zero β], (UniformOnFun.toFun 𝔖) 0 = 0
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (¬ ((!0 !1 !2) = !2)) is not type correct

Testing || EuclideanGeometry.Sphere.secondInter_smul : ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]
  [inst_3 : NormedAddTorsor V P] (s : EuclideanGeometry.Sphere P) (p : P) (v : V) {r : ℝ},
  r ≠ 0 → s.secondInter p (r • v) = s.secondInter p v
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || disjoint_sdiff_comm : ∀ {α : Type u} {x y z : α} [inst : GeneralizedBooleanAlgebra α], Disjoint (x \ z) y ↔ Disjoint x (y \ z)
Result.success

Testing || compl_add_closure_zero_eq : ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G] {t : Set G},
  t + closure {0} = t → tᶜ + closure {0} = tᶜ
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!7 !15 !9) = !0) is not type correct

Testing || Polynomial.Monic.natDegree_pos_of_not_isUnit : ∀ {R : Type u} [inst : CommSemiring R] {p : Polynomial R}, p.Monic → ¬IsUnit p → 0 < p.natDegree
Result.success

Testing || AddSubgroup.eq_of_le_of_card_ge : ∀ {G : Type u_1} [inst : AddGroup G] {H K : AddSubgroup G} [inst_1 : Finite ↥K],
  H ≤ K → Nat.card ↥K ≤ Nat.card ↥H → H = K
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : (#1 → Prop), ((!12 x0) = (!1 x0))) is not type correct

Testing || WittVector.mulN_coeff : ∀ {p : ℕ} {R : Type u_1} [hp : Fact (Nat.Prime p)] [inst : CommRing R] (n : ℕ) (x : WittVector p R) (k : ℕ),
  (x * ↑n).coeff k = (MvPolynomial.aeval x.coeff) (WittVector.wittMulN p n k)
Result.exception ::
Duper saturated

Testing || isIntegralCurveAt_comp_mul_ne_zero : ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] {H : Type u_2} [inst_2 : TopologicalSpace H]
  {I : ModelWithCorners ℝ E H} {M : Type u_3} [inst_3 : TopologicalSpace M] [inst_4 : ChartedSpace H M] {γ : ℝ → M}
  {v : (x : M) → TangentSpace I x} {t₀ a : ℝ},
  a ≠ 0 → (IsIntegralCurveAt γ v t₀ ↔ IsIntegralCurveAt (γ ∘ fun x => x * a) (a • v) (t₀ / a))
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instAddCommGroupTangentSpace
  cifvar_12`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || DomAddAct.instAddActionSubtypeAEEqFunMemAddAddSubgroupLp.proof_2 : ∀ {α : Type u_1} {E : Type u_2} [inst : MeasurableSpace α] [inst_1 : NormedAddCommGroup E] {μ : MeasureTheory.Measure α}
  {p : ENNReal}, Function.Injective Subtype.val
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Subtype x_0 of λ binder contains bound variables

Testing || AddSubmonoid.le_op_iff : ∀ {M : Type u_2} [inst : AddZeroClass M] {S₁ : AddSubmonoid Mᵃᵒᵖ} {S₂ : AddSubmonoid M}, S₁ ≤ S₂.op ↔ S₁.unop ≤ S₂
Result.exception ::
Duper saturated

Testing || LinOrd.dualEquiv_inverse : LinOrd.dualEquiv.inverse = LinOrd.dual
Result.success

Testing || Complex.nnnorm_real : ∀ (r : ℝ), ‖↑r‖₊ = ‖r‖₊
Result.exception ::
Duper saturated

Testing || Sublattice.mem_sInf : ∀ {α : Type u_2} [inst : Lattice α] {a : α} {S : Set (Sublattice α)}, a ∈ sInf S ↔ ∀ L ∈ S, a ∈ L
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type i ∈ S of λ binder contains bound variables

Testing || CategoryTheory.ChosenFiniteProducts.lift_snd : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.ChosenFiniteProducts C] {T X Y : C}
  (f : T ⟶ X) (g : T ⟶ Y),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.lift f g)
      (CategoryTheory.ChosenFiniteProducts.snd X Y) =
    g
Result.exception ::
Duper saturated

Testing || Cardinal.mk_quotient_le : ∀ {α : Type u} {s : Setoid α}, Cardinal.mk (Quotient s) ≤ Cardinal.mk α
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `⇑s`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || TrivSqZeroExt.snd_exp : ∀ (𝕜 : Type u_1) {R : Type u_3} {M : Type u_4} [inst : Field 𝕜] [inst_1 : CharZero 𝕜] [inst_2 : CommRing R]
  [inst_3 : AddCommGroup M] [inst_4 : Algebra 𝕜 R] [inst_5 : _root_.Module 𝕜 M] [inst_6 : _root_.Module R M]
  [inst_7 : _root_.Module Rᵐᵒᵖ M] [inst_8 : IsCentralScalar R M] [inst_9 : IsScalarTower 𝕜 R M]
  [inst_10 : TopologicalSpace R] [inst_11 : TopologicalSpace M] [inst_12 : TopologicalRing R]
  [inst_13 : TopologicalAddGroup M] [inst_14 : ContinuousSMul R M] [inst_15 : ContinuousSMul Rᵐᵒᵖ M]
  [inst_16 : T2Space R] [inst_17 : T2Space M] (x : TrivSqZeroExt R M),
  (NormedSpace.exp 𝕜 x).snd = NormedSpace.exp 𝕜 x.fst • x.snd
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `TrivSqZeroExt.nonAssocRing`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AlgebraicTopology.DoldKan.Q_f_idem : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  {X : CategoryTheory.SimplicialObject C} (q n : ℕ),
  CategoryTheory.CategoryStruct.comp ((AlgebraicTopology.DoldKan.Q q).f n) ((AlgebraicTopology.DoldKan.Q q).f n) =
    (AlgebraicTopology.DoldKan.Q q).f n
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_9 x_0).f x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Isometry.mapsTo_perpBisector : ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]
  [inst_3 : NormedAddTorsor V P] {V' : Type u_3} {P' : Type u_4} [inst_4 : NormedAddCommGroup V']
  [inst_5 : InnerProductSpace ℝ V'] [inst_6 : MetricSpace P'] [inst_7 : NormedAddTorsor V' P'] {f : P → P'},
  Isometry f →
    ∀ (p₁ p₂ : P), Set.MapsTo f ↑(AffineSubspace.perpBisector p₁ p₂) ↑(AffineSubspace.perpBisector (f p₁) (f p₂))
Result.exception ::
Duper saturated

Testing || CategoryTheory.Discrete.monoidal_leftUnitor : ∀ (M : Type u) [inst : Monoid M] (X : CategoryTheory.Discrete M),
  CategoryTheory.MonoidalCategory.leftUnitor X = CategoryTheory.Discrete.eqToIso ⋯
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀ (p : { as := 1 * X.as } = X),
  CategoryTheory.MonoidalCategory.leftUnitor X =
    CategoryTheory.eqToIso p, type of dependent ∀ bound variable is of sort `Prop`

Testing || contravariant_lt_of_contravariant_le : ∀ (M : Type u_1) (N : Type u_2) (μ : M → N → N) [inst : PartialOrder N],
  (Contravariant M N μ fun x1 x2 => x1 ≤ x2) → Contravariant M N μ fun x1 x2 => x1 < x2
Result.success

Testing || Int.eq_mul_div_of_mul_eq_mul_of_dvd_left : ∀ {a b c d : ℤ}, b ≠ 0 → b ∣ c → b * a = c * d → a = c / b * d
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || pointedToPartialFun_map : ∀ {X Y : Pointed} (f : X ⟶ Y) (a : { x // x ≠ X.point }),
  pointedToPartialFun.map f a = (PFun.toSubtype (fun x => x ≠ Y.point) f.toFun ∘ Subtype.val) a
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: pointedToPartialFun.obj X✝ ⟶ pointedToPartialFun.obj Y✝ is not a `∀`

Testing || MulRingSeminormClass.toRingSeminormClass : ∀ {F : Type u_2} {α : Type u_3} {β : Type u_4} [inst : FunLike F α β] [inst_1 : NonAssocRing α]
  [inst_2 : OrderedSemiring β] [inst_3 : MulRingSeminormClass F α β], RingSeminormClass F α β
Result.exception ::
Duper saturated

Testing || CategoryTheory.ThinSkeleton.map_id_eq : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : Quiver.IsThin C],
  CategoryTheory.ThinSkeleton.map (CategoryTheory.Functor.id C) =
    CategoryTheory.Functor.id (CategoryTheory.ThinSkeleton C)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x✝³ ≈ x✝² of λ binder contains bound variables

Testing || Ordinal.pred_lt_iff_is_succ : ∀ {o : Ordinal.{u_4}}, o.pred < o ↔ ∃ a, o = Order.succ a
Result.exception ::
Duper saturated

Testing || Polynomial.lt_rootMultiplicity_iff_isRoot_iterate_derivative_of_mem_nonZeroDivisors : ∀ {R : Type u} [inst : CommRing R] {p : Polynomial R} {t : R} {n : ℕ},
  p ≠ 0 →
    ↑n.factorial ∈ nonZeroDivisors R →
      (n < Polynomial.rootMultiplicity t p ↔ ∀ m ≤ n, ((⇑Polynomial.derivative)^[m] p).IsRoot t)
Result.success

Testing || List.Vector.mem_iff_get : ∀ {α : Type u_1} {n : ℕ} (a : α) (v : List.Vector α n), a ∈ v.toList ↔ ∃ i, v.get i = a
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Fin x_1.length of λ binder contains bound variables

Testing || Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.mem_lrat_of_mem : ∀ {n : ℕ} {l : Std.Sat.Literal (Std.Tactic.BVDecide.LRAT.Internal.PosFin n)}
  {lratClause : Std.Tactic.BVDecide.LRAT.Internal.DefaultClause n}
  (clause : Std.Sat.CNF.Clause (Std.Tactic.BVDecide.LRAT.Internal.PosFin n)),
  l ∈ clause →
    Std.Tactic.BVDecide.LRAT.Internal.DefaultClause.ofArray (List.toArray clause) = some lratClause →
      l ∈ lratClause.clause
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instDecidableEqBool
  (cifvar_17 (cifvar_12 (cifvar_18 x_1) (cifvar_19 (cifvar_20 x_1))) (cifvar_9 x_0)) cifvar_13`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || HomologicalComplex₂.d_f_comp_d_f : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_4, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  {I₁ : Type u_2} {I₂ : Type u_3} {c₁ : ComplexShape I₁} {c₂ : ComplexShape I₂} (K : HomologicalComplex₂ C c₁ c₂)
  (i₁ i₁' i₁'' : I₁) (i₂ : I₂), CategoryTheory.CategoryStruct.comp ((K.d i₁ i₁').f i₂) ((K.d i₁' i₁'').f i₂) = 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_9 x_0 x_1).f x_2`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || grade_lt_grade_iff : ∀ {𝕆 : Type u_1} {α : Type u_3} [inst : Preorder 𝕆] [inst_1 : LinearOrder α] [inst_2 : GradeOrder 𝕆 α] {a b : α},
  grade 𝕆 a < grade 𝕆 b ↔ a < b
Result.success

Testing || Matrix.vecMulVec_empty : ∀ {α : Type u} {m' : Type uₘ} [inst : NonUnitalNonAssocSemiring α] (v : m' → α) (w : Fin 0 → α),
  Matrix.vecMulVec v w = Matrix.of fun x => ![]
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.join_map_filter : ∀ {α : Type u_1} (p : α → Bool) (l : List (List α)), (List.map (List.filter p) l).flatten = List.filter p l.flatten
Result.success

Testing || Matrix.circulant_add : ∀ {α : Type u_1} {n : Type u_3} [inst : Add α] [inst_1 : Sub n] (v w : n → α),
  Matrix.circulant (v + w) = Matrix.circulant v + Matrix.circulant w
Result.success

Testing || CategoryTheory.CostructuredArrow.map_obj_hom : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {T T' : D} {S : CategoryTheory.Functor C D} (f : T ⟶ T')
  (X : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)),
  ((CategoryTheory.CostructuredArrow.map f).obj X).hom = CategoryTheory.CategoryStruct.comp X.hom f
Result.success

Testing || LinearMap.range_toContinuousLinearMap : ∀ {𝕜 : Type u} [hnorm : NontriviallyNormedField 𝕜] {E : Type v} [inst : AddCommGroup E] [inst_1 : _root_.Module 𝕜 E]
  [inst_2 : TopologicalSpace E] [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul 𝕜 E] {F' : Type x}
  [inst_5 : AddCommGroup F'] [inst_6 : _root_.Module 𝕜 F'] [inst_7 : TopologicalSpace F']
  [inst_8 : TopologicalAddGroup F'] [inst_9 : ContinuousSMul 𝕜 F'] [inst_10 : CompleteSpace 𝕜] [inst_11 : T2Space E]
  [inst_12 : FiniteDimensional 𝕜 E] (f : E →ₗ[𝕜] F'),
  LinearMap.range (LinearMap.toContinuousLinearMap f) = LinearMap.range f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `ContinuousLinearMap.funLike`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || LinearEquiv.isUnit_det : ∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  {M' : Type u_3} [inst_3 : AddCommGroup M'] [inst_4 : _root_.Module R M'] {ι : Type u_4} [inst_5 : DecidableEq ι]
  [inst_6 : Fintype ι] (f : M ≃ₗ[R] M') (v : Basis ι R M) (v' : Basis ι R M'), IsUnit ((LinearMap.toMatrix v v') ↑f).det
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || riemannZeta_eulerProduct_hasProd : ∀ {s : ℂ}, 1 < s.re → HasProd (fun p => (1 - ↑↑p ^ (-s))⁻¹) (riemannZeta s)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || FiniteDimensional.finiteDimensional_subalgebra : ∀ {F : Type u_1} {E : Type u_2} [inst : Field F] [inst_1 : Ring E] [inst_2 : Algebra F E]
  [inst_3 : FiniteDimensional F E] (S : Subalgebra F E), FiniteDimensional F ↥S
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Set.iUnion_vadd_left_image : ∀ {α : Type u_2} {β : Type u_3} [inst : VAdd α β] {s : Set α} {t : Set β}, ⋃ a ∈ s, a +ᵥ t = s +ᵥ t
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a ∈ s of λ binder contains bound variables

Testing || SimpleGraph.edgeSet_ssubset_edgeSet : ∀ {V : Type u} {G₁ G₂ : SimpleGraph V}, G₁.edgeSet ⊂ G₂.edgeSet ↔ G₁ < G₂
Result.success

Testing || isAtomic_iff_isCoatomic : ∀ {α : Type u_2} [inst : Lattice α] [inst_1 : BoundedOrder α] [inst_2 : IsModularLattice α]
  [inst_3 : ComplementedLattice α], IsAtomic α ↔ IsCoatomic α
Result.success

Testing || AlgebraicGeometry.isSurjectiveOnStalks_isLocalAtTarget : AlgebraicGeometry.IsLocalAtTarget
  (AlgebraicGeometry.stalkwise fun {R S} [CommRing R] [CommRing S] x => Function.Surjective ⇑x)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type CommRing R✝ of λ binder contains bound variables

Testing || hasGroupoid_continuousGroupoid : ∀ {H : Type u} {M : Type u_2} [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M],
  HasGroupoid M (continuousGroupoid H)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type IsOpen u✝² of λ binder contains bound variables

Testing || SimpleGraph.Walk.reverse_singleton : ∀ {V : Type u} {G : SimpleGraph V} {u v : V} (h : G.Adj u v),
  (SimpleGraph.Walk.cons h SimpleGraph.Walk.nil).reverse = SimpleGraph.Walk.cons ⋯ SimpleGraph.Walk.nil
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Symmetric G.Adj is not a `∀`

Testing || divp_assoc' : ∀ {α : Type u} [inst : Monoid α] (x y : α) (u : αˣ), x * (y /ₚ u) = x * y /ₚ u
Result.success

Testing || Set.add_iUnion : ∀ {α : Type u_2} {ι : Sort u_5} [inst : Add α] (s : Set α) (t : ι → Set α), s + ⋃ i, t i = ⋃ i, s + t i
Result.success

Testing || PiToModule.fromEnd_apply : ∀ {ι : Type u_1} [inst : Fintype ι] {M : Type u_2} [inst_1 : AddCommGroup M] (R : Type u_3) [inst_2 : CommRing R]
  [inst_3 : _root_.Module R M] (b : ι → M) (f : Module.End R M) (w : ι → R),
  ((PiToModule.fromEnd R b) f) w = f (((Fintype.linearCombination R R) b) w)
Result.success

Testing || ContextFreeGrammar.derives_reverse_comm : ∀ {T : Type uT} {g : ContextFreeGrammar T} {u v : List (Symbol T g.NT)},
  g.reverse.Derives u v ↔ g.Derives u.reverse v.reverse
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || AlgebraicGeometry.Scheme.PartialMap.fromSpecStalkOfMem_compHom : ∀ {X Y Z : AlgebraicGeometry.Scheme} (f : X.PartialMap Y) (g : Y ⟶ Z) (x : ↑↑X.toPresheafedSpace)
  (hx : x ∈ (f.compHom g).domain),
  (f.compHom g).fromSpecStalkOfMem hx = CategoryTheory.CategoryStruct.comp (f.fromSpecStalkOfMem hx) g
Result.exception ::
Duper saturated

Testing || CochainComplex.HomComplex.δ_comp_zero_cocycle : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C]
  {F G K : CochainComplex C ℤ} {n : ℤ} (z₁ : CochainComplex.HomComplex.Cochain F G n)
  (z₂ : CochainComplex.HomComplex.Cocycle G K 0) (m : ℤ),
  CochainComplex.HomComplex.δ n m (z₁.comp ↑z₂ ⋯) = (CochainComplex.HomComplex.δ n m z₁).comp ↑z₂ ⋯
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CochainComplex.HomComplex.δ
  cifvar_13 x_1 (cifvar_5 x_0)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || NumberField.mixedEmbedding.instIsZLatticeRealMixedSpaceIntegerLattice : ∀ (K : Type u_1) [inst : Field K] [inst_1 : NumberField K], IsZLattice ℝ (NumberField.mixedEmbedding.integerLattice K)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || addEquivOfAddOrderOfEq.proof_1 : ∀ {G : Type u_2} {G' : Type u_1} [inst : AddGroup G] [inst_1 : AddGroup G'] {g : G} {g' : G'},
  addOrderOf g = addOrderOf g' → addOrderOf g' ∣ addOrderOf g
Result.success

Testing || kstar_mul_kstar : ∀ {α : Type u_1} [inst : KleeneAlgebra α] (a : α), KStar.kstar a * KStar.kstar a = KStar.kstar a
Result.success

Testing || Real.rpow_eq_zero : ∀ {x y : ℝ}, 0 ≤ x → y ≠ 0 → (x ^ y = 0 ↔ x = 0)
Result.success

Testing || MvPowerSeries.coeff_mul_left_one_sub_of_lt_weightedOrder : ∀ {σ : Type u_1} (w : σ → ℕ) {R : Type u_3} [inst : Ring R] {f g : MvPowerSeries σ R} {d : σ →₀ ℕ},
  ↑((Finsupp.weight w) d) < MvPowerSeries.weightedOrder w g →
    (MvPowerSeries.coeff R d) (f * (1 - g)) = (MvPowerSeries.coeff R d) f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `AddGroup.toSubNegMonoid`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Arrow.w_mk_right_assoc : ∀ {T : Type u} [inst : CategoryTheory.Category.{v, u} T] {f : CategoryTheory.Arrow T} {X Y : T} {g : X ⟶ Y}
  (sq : f ⟶ CategoryTheory.Arrow.mk g) {Z : T} (h : Y ⟶ Z),
  CategoryTheory.CategoryStruct.comp sq.left (CategoryTheory.CategoryStruct.comp g h) =
    CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.CategoryStruct.comp sq.right h)
Result.success

Testing || CommRingCat.isLocalRingHom_comp : ∀ {R S T : CommRingCat} (f : R ⟶ S) (g : S ⟶ T) [inst : IsLocalHom g.hom] [inst : IsLocalHom f.hom],
  IsLocalHom (CategoryTheory.CategoryStruct.comp f g).hom
Result.success

Testing || Nat.eq_of_dvd_of_lt_two_mul : ∀ {a b : ℕ}, a ≠ 0 → b ∣ a → a < 2 * b → a = b
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Finsupp.Lex.single_strictAnti : ∀ {α : Type u_1} [inst : LinearOrder α], StrictAnti fun a => toLex fun₀ | a => 1
Result.exception ::
Duper saturated

Testing || neg_iff_neg_of_mul_pos : ∀ {α : Type u_3} {a b : α} [inst : MulZeroClass α] [inst_1 : LinearOrder α] [inst_2 : PosMulMono α]
  [inst_3 : MulPosMono α], 0 < a * b → (a < 0 ↔ b < 0)
Result.success

Testing || Derivation.coe_neg : ∀ {R : Type u_1} [inst : CommRing R] {A : Type u_2} [inst_1 : CommRing A] [inst_2 : Algebra R A] {M : Type u_3}
  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module A M] [inst_5 : _root_.Module R M] (D : Derivation R A M),
  ⇑(-D) = -⇑D
Result.exception ::
Duper saturated

Testing || Quotient.finChoiceEquiv_symm_apply : ∀ {ι : Type u_1} [inst : Fintype ι] [inst_1 : DecidableEq ι] {α : ι → Sort u_2} {S : (i : ι) → Setoid (α i)}
  (q : Quotient inferInstance) (i : ι), Quotient.finChoiceEquiv.symm q i = q.eval i
Result.exception ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || Filter.add_neBot_iff : ∀ {α : Type u_2} [inst : Add α] {f g : Filter α}, (f + g).NeBot ↔ f.NeBot ∧ g.NeBot
Result.success

Testing || Filter.cocardinal_aleph0_eq_cofinite : ∀ {α : Type u}, Filter.cocardinal α Cardinal.isRegular_aleph0 = Filter.cofinite
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : (#3 → Prop), ((!4 (!5 (!6 (λx1 : #3, (x0 x1)))) !7) = (!8 (!9 (λx1 : #3, (x0 x1)))))) is not type correct

Testing || ContDiffAt.snd : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {G : Type uG}
  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace 𝕜 G] {n : WithTop ℕ∞} {f : E → F × G} {x : E},
  ContDiffAt 𝕜 n f x → ContDiffAt 𝕜 n (fun x => (f x).2) x
Result.success

Testing || stdSimplex_unique : ∀ (𝕜 : Type u_1) (ι : Type u_5) [inst : OrderedSemiring 𝕜] [inst_1 : Fintype ι] [inst_2 : Nonempty ι]
  [inst_3 : Subsingleton ι], stdSimplex 𝕜 ι = {fun x => 1}
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!7 !0 !1) = (!0 !1)) is not type correct

Testing || Matrix.UnitaryGroup.star_mul_self : ∀ {n : Type u} [inst : DecidableEq n] [inst_1 : Fintype n] {α : Type v} [inst_2 : CommRing α] [inst_3 : StarRing α]
  (A : ↥(Matrix.unitaryGroup n α)), star ↑A * ↑A = 1
Result.exception ::
Duper saturated

Testing || List.find?_replicate_of_neg : ∀ {α : Type u_1} {p : α → Bool} {n : ℕ} {a : α}, ¬p a = true → List.find? p (List.replicate n a) = none
Result.success

Testing || covBy_iff_wcovBy_and_ne : ∀ {α : Type u_1} [inst : PartialOrder α] {a b : α}, a ⋖ b ↔ a ⩿ b ∧ a ≠ b
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MeasureTheory.toReal_laverage : ∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {f : α → ENNReal},
  AEMeasurable f μ → (∀ᵐ (x : α) ∂μ, f x ≠ ⊤) → (⨍⁻ (x : α), f x ∂μ).toReal = ⨍ (x : α), (f x).toReal ∂μ
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CofiniteTopology.nhds_eq : ∀ {X : Type u} (x : CofiniteTopology X), nhds x = pure x ⊔ Filter.cofinite
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In α →
  Prop, type of ∀ bound variable is not of sort `Prop`, and depends on bound variables

Testing || ENat.one_lt_card_iff_nontrivial : ∀ (α : Type u_3), 1 < ENat.card α ↔ Nontrivial α
Result.exception ::
Duper saturated

Testing || SetTheory.PGame.lf_of_le_moveLeft : ∀ {x y : SetTheory.PGame} {i : y.LeftMoves}, x ≤ y.moveLeft i → x.LF y
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x_0.RightMoves of λ binder contains bound variables

Testing || Finset.sdiff_empty : ∀ {α : Type u_1} [inst : DecidableEq α] {s : Finset α}, s \ ∅ = s
Result.success

Testing || Vector.continuous_insertIdx' : ∀ {α : Type u_1} [inst : TopologicalSpace α] {n : ℕ} {i : Fin (n + 1)},
  Continuous fun p => List.Vector.insertIdx p.1 i p.2
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Polynomial.nontrivial_iff : ∀ {R : Type u} [inst : Semiring R], Nontrivial (Polynomial R) ↔ Nontrivial R
Result.exception ::
Duper saturated

Testing || AlgebraicGeometry.AffineScheme.Γ_preservesLimits : CategoryTheory.Limits.PreservesLimits AlgebraicGeometry.AffineScheme.Γ.rightOp
Result.exception ::
Duper saturated

Testing || Int.fract_sub_self : ∀ {α : Type u_2} [inst : LinearOrderedRing α] [inst_1 : FloorRing α] (a : α), Int.fract a - a = -↑⌊a⌋
Result.success

Testing || OrderIso.bddBelow_image : ∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] (e : α ≃o β) {s : Set α},
  BddBelow (⇑e '' s) ↔ BddBelow s
Result.exception ::
Duper saturated

Testing || ContinuousMap.comp_id : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (f : C(α, β)),
  f.comp (ContinuousMap.id α) = f
Result.success

Testing || MvPolynomial.join₂_comp_map : ∀ {σ : Type u_1} {R : Type u_3} {S : Type u_4} [inst : CommSemiring R] [inst_1 : CommSemiring S]
  (f : R →+* MvPolynomial σ S), MvPolynomial.join₂.comp (MvPolynomial.map f) = MvPolynomial.bind₂ f
Result.exception ::
Duper saturated

Testing || CircleDeg1Lift.map_sub_int : ∀ (f : CircleDeg1Lift) (x : ℝ) (n : ℤ), f (x - ↑n) = f x - ↑n
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Polynomial.natDegree_hermite : ∀ {n : ℕ}, (Polynomial.hermite n).natDegree = n
Result.success

Testing || Monotone.map_sInf_of_continuousAt : ∀ {α : Type u_1} {β : Type u_2} [inst : CompleteLinearOrder α] [inst_1 : TopologicalSpace α] [inst_2 : OrderTopology α]
  [inst_3 : CompleteLinearOrder β] [inst_4 : TopologicalSpace β] [inst_5 : OrderClosedTopology β] {f : α → β}
  {s : Set α}, ContinuousAt f (sInf s) → Monotone f → f ⊤ = ⊤ → f (sInf s) = sInf (f '' s)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In α →
  Prop, type of ∀ bound variable is not of sort `Prop`, and depends on bound variables

Testing || MemHolder.nnHolderNorm_nsmul : ∀ {X : Type u_1} {Y : Type u_2} [inst : MetricSpace X] [inst_1 : NormedAddCommGroup Y] {r : NNReal} {f : X → Y}
  [inst_2 : _root_.Module ℝ Y] [inst_3 : BoundedSMul ℝ Y] (n : ℕ),
  MemHolder r f → nnHolderNorm r (n • f) = n • nnHolderNorm r f
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Module.toMulActionWithZero`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Int.lt.intro : ∀ {a b : ℤ} {n : ℕ}, a + ↑n.succ = b → a < b
Result.success

Testing || IsOpen.mul_left : ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : Group α] [inst_2 : ContinuousConstSMul α α] {s t : Set α},
  IsOpen t → IsOpen (s * t)
Result.success

Testing || MulAction.IsBlock.empty : ∀ {G : Type u_1} {X : Type u_2} [inst : SMul G X], MulAction.IsBlock G ∅
Result.exception ::
Duper saturated

Testing || MonoidAlgebra.opRingEquiv_single : ∀ {k : Type u₁} {G : Type u₂} [inst : Semiring k] [inst_1 : Monoid G] (r : k) (x : G),
  MonoidAlgebra.opRingEquiv (MulOpposite.op (MonoidAlgebra.single x r)) =
    MonoidAlgebra.single (MulOpposite.op x) (MulOpposite.op r)
Result.exception ::
Duper saturated

Testing || TwoSidedIdeal.mem_ker : ∀ {R : Type u_1} {S : Type u_2} [inst : NonUnitalNonAssocRing R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_3}
  [inst_2 : FunLike F R S] [inst_3 : NonUnitalRingHomClass F R S] (f : F) {x : R}, x ∈ TwoSidedIdeal.ker f ↔ f x = 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Zero.toOfNat0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.GradedObject.ι_mapBifunctorAssociator_inv : ∀ {C₁ : Type u_1} {C₂ : Type u_2} {C₁₂ : Type u_3} {C₂₃ : Type u_4} {C₃ : Type u_5} {C₄ : Type u_6}
  [inst : CategoryTheory.Category.{u_13, u_1} C₁] [inst_1 : CategoryTheory.Category.{u_15, u_2} C₂]
  [inst_2 : CategoryTheory.Category.{u_14, u_5} C₃] [inst_3 : CategoryTheory.Category.{u_11, u_6} C₄]
  [inst_4 : CategoryTheory.Category.{u_17, u_3} C₁₂] [inst_5 : CategoryTheory.Category.{u_12, u_4} C₂₃]
  {F₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)}
  {G : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)}
  {F : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)}
  {G₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)}
  (associator : CategoryTheory.bifunctorComp₁₂ F₁₂ G ≅ CategoryTheory.bifunctorComp₂₃ F G₂₃) {I₁ : Type u_7}
  {I₂ : Type u_8} {I₃ : Type u_9} {J : Type u_10} {r : I₁ × I₂ × I₃ → J}
  (ρ₁₂ : CategoryTheory.GradedObject.BifunctorComp₁₂IndexData r)
  (ρ₂₃ : CategoryTheory.GradedObject.BifunctorComp₂₃IndexData r) (X₁ : CategoryTheory.GradedObject I₁ C₁)
  (X₂ : CategoryTheory.GradedObject I₂ C₂) (X₃ : CategoryTheory.GradedObject I₃ C₃)
  [inst_6 : (((CategoryTheory.GradedObject.mapBifunctor F₁₂ I₁ I₂).obj X₁).obj X₂).HasMap ρ₁₂.p]
  [inst_7 :
    (((CategoryTheory.GradedObject.mapBifunctor G ρ₁₂.I₁₂ I₃).obj
              (CategoryTheory.GradedObject.mapBifunctorMapObj F₁₂ ρ₁₂.p X₁ X₂)).obj
          X₃).HasMap
      ρ₁₂.q]
  [inst_8 : (((CategoryTheory.GradedObject.mapBifunctor G₂₃ I₂ I₃).obj X₂).obj X₃).HasMap ρ₂₃.p]
  [inst_9 :
    (((CategoryTheory.GradedObject.mapBifunctor F I₁ ρ₂₃.I₂₃).obj X₁).obj
          (CategoryTheory.GradedObject.mapBifunctorMapObj G₂₃ ρ₂₃.p X₂ X₃)).HasMap
      ρ₂₃.q]
  [H₁₂ : CategoryTheory.GradedObject.HasGoodTrifunctor₁₂Obj F₁₂ G ρ₁₂ X₁ X₂ X₃]
  [H₂₃ : CategoryTheory.GradedObject.HasGoodTrifunctor₂₃Obj F G₂₃ ρ₂₃ X₁ X₂ X₃] (i₁ : I₁) (i₂ : I₂) (i₃ : I₃) (j : J)
  (h : r (i₁, i₂, i₃) = j),
  CategoryTheory.CategoryStruct.comp
      (CategoryTheory.GradedObject.ιMapBifunctorBifunctor₂₃MapObj F G₂₃ ρ₂₃ X₁ X₂ X₃ i₁ i₂ i₃ j h)
      ((CategoryTheory.GradedObject.mapBifunctorAssociator associator ρ₁₂ ρ₂₃ X₁ X₂ X₃).inv j) =
    CategoryTheory.CategoryStruct.comp (((associator.inv.app (X₁ i₁)).app (X₂ i₂)).app (X₃ i₃))
      (CategoryTheory.GradedObject.ιMapBifunctor₁₂BifunctorMapObj F₁₂ G ρ₁₂ X₁ X₂ X₃ i₁ i₂ i₃ j h)
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.GradedObject (I₁ × I₂) C₁₂ is not a `∀`

Testing || AddSubmonoid.toAddZeroClass.proof_1 : ∀ {M : Type u_1} [inst : AddZeroClass M] (S : AddSubmonoid M), Function.Injective fun a => ↑a
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Subtype x_0 of λ binder contains bound variables

Testing || List.subset_append_of_subset_left : ∀ {α : Type u_1} {l l₁ : List α} (l₂ : List α), l ⊆ l₁ → l ⊆ l₁ ++ l₂
Result.success

Testing || CompHausLike.instHasPropSigma : ∀ {P : TopCat → Prop} [inst : CompHausLike.HasExplicitFiniteCoproducts P] {α : Type u} [inst : Finite α]
  (σ : α → Type u) [inst : (a : α) → TopologicalSpace (σ a)] [inst_1 : ∀ (a : α), CompactSpace (σ a)]
  [inst_2 : ∀ (a : α), T2Space (σ a)] [inst_3 : ∀ (a : α), CompHausLike.HasProp P (σ a)],
  CompHausLike.HasProp P ((a : α) × σ a)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `inst✝³ x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || tsupport_smul_subset_right : ∀ {X : Type u_1} {M : Type u_9} {α : Type u_10} [inst : TopologicalSpace X] [inst_1 : _root_.Zero α]
  [inst_2 : SMulZeroClass M α] (f : X → M) (g : X → α), (tsupport fun x => f x • g x) ⊆ tsupport g
Result.exception ::
Duper saturated

Testing || NONote.NF : ∀ (o : NONote), (↑o).NF
Result.success

Testing || Primrec.cond : ∀ {α : Type u_1} {σ : Type u_3} [inst : Primcodable α] [inst_1 : Primcodable σ] {c : α → Bool} {f g : α → σ},
  Primrec c → Primrec f → Primrec g → Primrec fun a => bif c a then f a else g a
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Submodule.Quotient.equiv_apply : ∀ {R : Type u_1} {M : Type u_2} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M] {N : Type u_5}
  [inst_3 : AddCommGroup N] [inst_4 : _root_.Module R N] (P : Submodule R M) (Q : Submodule R N) (f : M ≃ₗ[R] N)
  (hf : Submodule.map f P = Q) (a : M ⧸ P), (Submodule.Quotient.equiv P Q f hf) a = (P.mapQ Q ↑f ⋯) a
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `a✝.quotientRel`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || BitVec.neg_neg : ∀ {w : ℕ} {x : BitVec w}, - -x = x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `BitVec.instNeg`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.finRange_zero : List.finRange 0 = []
Result.success

Testing || Finset.sups_nonempty : ∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : SemilatticeSup α] {s t : Finset α},
  (s ⊻ t).Nonempty ↔ s.Nonempty ∧ t.Nonempty
Result.success

Testing || Ordnode.Valid.merge : ∀ {α : Type u_1} [inst : Preorder α] {l r : Ordnode α},
  l.Valid → r.Valid → Ordnode.All (fun x => Ordnode.All (fun y => x < y) r) l → (l.merge r).Valid
Result.success

Testing || SzemerediRegularity.increment_isEquipartition : ∀ {α : Type u_1} [inst : Fintype α] [inst_1 : DecidableEq α] {P : Finpartition Finset.univ} (hP : P.IsEquipartition)
  (G : SimpleGraph α) [inst_2 : DecidableRel G.Adj] (ε : ℝ), (SzemerediRegularity.increment hP G ε).IsEquipartition
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #5, (∀ x1 : #4, ((!6 (!13 (!14 x0)) x1) = (!8 x0 x1)))) is not type correct

Testing || ChainComplex.quasiIsoAt₀_iff : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  {K L : ChainComplex C ℕ} (f : K ⟶ L) [inst_2 : HomologicalComplex.HasHomology K 0]
  [inst_3 : HomologicalComplex.HasHomology L 0] [inst_4 : (HomologicalComplex.sc' K 1 0 0).HasHomology]
  [inst_5 : (HomologicalComplex.sc' L 1 0 0).HasHomology],
  QuasiIsoAt f 0 ↔
    CategoryTheory.ShortComplex.QuasiIso ((HomologicalComplex.shortComplexFunctor' C (ComplexShape.down ℕ) 1 0 0).map f)
Result.exception ::
Duper saturated

Testing || Vector.indexOf?_mk : ∀ {α : Type u_1} {n : ℕ} [inst : BEq α] (a : Array α) (h : a.size = n) (x : α),
  { toArray := a, size_toArray := h }.indexOf? x = Option.map (Fin.cast h) (a.indexOf? x)
Result.success

Testing || UpperSet.coe_compl : ∀ {α : Type u_1} [inst : LE α] (s : UpperSet α), ↑s.compl = (↑s)ᶜ
Result.success

Testing || Equiv.Perm.IsCycle.support_pow_eq_iff : ∀ {α : Type u_2} {f : Equiv.Perm α} [inst : DecidableEq α] [inst_1 : Fintype α],
  f.IsCycle → ∀ {n : ℕ}, (f ^ n).support = f.support ↔ ¬orderOf f ∣ n
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || joinM_map_map : ∀ {m : Type u → Type u} [inst : Monad m] [inst_1 : LawfulMonad m] {α β : Type u} (f : α → β) (a : m (m α)),
  joinM (Functor.map f <$> a) = f <$> joinM a
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Filter.ZeroAtFilter.neg : ∀ {α : Type u_2} {β : Type u_3} [inst : TopologicalSpace β] [inst_1 : AddGroup β] [inst_2 : ContinuousNeg β]
  {l : Filter α} {f : α → β}, l.ZeroAtFilter f → l.ZeroAtFilter (-f)
Result.success

Testing || Nimber.add_nat : ∀ (a b : ℕ), Ordinal.toNimber ↑a + Ordinal.toNimber ↑b = Ordinal.toNimber ↑(a ^^^ b)
Result.exception ::
Duper saturated

Testing || Grp.FilteredColimits.forget₂Mon_preservesFilteredColimits : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget₂ Grp MonCat)
Result.exception ::
Duper saturated

Testing || Auto.Embedding.Lam.LamBaseSort.eq_of_beq_eq_true : ∀ {b₁ b₂ : Embedding.Lam.LamBaseSort}, b₁.beq b₂ = true → b₁ = b₂
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || HahnSeries.isWF_support : ∀ {Γ : Type u_1} {R : Type u_3} [inst : PartialOrder Γ] [inst_1 : _root_.Zero R] (x : HahnSeries Γ R), x.support.IsWF
Result.success

Testing || PrimeSpectrum.localization_away_comap_range : ∀ {R : Type u} [inst : CommSemiring R] (S : Type v) [inst_1 : CommSemiring S] [inst_2 : Algebra R S] (r : R)
  [inst_3 : IsLocalization.Away r S], Set.range ⇑(PrimeSpectrum.comap (algebraMap R S)) = ↑(PrimeSpectrum.basicOpen r)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!14 !58 !31) = (!0 (!1 !2))) is not type correct

Testing || AddSubgroup.map.proof_2 : ∀ {G : Type u_2} [inst : AddGroup G] {N : Type u_1} [inst_1 : AddGroup N] (f : G →+ N) (H : AddSubgroup G) {a b : N},
  a ∈ (AddSubmonoid.map f H.toAddSubmonoid).carrier →
    b ∈ (AddSubmonoid.map f H.toAddSubmonoid).carrier → a + b ∈ (AddSubmonoid.map f H.toAddSubmonoid).carrier
Result.success

Testing || Small.trans_univLE : ∀ (α : Type w) [hα : Small.{u, w} α] [h : UnivLE.{u, v}], Small.{v, w} α
Result.exception ::
Duper saturated

Testing || ContinuousMap.addUnitsLift_symm_apply_apply_neg' : ∀ {X : Type u_1} {M : Type u_2} [inst : TopologicalSpace X] [inst_1 : AddMonoid M] [inst_2 : TopologicalSpace M]
  [inst_3 : ContinuousAdd M] (f : AddUnits C(X, M)) (x : X), ↑(-(ContinuousMap.addUnitsLift.symm f) x) = ↑(-f) x
Result.success

Testing || CategoryTheory.ShortComplex.SnakeInput.id_f₁ : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Abelian C]
  (S : CategoryTheory.ShortComplex.SnakeInput C),
  (CategoryTheory.CategoryStruct.id S).f₁ = CategoryTheory.CategoryStruct.id S.L₁
Result.success

Testing || TensorProduct.piScalarRight_apply : ∀ (R : Type u_1) [inst : CommSemiring R] (S : Type u_2) [inst_1 : CommSemiring S] [inst_2 : Algebra R S] (N : Type u_3)
  [inst_3 : AddCommMonoid N] [inst_4 : _root_.Module R N] [inst_5 : _root_.Module S N] [inst_6 : IsScalarTower R S N]
  (ι : Type u_4) [inst_7 : Fintype ι] [inst_8 : DecidableEq ι] (x : TensorProduct R N (ι → R)),
  (TensorProduct.piScalarRight R S N ι) x = (TensorProduct.piScalarRightHom R S N ι) x
Result.exception ::
Duper saturated

Testing || RootPairing.reflection_perm_involutive : ∀ {ι : Type u_1} {R : Type u_2} {M : Type u_3} {N : Type u_4} [inst : CommRing R] [inst_1 : AddCommGroup M]
  [inst_2 : _root_.Module R M] [inst_3 : AddCommGroup N] [inst_4 : _root_.Module R N] (P : RootPairing ι R M N) (i : ι),
  Function.Involutive ⇑(P.reflection_perm i)
Result.success

Testing || Set.instLawfulMonad : LawfulMonad Set
Result.exception ::
Duper saturated

Testing || decide_True' : ∀ (h : Decidable True), decide True = true
Result.success

Testing || LSeries.abscissaOfAbsConv_one : LSeries.abscissaOfAbsConv 1 = 1
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || isLittleO_pow_pow_of_lt_left : ∀ {r₁ r₂ : ℝ}, 0 ≤ r₁ → r₁ < r₂ → (fun n => r₁ ^ n) =o[Filter.atTop] fun n => r₂ ^ n
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Ordinal.iSup_lt_lift : ∀ {ι : Type u} {f : ι → Cardinal.{max u v}} {c : Cardinal.{max u v}},
  Cardinal.lift.{v, u} (Cardinal.mk ι) < c.ord.cof → (∀ (i : ι), f i < c) → iSup f < c
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || SeparationQuotient.inducing_mk : ∀ {X : Type u_1} [inst : TopologicalSpace X], Topology.IsInducing SeparationQuotient.mk
Result.success

Testing || div_two_sub_self : ∀ {α : Type u_2} [inst : LinearOrderedField α] (a : α), a / 2 - a = -(a / 2)
Result.success

Testing || aestronglyMeasurable_lineDeriv_uncurry : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : LocallyCompactSpace 𝕜] {E : Type u_2}
  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace 𝕜 E] [inst_4 : MeasurableSpace E]
  [inst_5 : OpensMeasurableSpace E] {F : Type u_3} [inst_6 : NormedAddCommGroup F] [inst_7 : NormedSpace 𝕜 F]
  [inst_8 : CompleteSpace F] {f : E → F} [inst_9 : SecondCountableTopology E],
  Continuous f →
    ∀ (μ : MeasureTheory.Measure (E × E)), MeasureTheory.AEStronglyMeasurable (fun p => lineDeriv 𝕜 f p.1 p.2) μ
Result.success

Testing || Int.Prime.dvd_pow' : ∀ {n : ℤ} {k p : ℕ}, Nat.Prime p → ↑p ∣ n ^ k → ↑p ∣ n
Result.success

Testing || Filter.blimsup_not_sup : ∀ {α : Type u_1} {β : Type u_2} [inst : CompleteDistribLattice α] {f : Filter β} {p : β → Prop} {u : β → α},
  (Filter.blimsup u f fun x => ¬p x) ⊔ Filter.blimsup u f p = Filter.limsup u f
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Coheyting.boundary_inf_le : ∀ {α : Type u_1} [inst : CoheytingAlgebra α] {a b : α},
  Coheyting.boundary (a ⊓ b) ≤ Coheyting.boundary a ⊔ Coheyting.boundary b
Result.success

Testing || CategoryTheory.IsFiltered.coeq₃_condition₁ : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.IsFilteredOrEmpty C] {j₁ j₂ : C}
  (f g h : j₁ ⟶ j₂),
  CategoryTheory.CategoryStruct.comp f (CategoryTheory.IsFiltered.coeq₃Hom f g h) =
    CategoryTheory.CategoryStruct.comp g (CategoryTheory.IsFiltered.coeq₃Hom f g h)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.IsFiltered.coeqHom
  x_0 x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || disjoint_compl_right : ∀ {α : Type u_2} [inst : HeytingAlgebra α] {a : α}, Disjoint a aᶜ
Result.success

Testing || Heyting.Regular.coe_sdiff : ∀ {α : Type u_1} [inst : HeytingAlgebra α] (a b : Heyting.Regular α), ↑(a \ b) = ↑a ⊓ (↑b)ᶜ
Result.success

Testing || CompHausLike.LocallyConstantModule.functorToPresheaves_obj_obj_isAddCommGroup : ∀ {P : TopCat → Prop} (R : Type (max u w)) [inst : Ring R] (X : ModuleCat R) (x : (CompHausLike P)ᵒᵖ),
  (((CompHausLike.LocallyConstantModule.functorToPresheaves R).obj X).obj x).isAddCommGroup =
    LocallyConstant.instAddCommGroup
Result.exception ::
Auto.Reif.resolveTy :: Unable to resolve AddCommGroup
  ↑(((CompHausLike.LocallyConstantModule.functorToPresheaves R).obj X).obj x✝)

Testing || Polynomial.Chebyshev.aeval_U : ∀ {R : Type u_1} {R' : Type u_2} [inst : CommRing R] [inst_1 : CommRing R'] [inst_2 : Algebra R R'] (x : R') (n : ℤ),
  (Polynomial.aeval x) (Polynomial.Chebyshev.U R n) = Polynomial.eval x (Polynomial.Chebyshev.U R' n)
Result.success

Testing || lipschitzExtensionConstant_def : ∀ (E' : Type u_1) [inst : NormedAddCommGroup E'] [inst_1 : NormedSpace ℝ E'] [inst_2 : FiniteDimensional ℝ E'],
  lipschitzExtensionConstant E' =
    let A := (Basis.ofVectorSpace ℝ E').equivFun.toContinuousLinearEquiv;
    ‖↑A.symm‖₊ * ‖↑A‖₊ ⊔ 1
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #9, (∀ x1 : #9, ((!21 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || SubMulAction.coe_copy : ∀ {R : Type u} {M : Type v} [inst : SMul R M] (p : SubMulAction R M) (s : Set M) (hs : s = ↑p), ↑(p.copy s hs) = s
Result.success

Testing || Cardinal.mul_eq_max' : ∀ {a b : Cardinal.{u_1}}, Cardinal.aleph0 ≤ a * b → a * b = a ⊔ b
Result.exception ::
Duper saturated

Testing || AlgHom.val_comp_codRestrict : ∀ {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]
  [inst_3 : Semiring B] [inst_4 : Algebra R B] (f : A →ₐ[R] B) (S : Subalgebra R B) (hf : ∀ (x : A), f x ∈ S),
  S.val.comp (f.codRestrict S hf) = f
Result.success

Testing || CStarRing.norm_one : ∀ {E : Type u_2} [inst : NormedRing E] [inst_1 : StarRing E] [inst_2 : CStarRing E] [inst_3 : Nontrivial E], ‖1‖ = 1
Result.success

Testing || Cardinal.mk_ne_zero_iff : ∀ {α : Type u}, Cardinal.mk α ≠ 0 ↔ Nonempty α
Result.exception ::
Duper saturated

Testing || Fin.Ioi_zero_eq_map : ∀ {n : ℕ}, Finset.Ioi 0 = Finset.map (Fin.succEmb n) Finset.univ
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Fin.succ`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || exists_mem_frontier_infDist_compl_eq_dist : ∀ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : FiniteDimensional ℝ E] {x : E}
  {s : Set E}, x ∈ s → s ≠ Set.univ → ∃ y ∈ frontier s, Metric.infDist x sᶜ = dist x y
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `PseudoMetricSpace.toUniformSpace`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Filter.Tendsto.max : ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : LinearOrder α] [inst_2 : OrderClosedTopology α]
  {f g : β → α} {b : Filter β} {a₁ a₂ : α},
  Filter.Tendsto f b (nhds a₁) → Filter.Tendsto g b (nhds a₂) → Filter.Tendsto (fun b => f b ⊔ g b) b (nhds (a₁ ⊔ a₂))
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `nhds x`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.Pi.forall_rel_cons_ext : ∀ {ι : Type u_1} [inst : DecidableEq ι] {α : ι → Sort u_2} {i : ι} {l : List ι} {r : ⦃i : ι⦄ → α i → α i → Prop}
  {a₁ a₂ : α i} {f₁ f₂ : (j : ι) → j ∈ l → α j},
  r a₁ a₂ →
    (∀ (i : ι) (hi : i ∈ l), r (f₁ i hi) (f₂ i hi)) →
      ∀ (j : ι) (hj : j ∈ i :: l), r (List.Pi.cons i l a₁ f₁ j hj) (List.Pi.cons i l a₂ f₂ j hj)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀ (a : j ∈ i ::ₘ ↑l),
  List.Pi.cons i l f b j a = Multiset.Pi.cons (↑l) i f b j a, type of dependent ∀ bound variable is of sort `Prop`

Testing || WithBot.toDual_lt_toDual_iff : ∀ {α : Type u_1} [inst : LT α] {a b : WithBot α}, WithBot.toDual a < WithBot.toDual b ↔ b < a
Result.success

Testing || Nat.Partrec.Code.fixed_point : ∀ {f : Nat.Partrec.Code → Nat.Partrec.Code}, Computable f → ∃ c, (f c).eval = c.eval
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: ℕ →. ℕ is not a `∀`

Testing || IsAddQuantale.add_bot : ∀ {α : Type u_3} [inst : AddSemigroup α] [inst_1 : CompleteLattice α] [inst_2 : IsAddQuantale α] {x : α}, x + ⊥ = ⊥
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type y ∈ x_1 of λ binder contains bound variables

Testing || CategoryTheory.Equivalence.pi_functor : ∀ {I : Type w₀} {C : I → Type u₁} [inst : (i : I) → CategoryTheory.Category.{v₁, u₁} (C i)] {D : I → Type u₂}
  [inst_1 : (i : I) → CategoryTheory.Category.{v₂, u₂} (D i)] (E : (i : I) → C i ≌ D i),
  (CategoryTheory.Equivalence.pi E).functor = CategoryTheory.Functor.pi fun i => (E i).functor
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `inst✝¹ i`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Matroid.Matroidᵣ.coe_inj : ∀ {α : Type u_1} {M₁ M₂ : Matroid.Matroidᵣ α}, M₁.toMatroid = M₂.toMatroid ↔ M₁ = M₂
Result.success

Testing || CategoryTheory.ShortComplex.LeftHomologyData.f'_i_assoc : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  {S : CategoryTheory.ShortComplex C} (h : S.LeftHomologyData) {Z : C} (h_1 : S.X₂ ⟶ Z),
  CategoryTheory.CategoryStruct.comp h.f' (CategoryTheory.CategoryStruct.comp h.i h_1) =
    CategoryTheory.CategoryStruct.comp S.f h_1
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.f`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AddSubgroup.isComplement'_comm : ∀ {G : Type u_1} [inst : AddGroup G] {H K : AddSubgroup G}, H.IsComplement' K ↔ K.IsComplement' H
Result.success

Testing || Equiv.mul_swap_involutive : ∀ {α : Type u} [inst : DecidableEq α] (i j : α), Function.Involutive fun x => x * Equiv.swap i j
Result.exception ::
Duper saturated

Testing || AddMonoid.not_isTorsion_iff : ∀ (G : Type u_1) [inst : AddMonoid G], ¬AddMonoid.IsTorsion G ↔ ∃ g, ¬IsOfFinAddOrder g
Result.success

Testing || Set.mem_iInter_of_mem : ∀ {α : Type u_1} {ι : Sort u_5} {s : ι → Set α} {a : α}, (∀ (i : ι), a ∈ s i) → a ∈ ⋂ i, s i
Result.success

Testing || FirstOrder.Language.LHom.id_onTerm : ∀ {L : FirstOrder.Language} {α : Type u'}, (FirstOrder.Language.LHom.id L).onTerm = id
Result.exception ::
Duper saturated

Testing || Mod_.hom_ext : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] {A : Mon_ C}
  {M N : Mod_ A} (f₁ f₂ : M ⟶ N), f₁.hom = f₂.hom → f₁ = f₂
Result.success

Testing || Matrix.permanent_zero : ∀ {n : Type u_1} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type u_2} [inst_2 : CommSemiring R]
  [inst_3 : Nonempty n], Matrix.permanent 0 = 0
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix n n R is not a `∀`

Testing || Ideal.radical_eq_iff : ∀ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, I.radical = I ↔ I.IsRadical
Result.success

Testing || NonemptyInterval.coe_pure : ∀ {α : Type u_1} [inst : PartialOrder α] (a : α), ↑(NonemptyInterval.pure a) = {a}
Result.exception ::
Duper saturated

Testing || exists_Ioo_extr_on_Icc : ∀ {X : Type u_1} {Y : Type u_2} [inst : ConditionallyCompleteLinearOrder X] [inst_1 : DenselyOrdered X]
  [inst_2 : TopologicalSpace X] [inst_3 : OrderTopology X] [inst_4 : LinearOrder Y] [inst_5 : TopologicalSpace Y]
  [inst_6 : OrderTopology Y] {f : X → Y} {a b : X},
  a < b → ContinuousOn f (Set.Icc a b) → f a = f b → ∃ c ∈ Set.Ioo a b, IsExtrOn f (Set.Icc a b) c
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!12 (λx0 : #0, ((!9 (!10 !4 !5) x0) ∧ (!11 !7 (!8 !4 !5) x0)))) = (∃ x0 : #0, ((!9 (!10 !4 !5) x0) ∧ (!11 !7 (!8 !4 !5) x0)))) is not type correct

Testing || PrimeSpectrum.comap_basicOpen : ∀ {R : Type u} {S : Type v} [inst : CommSemiring R] [inst_1 : CommSemiring S] (f : R →+* S) (x : R),
  (TopologicalSpace.Opens.comap (PrimeSpectrum.comap f)) (PrimeSpectrum.basicOpen x) = PrimeSpectrum.basicOpen (f x)
Result.success

Testing || CategoryTheory.HasExactLimitsOfShape.of_codomain_equivalence : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (J : Type u_1) [inst_1 : CategoryTheory.Category.{u_3, u_1} J]
  {D : Type u_2} [inst_2 : CategoryTheory.Category.{u_4, u_2} D] (e : C ≌ D)
  [inst_3 : CategoryTheory.Limits.HasLimitsOfShape J C] [inst_4 : CategoryTheory.HasExactLimitsOfShape J C],
  CategoryTheory.HasExactLimitsOfShape J D
Result.exception ::
Duper saturated

Testing || IsCyclotomicExtension.Rat.absdiscr_prime : ∀ (p : ℕ+) (K : Type u) [inst : Field K] [hp : Fact (Nat.Prime ↑p)] [inst_1 : CharZero K]
  [inst_2 : IsCyclotomicExtension {p} ℚ K], NumberField.discr K = (-1) ^ ((↑p - 1) / 2) * ↑↑p ^ (↑p - 2)
Result.exception ::
Duper saturated

Testing || span_gramSchmidt_Iio : ∀ (𝕜 : Type u_1) {E : Type u_2} [inst : RCLike 𝕜] [inst_1 : NormedAddCommGroup E] [inst_2 : InnerProductSpace 𝕜 E]
  {ι : Type u_3} [inst_3 : LinearOrder ι] [inst_4 : LocallyFiniteOrderBot ι] [inst_5 : WellFoundedLT ι] (f : ι → E)
  (c : ι), Submodule.span 𝕜 (gramSchmidt 𝕜 f '' Set.Iio c) = Submodule.span 𝕜 (f '' Set.Iio c)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Set.Iic x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Equiv.continuous_symm_iff : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (e : X ≃ Y),
  Continuous ⇑e.symm ↔ IsOpenMap ⇑e
Result.exception ::
Duper saturated

Testing || SimpleGraph.instInhabited_default : ∀ (V : Type u), default = ⊥
Result.success

Testing || Nat.exists_not_and_succ_of_not_zero_of_exists : ∀ {p : ℕ → Prop}, ¬p 0 → (∃ n, p n) → ∃ n, ¬p n ∧ p (n + 1)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ConvexOn.le_left_of_right_le' : ∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_5} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]
  [inst_2 : LinearOrderedCancelAddCommMonoid β] [inst_3 : SMul 𝕜 E] [inst_4 : _root_.Module 𝕜 β]
  [inst_5 : OrderedSMul 𝕜 β] {s : Set E} {f : E → β},
  ConvexOn 𝕜 s f →
    ∀ {x y : E},
      x ∈ s → y ∈ s → ∀ {a b : 𝕜}, 0 < a → 0 ≤ b → a + b = 1 → f y ≤ f (a • x + b • y) → f (a • x + b • y) ≤ f x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Preorder.toLT`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || NormedAddGroupHom.Equalizer.ι_comp_lift : ∀ {V : Type u_1} {W : Type u_2} {V₁ : Type u_3} [inst : SeminormedAddCommGroup V] [inst_1 : SeminormedAddCommGroup W]
  [inst_2 : SeminormedAddCommGroup V₁] {f g : NormedAddGroupHom V W} (φ : NormedAddGroupHom V₁ V)
  (h : f.comp φ = g.comp φ), (NormedAddGroupHom.Equalizer.ι f g).comp (NormedAddGroupHom.Equalizer.lift φ h) = φ
Result.success

Testing || CategoryTheory.Limits.MultispanIndex.multicoforkEquivSigmaCofork_functor : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (I : CategoryTheory.Limits.MultispanIndex C)
  [inst_1 : CategoryTheory.Limits.HasCoproduct I.left] [inst_2 : CategoryTheory.Limits.HasCoproduct I.right],
  I.multicoforkEquivSigmaCofork.functor = I.toSigmaCoforkFunctor
Result.success

Testing || CategoryTheory.Limits.instEpiFactorThruImageOfHasLimitWalkingParallelPairParallelPair : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C} (f : X ⟶ Y)
  [inst_1 : CategoryTheory.Limits.HasImage f]
  [inst_2 :
    ∀ {Z : C} (g h : CategoryTheory.Limits.image f ⟶ Z),
      CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair g h)],
  CategoryTheory.Epi (CategoryTheory.Limits.factorThruImage f)
Result.exception ::
Duper saturated

Testing || Submonoid.unop_closure : ∀ {M : Type u_2} [inst : MulOneClass M] (s : Set Mᵐᵒᵖ),
  (Submonoid.closure s).unop = Submonoid.closure (MulOpposite.op ⁻¹' s)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Pi.ringHom_apply : ∀ {I : Type u} {f : I → Type v} {γ : Type w} [inst : (i : I) → NonAssocSemiring (f i)] [inst_1 : NonAssocSemiring γ]
  (g : (i : I) → γ →+* f i) (x : γ) (b : I), (Pi.ringHom g) x b = (g b) x
Result.exception ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || ProbabilityTheory.Kernel.indepSet_zero_right : ∀ {α : Type u_1} {Ω : Type u_2} {_mα : MeasurableSpace α} {_mΩ : MeasurableSpace Ω} {κ : ProbabilityTheory.Kernel α Ω}
  {s t : Set Ω}, ProbabilityTheory.Kernel.IndepSet s t κ 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `MeasurableSpace.generateFrom
  (cifvar_8 x_0)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || InnerProductSpace.Core.sqrt_normSq_eq_norm : ∀ {𝕜 : Type u_1} {F : Type u_3} [inst : RCLike 𝕜] [inst_1 : AddCommGroup F] [inst_2 : _root_.Module 𝕜 F]
  [c : PreInnerProductSpace.Core 𝕜 F] (x : F), √(InnerProductSpace.Core.normSq x) = ‖x‖
Result.success

Testing || Cardinal.natCast_le_toENat_iff : ∀ {n : ℕ} {c : Cardinal.{u_3}}, ↑n ≤ Cardinal.toENat c ↔ ↑n ≤ c
Result.exception ::
Duper saturated

Testing || AddSubsemigroup.mem_comap : ∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] {S : AddSubsemigroup N} {f : M →ₙ+ N} {x : M},
  x ∈ AddSubsemigroup.comap f S ↔ f x ∈ S
Result.success

Testing || Equiv.prodAssoc_symm_apply : ∀ (α : Type u_9) (β : Type u_10) (γ : Type u_11) (p : α × β × γ), (Equiv.prodAssoc α β γ).symm p = ((p.1, p.2.1), p.2.2)
Result.success

Testing || Prop.exists_iff : ∀ {p : Prop → Prop}, (∃ h, p h) ↔ p False ∨ p True
Result.success

Testing || AntitoneOn.map_bddAbove : ∀ {α : Type u} {β : Type v} [inst : Preorder α] [inst_1 : Preorder β] {f : α → β} {s t : Set α},
  AntitoneOn f t → s ⊆ t → (upperBounds s ∩ t).Nonempty → BddBelow (f '' s)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In α →
  Prop, type of ∀ bound variable is not of sort `Prop`, and depends on bound variables

Testing || add_sSup_distrib : ∀ {α : Type u_1} {x : α} {s : Set α} [inst : AddSemigroup α] [inst_1 : CompleteLattice α] [inst_2 : IsAddQuantale α],
  x + sSup s = ⨆ y ∈ s, x + y
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type y ∈ s of λ binder contains bound variables

Testing || AddChar.sum_apply_eq_ite : ∀ {α : Type u_1} [inst : AddCommGroup α] [inst_1 : Fintype α] [inst_2 : DecidableEq α] (a : α),
  ∑ ψ : AddChar α ℂ, ψ a = if a = 0 then ↑(Fintype.card α) else 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finite.of_fintype cifvar_28`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || DualNumber.exp_smul_eps : ∀ (𝕜 : Type u_1) {R : Type u_2} [inst : Field 𝕜] [inst_1 : CharZero 𝕜] [inst_2 : CommRing R] [inst_3 : Algebra 𝕜 R]
  [inst_4 : UniformSpace R] [inst_5 : TopologicalRing R] [inst_6 : T2Space R] (r : R),
  NormedSpace.exp 𝕜 (r • DualNumber.eps) = 1 + r • DualNumber.eps
Result.exception ::
Duper saturated

Testing || QuaternionAlgebra.Basis.liftHom_apply : ∀ {R : Type u_1} {A : Type u_2} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A] {c₁ c₂ : R}
  (q : QuaternionAlgebra.Basis A c₁ c₂) (a : QuaternionAlgebra R c₁ c₂), q.liftHom a = q.lift a
Result.success

Testing || EReal.induction₂ : ∀ {P : EReal → EReal → Prop},
  P ⊤ ⊤ →
    (∀ (x : ℝ), 0 < x → P ⊤ ↑x) →
      P ⊤ 0 →
        (∀ x < 0, P ⊤ ↑x) →
          P ⊤ ⊥ →
            (∀ (x : ℝ), 0 < x → P ↑x ⊤) →
              (∀ (x : ℝ), 0 < x → P ↑x ⊥) →
                P 0 ⊤ →
                  (∀ (x y : ℝ), P ↑x ↑y) →
                    P 0 ⊥ →
                      (∀ x < 0, P ↑x ⊤) →
                        (∀ x < 0, P ↑x ⊥) →
                          P ⊥ ⊤ →
                            (∀ (x : ℝ), 0 < x → P ⊥ ↑x) → P ⊥ 0 → (∀ x < 0, P ⊥ ↑x) → P ⊥ ⊥ → ∀ (x y : EReal), P x y
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || intervalIntegral.deriv_integral_right : ∀ {E : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E] [inst_2 : CompleteSpace E] {f : ℝ → E}
  {a b : ℝ},
  IntervalIntegrable f MeasureTheory.volume a b →
    StronglyMeasurableAtFilter f (nhds b) MeasureTheory.volume →
      ContinuousAt f b → deriv (fun u => ∫ (x : ℝ) in a..u, f x) b = f b
Result.success

Testing || Finset.compls_subset_compls : ∀ {α : Type u_2} [inst : BooleanAlgebra α] {s₁ s₂ : Finset α}, s₁.compls ⊆ s₂.compls ↔ s₁ ⊆ s₂
Result.success

Testing || Sbtw.oangle_eq_right : ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]
  [inst_3 : NormedAddTorsor V P] [hd2 : Fact (Module.finrank ℝ V = 2)] [inst_4 : Module.Oriented ℝ V (Fin 2)]
  {p₁ p₂ p₃ p₃' : P}, Sbtw ℝ p₂ p₃ p₃' → EuclideanGeometry.oangle p₁ p₂ p₃ = EuclideanGeometry.oangle p₁ p₂ p₃'
Result.success

Testing || CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian_i : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Abelian C]
  (S : CategoryTheory.ShortComplex C),
  (CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian S).i = CategoryTheory.Limits.kernel.ι S.g
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.g`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || UV.disjoint_of_mem_compression_of_not_mem : ∀ {α : Type u_1} [inst : GeneralizedBooleanAlgebra α] [inst_1 : DecidableRel Disjoint]
  [inst_2 : DecidableRel fun x1 x2 => x1 ≤ x2] {s : Finset α} {u v a : α} [inst_3 : DecidableEq α],
  a ∈ UV.compression u v s → a ∉ s → Disjoint v a
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.StructuredArrow.post_obj : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {B : Type u₄} [inst_2 : CategoryTheory.Category.{v₄, u₄} B] (S : C) (F : CategoryTheory.Functor B C)
  (G : CategoryTheory.Functor C D) (X : CategoryTheory.StructuredArrow S F),
  (CategoryTheory.StructuredArrow.post S F G).obj X = CategoryTheory.StructuredArrow.mk (G.map X.hom)
Result.success

Testing || Equiv.Perm.VectorsProdEqOne.rotate_zero : ∀ {G : Type u_2} [inst : Group G] {n : ℕ} (v : ↑(Equiv.Perm.vectorsProdEqOne G n)),
  Equiv.Perm.VectorsProdEqOne.rotate v 0 = v
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #1, (∀ x1 : #1, ((!2 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || TrivSqZeroExt.instTopologicalRingOfTopologicalAddGroupOfContinuousSMulMulOpposite : ∀ {R : Type u_3} {M : Type u_4} [inst : TopologicalSpace R] [inst_1 : TopologicalSpace M] [inst_2 : Ring R]
  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module Rᵐᵒᵖ M] [inst_6 : TopologicalRing R]
  [inst_7 : TopologicalAddGroup M] [inst_8 : ContinuousSMul R M] [inst_9 : ContinuousSMul Rᵐᵒᵖ M],
  TopologicalRing (TrivSqZeroExt R M)
Result.exception ::
failed to synthesize
  SMul (TrivSqZeroExt R M) M
(deterministic) timeout at `typeclass`, maximum number of heartbeats (20000) has been reached
Use `set_option synthInstance.maxHeartbeats <num>` to set the limit.
Additional diagnostic information may be available using the `set_option diagnostics true` command.
Additional diagnostic information may be available using the `set_option diagnostics true` command.

Testing || LipschitzWith.dist_right : ∀ {α : Type u} [inst : PseudoMetricSpace α] (x : α), LipschitzWith 1 (dist x)
Result.success

Testing || Set.Finite.powerset : ∀ {α : Type u} {s : Set α}, s.Finite → (𝒫 s).Finite
Result.success

Testing || contDiff_iff_forall_nat_le : ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}
  {n : ℕ∞}, ContDiff 𝕜 (↑n) f ↔ ∀ (m : ℕ), ↑m ≤ n → ContDiff 𝕜 (↑m) f
Result.success

Testing || CategoryTheory.Limits.compReflectsLimitsOfShape : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {J : Type w} [inst_2 : CategoryTheory.Category.{w', w} J] {E : Type u₃} [ℰ : CategoryTheory.Category.{v₃, u₃} E]
  (F : CategoryTheory.Functor C D) (G : CategoryTheory.Functor D E)
  [inst_3 : CategoryTheory.Limits.ReflectsLimitsOfShape J F] [inst_4 : CategoryTheory.Limits.ReflectsLimitsOfShape J G],
  CategoryTheory.Limits.ReflectsLimitsOfShape J (F.comp G)
Result.success

Testing || SimpleGraph.IsNClique.insert : ∀ {α : Type u_1} {G : SimpleGraph α} {n : ℕ} {s : Finset α} {a : α} [inst : DecidableEq α],
  G.IsNClique n s → (∀ b ∈ s, G.Adj a b) → G.IsNClique (n + 1) (insert a s)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!12 (!0 !1 !2) !3) = (!0 !1 !2 !3)) is not type correct

Testing || DilationEquiv.ratio_zpow : ∀ {X : Type u_1} [inst : PseudoEMetricSpace X] (e : X ≃ᵈ X) (n : ℤ), Dilation.ratio (e ^ n) = Dilation.ratio e ^ n
Result.exception ::
Duper saturated

Testing || instIsSuccArchimedeanMultiplicative : ∀ {X : Type u_1} [inst : Preorder X] [inst_1 : SuccOrder X] [h : IsSuccArchimedean X],
  IsSuccArchimedean (Multiplicative X)
Result.success

Testing || Stream'.WSeq.liftRel_append : ∀ {α : Type u} {β : Type v} (R : α → β → Prop) {s1 s2 : Stream'.WSeq α} {t1 t2 : Stream'.WSeq β},
  Stream'.WSeq.LiftRel R s1 t1 → Stream'.WSeq.LiftRel R s2 t2 → Stream'.WSeq.LiftRel R (s1.append s2) (t1.append t2)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || TopologicalSpace.isTopologicalBasis_of_subbasis_of_inter : ∀ {α : Type u} [t : TopologicalSpace α] {r : Set (Set α)},
  t = TopologicalSpace.generateFrom r →
    (∀ ⦃s : Set α⦄, s ∈ r → ∀ ⦃t : Set α⦄, t ∈ r → s ∩ t ∈ r) → TopologicalSpace.IsTopologicalBasis (insert Set.univ r)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `TopologicalSpace.generateFrom x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || LieSubmodule.le_normalizer : ∀ {R : Type u_1} {L : Type u_2} {M : Type u_3} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : LieAlgebra R L]
  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : LieRingModule L M] [inst_6 : LieModule R L M]
  (N : LieSubmodule R L M), N ≤ N.normalizer
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.exists_of_mem_keys : ∀ {α : Type u} {β : α → Type v} {a : α} {l : List (Sigma β)}, a ∈ l.keys → ∃ b, ⟨a, b⟩ ∈ l
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || AlgebraicTopology.DoldKan.Compatibility.equivalenceUnitIso_eq : ∀ {A : Type u_1} {A' : Type u_2} {B : Type u_3} {B' : Type u_4} [inst : CategoryTheory.Category.{u_6, u_1} A]
  [inst_1 : CategoryTheory.Category.{u_5, u_2} A'] [inst_2 : CategoryTheory.Category.{u_8, u_3} B]
  [inst_3 : CategoryTheory.Category.{u_7, u_4} B'] {eA : A ≌ A'} {eB : B ≌ B'} {e' : A' ≌ B'}
  {F : CategoryTheory.Functor A B'} {hF : eA.functor.comp e'.functor ≅ F} {G : CategoryTheory.Functor B A}
  {hG : eB.functor.comp e'.inverse ≅ G.comp eA.functor} {ε : eA.functor ≅ F.comp e'.inverse},
  AlgebraicTopology.DoldKan.Compatibility.υ hF = ε →
    (AlgebraicTopology.DoldKan.Compatibility.equivalence hF hG).unitIso =
      AlgebraicTopology.DoldKan.Compatibility.equivalenceUnitIso hG ε
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || AffineEquiv.pointReflection_apply : ∀ (k : Type u_1) {P₁ : Type u_2} {V₁ : Type u_6} [inst : Ring k] [inst_1 : AddCommGroup V₁]
  [inst_2 : _root_.Module k V₁] [inst_3 : AddTorsor V₁ P₁] (x y : P₁),
  (AffineEquiv.pointReflection k x) y = (x -ᵥ y) +ᵥ x
Result.success

Testing || RCLike.nonpos_iff_exists_ofReal : ∀ {K : Type u_1} [inst : RCLike K] {z : K}, z ≤ 0 ↔ ∃ x ≤ 0, ↑x = z
Result.success

Testing || generateFrom_iUnion : ∀ {α : Type u} {ι : Sort v} {f : ι → Set (Set α)},
  TopologicalSpace.generateFrom (⋃ i, f i) = ⨅ i, TopologicalSpace.generateFrom (f i)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `TopologicalSpace.generateFrom
  (cifvar_4 i)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Adjunction.counit_epi_of_R_faithful : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {L : CategoryTheory.Functor C D} {R : CategoryTheory.Functor D C} (h : L ⊣ R) [inst_2 : R.Faithful] (X : D),
  CategoryTheory.Epi (h.counit.app X)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_9 x_2).map`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || ContinuousSup.measurableSup₂ : ∀ {γ : Type u_3} [inst : TopologicalSpace γ] {mγ : MeasurableSpace γ} [inst_1 : BorelSpace γ]
  [inst_2 : SecondCountableTopology γ] [inst_3 : Max γ] [inst : ContinuousSup γ], MeasurableSup₂ γ
Result.exception ::
Duper saturated

Testing || BoxIntegral.TaggedPrepartition.unionComplToSubordinate_boxes : ∀ {ι : Type u_1} [inst : Fintype ι] {I : BoxIntegral.Box ι} (π₁ : BoxIntegral.TaggedPrepartition I)
  (π₂ : BoxIntegral.Prepartition I) (hU : π₂.iUnion = ↑I \ π₁.iUnion) (r : (ι → ℝ) → ↑(Set.Ioi 0)),
  (π₁.unionComplToSubordinate π₂ hU r).boxes = π₁.boxes ∪ (π₂.toSubordinate r).boxes
Result.success

Testing || CategoryTheory.MonoidalCategory.whiskerLeft_inv_hom'_assoc : ∀ {C : Type u} [𝒞 : CategoryTheory.Category.{v, u} C] [inst : CategoryTheory.MonoidalCategory C] (X : C) {Y Z : C}
  (f : Y ⟶ Z) [inst_1 : CategoryTheory.IsIso f] {Z_1 : C} (h : CategoryTheory.MonoidalCategory.tensorObj X Z ⟶ Z_1),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.whiskerLeft X (CategoryTheory.inv f))
      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.whiskerLeft X f) h) =
    h
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.MonoidalCategory.whiskerLeft
  x_0 (cifvar_7 x_1 x_2)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || SpectrumRestricts.nnreal_iff_spectralRadius_le : ∀ {A : Type u_3} [inst : Ring A] [inst_1 : Algebra ℝ A] {a : A} {t : NNReal},
  spectralRadius ℝ a ≤ ↑t →
    (SpectrumRestricts a ⇑ContinuousMap.realToNNReal ↔ spectralRadius ℝ ((algebraMap ℝ A) ↑t - a) ≤ ↑t)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type i ∈ spectrum ℝ a of λ binder contains bound variables

Testing || Real.sin_nat_mul_pi_sub : ∀ (x : ℝ) (n : ℕ), Real.sin (↑n * Real.pi - x) = -((-1) ^ n * Real.sin x)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #0, (∀ x1 : #0, ((!33 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || IsNonarchimedean.multiset_image_add : ∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} [inst : AddCommGroup α] [inst_1 : FunLike F α ℝ]
  [inst_2 : AddGroupSeminormClass F α ℝ] [inst_3 : Nonempty β] {f : F},
  IsNonarchimedean ⇑f → ∀ (g : β → α) (s : Multiset β), ∃ b, (s ≠ 0 → b ∈ s) ∧ f (Multiset.map g s).sum ≤ f (g b)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `SeminormedAddCommGroup.toNorm`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || DirectSum.of_eq_of_gradedMonoid_eq : ∀ {ι : Type u_1} [inst : DecidableEq ι] {A : ι → Type u_2} [inst_1 : (i : ι) → AddCommMonoid (A i)] {i j : ι} {a : A i}
  {b : A j}, GradedMonoid.mk i a = GradedMonoid.mk j b → (DirectSum.of A i) a = (DirectSum.of A j) b
Result.success

Testing || IsMinOn.of_isLocalMinOn_of_convexOn : ∀ {E : Type u_1} {β : Type u_2} [inst : AddCommGroup E] [inst_1 : TopologicalSpace E] [inst_2 : _root_.Module ℝ E]
  [inst_3 : TopologicalAddGroup E] [inst_4 : ContinuousSMul ℝ E] [inst_5 : OrderedAddCommGroup β]
  [inst_6 : _root_.Module ℝ β] [inst_7 : OrderedSMul ℝ β] {s : Set E} {f : E → β} {a : E},
  a ∈ s → IsLocalMinOn f s a → ConvexOn ℝ s f → IsMinOn f s a
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!21 !22 !23) = !0) is not type correct

Testing || List.map₂Right'_nil_right : ∀ {α : Type u} {β : Type v} {γ : Type w} (f : Option α → β → γ) (as : List α), List.map₂Right' f as [] = ([], as)
Result.success

Testing || Set.mulIndicator_one_preimage : ∀ {α : Type u_1} {M : Type u_3} [inst : _root_.One M] {t : Set α} (s : Set M), t.mulIndicator 1 ⁻¹' s ∈ {Set.univ, ∅}
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #1, (∀ x1 : #1, ((!0 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || strictAntiOn_of_add_one_lt : ∀ {α : Type u_2} {β : Type u_3} [inst : PartialOrder α] [inst_1 : Preorder β] [inst_2 : Add α] [inst_3 : _root_.One α]
  [inst_4 : SuccAddOrder α] [inst_5 : IsSuccArchimedean α] {s : Set α} {f : α → β},
  s.OrdConnected → (∀ (a : α), ¬IsMax a → a ∈ s → a + 1 ∈ s → f (a + 1) < f a) → StrictAntiOn f s
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!14 !15 !16) = !0) is not type correct

Testing || orderOf_eq_prime : ∀ {G : Type u_1} [inst : Monoid G] {x : G} {p : ℕ} [hp : Fact (Nat.Prime p)], x ^ p = 1 → x ≠ 1 → orderOf x = p
Result.success

Testing || Polynomial.leadingCoeff_det_X_one_add_C : ∀ {n : Type u_1} {α : Type u_2} [inst : DecidableEq n] [inst_1 : Fintype n] [inst_2 : CommRing α] (A : Matrix n n α),
  (Polynomial.X • 1 + A.map ⇑Polynomial.C).det.leadingCoeff = 1
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (¬ ((!0 (!1 !2 (!3 (!4 !5 !6) (!7 !8 (!9 !10))))) = !11)) is not type correct

Testing || Quaternion.normSq_coe : ∀ {R : Type u_3} [inst : CommRing R] (x : R), Quaternion.normSq ↑x = x ^ 2
Result.success

Testing || Ideal.comap_comap : ∀ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : Semiring S] {T : Type u_3} [inst_2 : Semiring T] {I : Ideal T}
  (f : R →+* S) (g : S →+* T), Ideal.comap f (Ideal.comap g I) = Ideal.comap (g.comp f) I
Result.success

Testing || MulHom.srange_top_of_surjective : ∀ {M : Type u_1} [inst : Mul M] {N : Type u_5} [inst_1 : Mul N] (f : M →ₙ* N), Function.Surjective ⇑f → f.srange = ⊤
Result.success

Testing || ContinuousLinearMap.proj_apply : ∀ {R : Type u_1} [inst : Semiring R] {ι : Type u_4} {φ : ι → Type u_5} [inst_1 : (i : ι) → TopologicalSpace (φ i)]
  [inst_2 : (i : ι) → AddCommMonoid (φ i)] [inst_3 : (i : ι) → _root_.Module R (φ i)] (i : ι) (b : (i : ι) → φ i),
  (ContinuousLinearMap.proj i) b = b i
Result.success

Testing || Order.Ioo_succ_right : ∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : SuccOrder α] [inst_2 : NoMaxOrder α] (a b : α),
  Set.Ioo a (Order.succ b) = Set.Ioc a b
Result.success

Testing || Sym2.GameAdd.fix_eq : ∀ {α : Type u_1} {rα : α → α → Prop} {C : α → α → Sort u_3} (hr : WellFounded rα)
  (IH : (a₁ b₁ : α) → ((a₂ b₂ : α) → Sym2.GameAdd rα s(a₂, b₂) s(a₁, b₁) → C a₂ b₂) → C a₁ b₁) (a b : α),
  Sym2.GameAdd.fix hr IH a b = IH a b fun a' b' x => Sym2.GameAdd.fix hr IH a' b'
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Sym2.GameAdd rα (Quot.mk (Sym2.Rel α) (a', b'))
  (Quot.mk (Sym2.Rel α) (a, b)) of λ binder contains bound variables

Testing || UniqueSums.of_same : ∀ {G : Type u_1} [inst : AddSemigroup G] [inst_1 : IsCancelAdd G],
  (∀ {A : Finset G}, A.Nonempty → ∃ a1 ∈ A, ∃ a2 ∈ A, UniqueAdd A A a1 a2) → UniqueSums G
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.add`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || FreeAbelianGroup.add_bind : ∀ {α β : Type u} (f : α → FreeAbelianGroup β) (x y : FreeAbelianGroup α), x + y >>= f = (x >>= f) + (y >>= f)
Result.success

Testing || CategoryTheory.ChosenFiniteProducts.leftUnitor_inv_snd_assoc : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.ChosenFiniteProducts C] (X : C)
  {Z : C} (h : X ⟶ Z),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).inv
      (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (𝟙_ C) X) h) =
    h
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ENNReal.log_strictMono : StrictMono ENNReal.log
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `BoundedOrder.toOrderBot`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || OrderMonoidHom.copy_eq : ∀ {α : Type u_2} {β : Type u_3} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : MulOneClass α]
  [inst_3 : MulOneClass β] (f : α →*o β) (f' : α → β) (h : f' = ⇑f), f.copy f' h = f
Result.exception ::
Duper saturated

Testing || LowerSemicontinuous.add' : ∀ {α : Type u_1} [inst : TopologicalSpace α] {γ : Type u_4} [inst_1 : LinearOrderedAddCommMonoid γ]
  [inst_2 : TopologicalSpace γ] [inst_3 : OrderTopology γ] {f g : α → γ},
  LowerSemicontinuous f →
    LowerSemicontinuous g →
      (∀ (x : α), ContinuousAt (fun p => p.1 + p.2) (f x, g x)) → LowerSemicontinuous fun z => f z + g z
Result.exception ::
Duper saturated

Testing || Vector.continuous_insertNth : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {n : ℕ} {i : Fin (n + 1)}
  {f : β → α} {g : β → List.Vector α n},
  Continuous f → Continuous g → Continuous fun b => List.Vector.insertIdx (f b) i (g b)
Result.success

Testing || RatFunc.algebraMap_apply_div : ∀ {F : Type u} [inst : Field F] (p q : Polynomial F),
  (algebraMap (RatFunc F) (LaurentSeries F))
      ((algebraMap (Polynomial F) (RatFunc F)) p / (algebraMap (Polynomial F) (RatFunc F)) q) =
    (algebraMap (Polynomial F) (LaurentSeries F)) p / (algebraMap (Polynomial F) (LaurentSeries F)) q
Result.exception ::
Duper saturated

Testing || CategoryTheory.braiding_inv_apply : ∀ {X Y : Type u} {x : X} {y : Y}, (β_ X Y).inv (y, x) = (x, y)
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.MonoidalCategory.tensorObj Y X ⟶
  CategoryTheory.MonoidalCategory.tensorObj X Y is not a `∀`

Testing || instOrderedSubPrimeMultiset : OrderedSub PrimeMultiset
Result.exception ::
Duper saturated

Testing || IntermediateField.map_le_iff_le_comap : ∀ {K : Type u_1} {L : Type u_2} {L' : Type u_3} [inst : Field K] [inst_1 : Field L] [inst_2 : Field L']
  [inst_3 : Algebra K L] [inst_4 : Algebra K L'] {f : L →ₐ[K] L'} {s : IntermediateField K L}
  {t : IntermediateField K L'}, IntermediateField.map f s ≤ t ↔ s ≤ IntermediateField.comap f t
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Functor.mapTriangle_map_hom₁ : ∀ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_4, u_1} C]
  [inst_1 : CategoryTheory.Category.{u_5, u_2} D] [inst_2 : CategoryTheory.HasShift C ℤ]
  [inst_3 : CategoryTheory.HasShift D ℤ] (F : CategoryTheory.Functor C D) [inst_4 : F.CommShift ℤ]
  {X Y : CategoryTheory.Pretriangulated.Triangle C} (f : X ⟶ Y), (F.mapTriangle.map f).hom₁ = F.map f.hom₁
Result.success

Testing || ZNum.cmp_to_int : ∀ (m n : ZNum), Ordering.casesOn (m.cmp n) (↑m < ↑n) (m = n) (↑n < ↑m)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `AddGroup.toSubtractionMonoid`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || isLocalHomeomorphOn_iff_isOpenEmbedding_restrict : ∀ {X : Type u_1} {Y : Type u_2} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] (s : Set X) {f : X → Y},
  IsLocalHomeomorphOn f s ↔ ∀ x ∈ s, ∃ U ∈ nhds x, Topology.IsOpenEmbedding (U.restrict f)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instTopologicalSpaceSubtype`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Commute.invOf_left : ∀ {α : Type u} [inst : Monoid α] {a b : α} [inst_1 : Invertible b], Commute b a → Commute (⅟b) a
Result.success

Testing || Rat.canLift : CanLift ℚ ℤ Int.cast fun q => q.den = 1
Result.exception ::
Duper saturated

Testing || Subring.mem_pointwise_smul_iff_inv_smul_mem : ∀ {M : Type u_1} {R : Type u_2} [inst : Group M] [inst_1 : Ring R] [inst_2 : MulSemiringAction M R] {a : M}
  {S : Subring R} {x : R}, x ∈ a • S ↔ a⁻¹ • x ∈ S
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `MulAction.toSMul`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AddSubgroup.card_dvd_of_surjective : ∀ {G : Type u_1} {G' : Type u_2} [inst : AddGroup G] [inst_1 : AddGroup G'] (f : G →+ G'),
  Function.Surjective ⇑f → Nat.card G' ∣ Nat.card G
Result.exception ::
Duper saturated

Testing || Subalgebra.topologicalClosure_minimal : ∀ {R : Type u_1} [inst : CommSemiring R] {A : Type u} [inst_1 : TopologicalSpace A] [inst_2 : Semiring A]
  [inst_3 : Algebra R A] [inst_4 : TopologicalSemiring A] (s : Subalgebra R A) {t : Subalgebra R A},
  s ≤ t → IsClosed ↑t → s.topologicalClosure ≤ t
Result.success

Testing || Valuation.isEquiv_iff_val_eq_one : ∀ {K : Type u_1} [inst : DivisionRing K] {Γ₀ : Type u_4} {Γ'₀ : Type u_5} [inst_1 : LinearOrderedCommGroupWithZero Γ₀]
  [inst_2 : LinearOrderedCommGroupWithZero Γ'₀] {v : Valuation K Γ₀} {v' : Valuation K Γ'₀},
  v.IsEquiv v' ↔ ∀ {x : K}, v x = 1 ↔ v' x = 1
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WeierstrassCurve.ofJ0_c₄ : ∀ (R : Type u_1) [inst : CommRing R], (WeierstrassCurve.ofJ0 R).c₄ = 0
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Limits.id_preservesColimitsOfSize : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C],
  CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v₁, v₁, u₁, u₁} (CategoryTheory.Functor.id C)
Result.exception ::
Duper saturated

Testing || Finsupp.sumFinsuppAddEquivProdFinsupp_apply : ∀ {M : Type u_5} [inst : AddMonoid M] {α : Type u_13} {β : Type u_14} (f : α ⊕ β →₀ M),
  Finsupp.sumFinsuppAddEquivProdFinsupp f = (Finsupp.comapDomain Sum.inl f ⋯, Finsupp.comapDomain Sum.inr f ⋯)
Result.success

Testing || WithBot.unbot_coe : ∀ {α : Type u_1} (x : α) (h : optParam (↑x ≠ ⊥) ⋯), (↑x).unbot h = x
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀ (a : ↑x ≠ ⊥),
  x = (↑x).unbot a, type of dependent ∀ bound variable is of sort `Prop`

Testing || Normal.minpoly_eq_iff_mem_orbit : ∀ {F : Type u_1} [inst : Field F] (E : Type u_6) [inst_1 : Field E] [inst_2 : Algebra F E] [h : Normal F E] {x y : E},
  minpoly F x = minpoly F y ↔ x ∈ MulAction.orbit (E ≃ₐ[F] E) y
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #1, (∀ x1 : #1, ((!4 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || HahnSeries.SummableFamily.ext : ∀ {Γ : Type u_1} {R : Type u_3} {α : Type u_5} [inst : PartialOrder Γ] [inst_1 : AddCommMonoid R]
  {s t : HahnSeries.SummableFamily Γ R α}, (∀ (a : α), s a = t a) → s = t
Result.success

Testing || Bool.cond_pos : ∀ {α : Type u_1} {b : Bool} {a a' : α}, b = true → (bif b then a else a') = a
Result.success

Testing || AddUnits.neg_add_eq_iff_eq_add : ∀ {α : Type u} [inst : AddMonoid α] (a : AddUnits α) {b c : α}, ↑(-a) + b = c ↔ b = ↑a + c
Result.success

Testing || Polynomial.isRoot_cyclotomic_iff : ∀ {R : Type u_1} [inst : CommRing R] {n : ℕ} [inst_1 : IsDomain R] [inst_2 : NeZero ↑n] {μ : R},
  (Polynomial.cyclotomic n R).IsRoot μ ↔ IsPrimitiveRoot μ n
Result.exception ::
Duper saturated

Testing || SimplexCategory.Truncated.instFullInclusion : ∀ (n : ℕ), (SimplexCategory.Truncated.inclusion n).Full
Result.success

Testing || Ordinal.nfp_le_fp : ∀ {f : Ordinal.{u_1} → Ordinal.{u_1}}, Monotone f → ∀ {a b : Ordinal.{u_1}}, a ≤ b → f b ≤ b → Ordinal.nfp f a ≤ b
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || List.length_eraseP_add_one : ∀ {α : Type u} {p : α → Bool} {l : List α} {a : α}, a ∈ l → p a = true → (List.eraseP p l).length + 1 = l.length
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || BitVec.eq_sub_iff_add_eq : ∀ {w : ℕ} {x y z : BitVec w}, x = z - y ↔ x + y = z
Result.success

Testing || EuclideanGeometry.collinear_of_angle_eq_zero : ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]
  [inst_3 : NormedAddTorsor V P] {p₁ p₂ p₃ : P}, EuclideanGeometry.angle p₁ p₂ p₃ = 0 → Collinear ℝ {p₁, p₂, p₃}
Result.success

Testing || MeasureTheory.Measure.instNeZeroOfNonempty : ∀ {X : Type u_1} [inst : TopologicalSpace X] {m : MeasurableSpace X} (μ : MeasureTheory.Measure X)
  [inst : μ.IsOpenPosMeasure] [inst : Nonempty X], NeZero μ
Result.exception ::
Duper saturated

Testing || AddAction.IsFixedBlock.univ : ∀ {G : Type u_1} [inst : AddGroup G] {X : Type u_2} [inst_1 : AddAction G X], AddAction.IsFixedBlock G Set.univ
Result.exception ::
Duper saturated

Testing || FreeGroup.invRev_involutive : ∀ {α : Type u}, Function.Involutive FreeGroup.invRev
Result.exception ::
Duper saturated

Testing || CategoryTheory.Adjunction.unit_rightAdjointUniq_hom_app_assoc : ∀ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_3, u_1} C]
  [inst_1 : CategoryTheory.Category.{u_4, u_2} D] {F : CategoryTheory.Functor C D} {G G' : CategoryTheory.Functor D C}
  (adj1 : F ⊣ G) (adj2 : F ⊣ G') (x : C) {Z : C} (h : G'.obj (F.obj x) ⟶ Z),
  CategoryTheory.CategoryStruct.comp (adj1.unit.app x)
      (CategoryTheory.CategoryStruct.comp ((adj1.rightAdjointUniq adj2).hom.app (F.obj x)) h) =
    CategoryTheory.CategoryStruct.comp (adj2.unit.app x) h
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.CategoryStruct.id
  x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Nat.Primes.coe_nat_injective : Function.Injective fun a => ↑a
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Subtype x_0 of λ binder contains bound variables

Testing || Affine.Simplex.circumcenter_eq_affineCombination_of_pointsWithCircumcenter : ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]
  [inst_3 : NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n),
  s.circumcenter =
    (Finset.affineCombination ℝ Finset.univ s.pointsWithCircumcenter)
      (Affine.Simplex.circumcenterWeightsWithCircumcenter n)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || covBy_iff_lt_covBy_grade : ∀ {𝕆 : Type u_1} {α : Type u_3} [inst : Preorder 𝕆] [inst_1 : Preorder α] [inst_2 : GradeOrder 𝕆 α] {a b : α},
  a ⋖ b ↔ a < b ∧ grade 𝕆 a ⋖ grade 𝕆 b
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `grade cifvar_11 x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.range'_subset_right_1 : ∀ {s m n : ℕ}, List.range' s m ⊆ List.range' s n ↔ m ≤ n
Result.exception ::
Duper saturated

Testing || AffineSubspace.SSameSide.trans : ∀ {R : Type u_1} {V : Type u_2} {P : Type u_4} [inst : LinearOrderedField R] [inst_1 : AddCommGroup V]
  [inst_2 : _root_.Module R V] [inst_3 : AddTorsor V P] {s : AffineSubspace R P} {x y z : P},
  s.SSameSide x y → s.SSameSide y z → s.SSameSide x z
Result.exception ::
Duper saturated

Testing || Finset.dens_lt_dens : ∀ {α : Type u_2} [inst : Fintype α] {s t : Finset α}, s ⊂ t → s.dens < t.dens
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `GroupWithZero.toDivInvMonoid`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Submonoid.closure_eq_of_le : ∀ {M : Type u_1} [inst : MulOneClass M] {s : Set M} {S : Submonoid M},
  s ⊆ ↑S → S ≤ Submonoid.closure s → Submonoid.closure s = S
Result.success

Testing || SetLike.prod_mem_graded : ∀ {ι : Type u_2} {R : Type u_3} {S : Type u_4} [inst : SetLike S R] [inst_1 : CommMonoid R] [inst_2 : AddCommMonoid ι]
  (A : ι → S) [inst_3 : SetLike.GradedMonoid A] {κ : Type u_5} (i : κ → ι) (g : κ → R) {F : Finset κ},
  (∀ k ∈ F, g k ∈ A (i k)) → ∏ k ∈ F, g k ∈ A (∑ k ∈ F, i k)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.instInsert`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Pi.mulSupport_mulSingle_one : ∀ {A : Type u_1} {B : Type u_2} [inst : DecidableEq A] [inst_1 : _root_.One B] {a : A},
  Function.mulSupport (Pi.mulSingle a 1) = ∅
Result.exception ::
Duper saturated

Testing || CategoryTheory.SemiadditiveOfBinaryBiproducts.add_eq_right_addition : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  [inst_2 : CategoryTheory.Limits.HasBinaryBiproducts C] {X Y : C} (f g : X ⟶ Y),
  f + g =
    CategoryTheory.CategoryStruct.comp
      (CategoryTheory.Limits.biprod.lift (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X))
      (CategoryTheory.Limits.biprod.desc f g)
Result.success

Testing || RCLike.nonneg_iff : ∀ {K : Type u_1} [inst : RCLike K] {z : K}, 0 ≤ z ↔ 0 ≤ RCLike.re z ∧ RCLike.im z = 0
Result.success

Testing || Finset.sup'_mono : ∀ {α : Type u_2} {β : Type u_3} [inst : SemilatticeSup α] (f : β → α) {s₁ s₂ : Finset β} (h : s₁ ⊆ s₂)
  (h₁ : s₁.Nonempty), s₁.sup' h₁ f ≤ s₂.sup' ⋯ f
Result.exception ::
Duper saturated

Testing || WithBot.zero_ne_bot : ∀ {α : Type u} [inst : _root_.Zero α], 0 ≠ ⊥
Result.success

Testing || IsCyclotomicExtension.discr_prime_pow_eq_unit_mul_pow : ∀ {p : ℕ+} {k : ℕ} {K : Type u} {L : Type v} {ζ : L} [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L]
  [inst_3 : IsCyclotomicExtension {p ^ k} K L] [hp : Fact (Nat.Prime ↑p)] (hζ : IsPrimitiveRoot ζ ↑(p ^ k)),
  Irreducible (Polynomial.cyclotomic (↑(p ^ k)) K) →
    ∃ u n, Algebra.discr K ⇑(IsPrimitiveRoot.powerBasis K hζ).basis = ↑↑u * ↑↑p ^ n
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `HasDistribNeg.toInvolutiveNeg`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || TopHom.comp_apply : ∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} [inst : Top α] [inst_1 : Top β] [inst_2 : Top γ] (f : TopHom β γ)
  (g : TopHom α β) (a : α), (f.comp g) a = f (g a)
Result.success

Testing || Basis.finTwoProd_zero : ∀ (R : Type u_7) [inst : Semiring R], (Basis.finTwoProd R) 0 = (1, 0)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Set.piecewise_neg : ∀ {I : Type u} {f : I → Type v} [inst : (i : I) → Neg (f i)] (s : Set I) [inst_1 : (i : I) → Decidable (i ∈ s)]
  (f₁ g₁ : (i : I) → f i), s.piecewise (-f₁) (-g₁) = -s.piecewise f₁ g₁
Result.exception ::
Duper saturated

Testing || CategoryTheory.Adjunction.toEquivalence_inverse : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor D C} (adj : F ⊣ G)
  [inst_2 : ∀ (X : C), CategoryTheory.IsIso (adj.unit.app X)]
  [inst_3 : ∀ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)], adj.toEquivalence.inverse = G
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_7 cifvar_8).app x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Units.val_inv_ofPowEqOne : ∀ {M : Type u_1} [inst : Monoid M] (a : M) (n : ℕ) (ha : a ^ n = 1) (hn : n ≠ 0),
  ↑(Units.ofPowEqOne a n ha hn)⁻¹ = a ^ (n - 1)
Result.success

Testing || EMetric.diam_closedBall : ∀ {α : Type u_1} {x : α} [inst : PseudoEMetricSpace α] {r : ENNReal}, EMetric.diam (EMetric.closedBall x r) ≤ 2 * r
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `EMetric.diam x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || minpoly.coeff_zero_eq_zero : ∀ {A : Type u_1} {B : Type u_2} [inst : Field A] [inst_1 : Ring B] [inst_2 : IsDomain B] [inst_3 : Algebra A B] {x : B},
  IsIntegral A x → ((minpoly A x).coeff 0 = 0 ↔ x = 0)
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Set.bijOn_iInter : ∀ {α : Type u_1} {β : Type u_2} {ι : Sort u_5} [hi : Nonempty ι] {s : ι → Set α} {t : ι → Set β} {f : α → β},
  (∀ (i : ι), Set.BijOn f (s i) (t i)) → Set.InjOn f (⋃ i, s i) → Set.BijOn f (⋂ i, s i) (⋂ i, t i)
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!12 (!5 (λx0 : #0, (!2 x0))) (λx0 : #1, (∀ x1 : #1, ((!22 (!5 (λx2 : #0, (!2 x2))) x1) → (((!1 x0) = (!1 x1)) → (x0 = x1)))))) = (!4 !1 (!5 (λx0 : #0, (!2 x0))))) is not type correct

Testing || Module.End.HasUnifEigenvalue.lt : ∀ {R : Type v} {M : Type w} [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  {f : Module.End R M} {μ : R} {k m : ℕ∞}, 0 < m → f.HasUnifEigenvalue μ k → f.HasUnifEigenvalue μ m
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `LinearMap.instFunLike`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Comonad.ComonadicityInternal.main_pair_F_cosplit : ∀ {C : Type u₁} {D : Type u₂} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.Category.{v₁, u₂} D]
  {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor D C} (adj : F ⊣ G) (A : adj.toComonad.Coalgebra),
  F.IsCosplitPair (G.map A.a) (adj.unit.app (G.obj A.A))
Result.exception ::
Duper saturated

Testing || AddSubgroup.map_eq_bot_iff : ∀ {G : Type u_1} [inst : AddGroup G] {N : Type u_5} [inst_1 : AddGroup N] (H : AddSubgroup G) {f : G →+ N},
  AddSubgroup.map f H = ⊥ ↔ H ≤ f.ker
Result.exception ::
Duper saturated

Testing || CategoryTheory.hasExactColimitsOfShape_discrete_of_hasExactColimitsOfShape_finset_discrete : ∀ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  [inst_2 : CategoryTheory.Limits.HasFiniteBiproducts C] [inst_3 : CategoryTheory.Limits.HasFiniteLimits C]
  (J : Type u_1) [inst_4 : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete J) C]
  [inst_5 : CategoryTheory.Limits.HasColimitsOfShape (Finset (CategoryTheory.Discrete J)) C]
  [inst_6 : CategoryTheory.HasExactColimitsOfShape (Finset (CategoryTheory.Discrete J)) C],
  CategoryTheory.HasExactColimitsOfShape (CategoryTheory.Discrete J) C
Result.exception ::
Duper saturated

Testing || NumberField.mixedEmbedding.fundamentalCone.normAtPlace_pos_of_mem : ∀ {K : Type u_1} [inst : Field K] [inst_1 : NumberField K] {x : NumberField.mixedEmbedding.mixedSpace K},
  x ∈ NumberField.mixedEmbedding.fundamentalCone K →
    ∀ (w : NumberField.InfinitePlace K), 0 < (NumberField.mixedEmbedding.normAtPlace w) x
Result.exception ::
Duper saturated

Testing || Filter.disjoint_cocompact_left : ∀ {X : Type u} [inst : TopologicalSpace X] (f : Filter X), Disjoint (Filter.cocompact X) f ↔ ∃ K ∈ f, IsCompact K
Result.success

Testing || List.dlookup_kerase_ne : ∀ {α : Type u} {β : α → Type v} [inst : DecidableEq α] {a a' : α} {l : List (Sigma β)},
  a ≠ a' → List.dlookup a (List.kerase a' l) = List.dlookup a l
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `List.dlookup x_1
  (cifvar_12 x_2 x_0)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || iteratedFDerivWithin_comp_add_left' : ∀ {𝕜 : Type u} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {s : Set E}
  {f : E → F} (n : ℕ) (a : E),
  iteratedFDerivWithin 𝕜 n (fun z => f (a + z)) s = fun x => iteratedFDerivWithin 𝕜 n f (a +ᵥ s) (a + x)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || MonotoneOn.Ioc : ∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] {f g : α → β} {s : Set α},
  MonotoneOn f s → AntitoneOn g s → AntitoneOn (fun x => Set.Ioc (f x) (g x)) s
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!5 (λx0 : #0, (!7 (!17 (!1 x0)) (λx1 : #1, (!18 x1 (!4 x0))))) !2) = (!5 (λx0 : #0, (!6 (!1 x0) (!4 x0))) !2)) is not type correct

Testing || AlgebraicGeometry.StructureSheaf.comap_const : ∀ {R : Type u} [inst : CommRing R] {S : Type u} [inst_1 : CommRing S] (f : R →+* S)
  (U : TopologicalSpace.Opens ↑(AlgebraicGeometry.PrimeSpectrum.Top R))
  (V : TopologicalSpace.Opens ↑(AlgebraicGeometry.PrimeSpectrum.Top S))
  (hUV : V.carrier ⊆ ⇑(PrimeSpectrum.comap f) ⁻¹' U.carrier) (a b : R) (hb : ∀ x ∈ U, b ∈ x.asIdeal.primeCompl),
  (AlgebraicGeometry.StructureSheaf.comap f U V hUV) (AlgebraicGeometry.StructureSheaf.const R a b U hb) =
    AlgebraicGeometry.StructureSheaf.const S (f a) (f b) V ⋯
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: V.carrier ⊆ ⇑(PrimeSpectrum.comap f) ⁻¹' U.carrier is not a `∀`

Testing || ContinuousLinearMap.restrictScalars_zero : ∀ {A : Type u_1} {M : Type u_2} {M₂ : Type u_3} [inst : Ring A] [inst_1 : AddCommGroup M] [inst_2 : AddCommGroup M₂]
  [inst_3 : _root_.Module A M] [inst_4 : _root_.Module A M₂] [inst_5 : TopologicalSpace M]
  [inst_6 : TopologicalSpace M₂] {R : Type u_4} [inst_7 : Ring R] [inst_8 : _root_.Module R M]
  [inst_9 : _root_.Module R M₂] [inst_10 : LinearMap.CompatibleSMul M M₂ R A],
  ContinuousLinearMap.restrictScalars R 0 = 0
Result.success

Testing || CategoryTheory.Limits.colimit.ι_pre : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {K : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} K]
  {C : Type u} [inst_2 : CategoryTheory.Category.{v, u} C] (F : CategoryTheory.Functor J C)
  [inst_3 : CategoryTheory.Limits.HasColimit F] (E : CategoryTheory.Functor K J)
  [inst_4 : CategoryTheory.Limits.HasColimit (E.comp F)] (k : K),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (E.comp F) k)
      (CategoryTheory.Limits.colimit.pre F E) =
    CategoryTheory.Limits.colimit.ι F (E.obj k)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_21.app x_2`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Module.AEval'_def : ∀ {R : Type u_2} {M : Type u_1} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]
  (φ : M →ₗ[R] M), Module.AEval' φ = Module.AEval R M φ
Result.success

Testing || MeasureTheory.Measure.integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport : ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : AddGroup G] [inst_2 : TopologicalAddGroup G]
  [inst_3 : MeasurableSpace G] [inst_4 : BorelSpace G] (μ' μ : MeasureTheory.Measure G) [inst_5 : μ.IsAddHaarMeasure]
  [inst_6 : MeasureTheory.IsFiniteMeasureOnCompacts μ'] [inst_7 : μ'.IsAddLeftInvariant] {f : G → ℝ},
  Continuous f → HasCompactSupport f → ∫ (x : G), f x ∂μ' = ∫ (x : G), f x ∂μ'.addHaarScalarFactor μ • μ
Result.exception ::
Duper saturated

Testing || Sublattice.mem_comap : ∀ {α : Type u_2} {β : Type u_3} [inst : Lattice α] [inst_1 : Lattice β] {f : LatticeHom α β} {a : α} {L : Sublattice β},
  a ∈ Sublattice.comap f L ↔ f a ∈ L
Result.success

Testing || ContinuousAlgHom.uniformContinuous : ∀ {R : Type u_1} [inst : CommSemiring R] {E₁ : Type u_4} {E₂ : Type u_5} [inst_1 : UniformSpace E₁]
  [inst_2 : UniformSpace E₂] [inst_3 : Ring E₁] [inst_4 : Ring E₂] [inst_5 : Algebra R E₁] [inst_6 : Algebra R E₂]
  [inst_7 : UniformAddGroup E₁] [inst_8 : UniformAddGroup E₂] (f : E₁ →A[R] E₂), UniformContinuous ⇑f
Result.success

Testing || CategoryTheory.ShortComplex.rightHomologyFunctor_obj : ∀ (C : Type u_1) [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C]
  (S : CategoryTheory.ShortComplex C), (CategoryTheory.ShortComplex.rightHomologyFunctor C).obj S = S.rightHomology
Result.success

Testing || Opposite.equivToOpposite_symm_coe : ∀ {α : Sort u}, ⇑Opposite.equivToOpposite.symm = Opposite.unop
Result.exception ::
Duper saturated

Testing || tendsto_nhdsWithin_iff : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] {a : α} {l : Filter β} {s : Set α} {f : β → α},
  Filter.Tendsto f l (nhdsWithin a s) ↔ Filter.Tendsto f l (nhds a) ∧ ∀ᶠ (n : β) in l, f n ∈ s
Result.success

Testing || Complex.integerComplement_eq : Complex.integerComplement = {z | ¬∃ n, ↑n = z}
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!1 (!3 (!4 !5))) = !0) is not type correct

Testing || CategoryTheory.Limits.hasImage_zero : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  [inst_2 : CategoryTheory.Limits.HasZeroObject C] {X Y : C}, CategoryTheory.Limits.HasImage 0
Result.exception ::
Duper saturated

Testing || Std.DHashMap.getD_eq_fallback : ∀ {α : Type u} {β : α → Type v} {x : BEq α} {x_1 : Hashable α} {m : Std.DHashMap α β} [inst : LawfulBEq α] {a : α}
  {fallback : β a}, a ∉ m → m.getD a fallback = fallback
Result.success

Testing || ULift.addRightCancelSemigroup.proof_2 : ∀ {α : Type u_2} [inst : AddRightCancelSemigroup α] (x x_1 : ULift.{u_1, u_2} α),
  Equiv.ulift (x + x_1) = Equiv.ulift (x + x_1)
Result.success

Testing || CategoryTheory.Functor.CoreMonoidal.μIso_hom_natural_right_assoc : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] {D : Type u₂}
  [inst_2 : CategoryTheory.Category.{v₂, u₂} D] [inst_3 : CategoryTheory.MonoidalCategory D]
  {F : CategoryTheory.Functor C D} (self : F.CoreMonoidal) {X Y : C} (X' : C) (f : X ⟶ Y) {Z : D}
  (h : F.obj (CategoryTheory.MonoidalCategory.tensorObj X' Y) ⟶ Z),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.whiskerLeft (F.obj X') (F.map f))
      (CategoryTheory.CategoryStruct.comp (self.μIso X' Y).hom h) =
    CategoryTheory.CategoryStruct.comp (self.μIso X' X).hom
      (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.MonoidalCategory.whiskerLeft X' f)) h)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CircleDeg1Lift.translate_zpow : ∀ (x : ℝ) (n : ℤ),
  CircleDeg1Lift.translate (Multiplicative.ofAdd x) ^ n = CircleDeg1Lift.translate (Multiplicative.ofAdd (↑n * x))
Result.exception ::
(deterministic) timeout at `superposition`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || TopologicalSpace.Compacts.equiv_symm : ∀ {α : Type u_1} {β : Type u_2} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] (f : α ≃ₜ β),
  TopologicalSpace.Compacts.equiv f.symm = (TopologicalSpace.Compacts.equiv f).symm
Result.success

Testing || OrderDual.instPosSMulReflectLE : ∀ {α : Type u_1} {β : Type u_2} [inst : Preorder α] [inst_1 : Preorder β] [inst_2 : SMul α β] [inst_3 : _root_.Zero α]
  [inst_4 : PosSMulReflectLE α β], PosSMulReflectLE α βᵒᵈ
Result.exception ::
Duper saturated

Testing || lowerClosure_vadd : ∀ {α : Type u_1} [inst : OrderedAddCommGroup α] (s : Set α) (a : α), lowerClosure (a +ᵥ s) = a +ᵥ lowerClosure s
Result.exception ::
Duper saturated

Testing || LTSeries.mk_length : ∀ {α : Type u_1} [inst : Preorder α] (length : ℕ) (toFun : Fin (length + 1) → α) (strictMono : StrictMono toFun),
  (LTSeries.mk length toFun strictMono).length = length
Result.success

Testing || tendsto_neg_nhdsWithin_Iio : ∀ {H : Type x} [inst : TopologicalSpace H] [inst_1 : OrderedAddCommGroup H] [inst_2 : ContinuousNeg H] {a : H},
  Filter.Tendsto Neg.neg (nhdsWithin a (Set.Iio a)) (nhdsWithin (-a) (Set.Ioi (-a)))
Result.success

Testing || Prod.instAddRightCancelMonoid.proof_5 : ∀ {M : Type u_1} {N : Type u_2} [inst : AddRightCancelMonoid M] [inst_1 : AddRightCancelMonoid N] (a a_1 a_2 : M × N),
  a + a_1 = a_2 + a_1 → a = a_2
Result.success

Testing || Set.pairwise_disjoint_Ioc_intCast : ∀ (α : Type u_1) [inst : OrderedRing α], Pairwise (Disjoint on fun n => Set.Ioc (↑n) (↑n + 1))
Result.exception ::
(deterministic) timeout at `fluidSup`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.OverPresheafAux.yonedaCollectionFunctor_map : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (A : CategoryTheory.Functor Cᵒᵖ (Type v))
  {X Y : CategoryTheory.Functor (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)ᵒᵖ (Type v)} (η : X ⟶ Y),
  (CategoryTheory.OverPresheafAux.yonedaCollectionFunctor A).map η =
    CategoryTheory.OverPresheafAux.yonedaCollectionPresheafMap₁ η
Result.success

Testing || CategoryTheory.Limits.MulticospanIndex.sndPiMap_π_assoc : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (I : CategoryTheory.Limits.MulticospanIndex C)
  [inst_1 : CategoryTheory.Limits.HasProduct I.left] [inst_2 : CategoryTheory.Limits.HasProduct I.right] (b : I.R)
  {Z : C} (h : I.right b ⟶ Z),
  CategoryTheory.CategoryStruct.comp I.sndPiMap
      (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π I.right b) h) =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π I.left (I.sndTo b))
      (CategoryTheory.CategoryStruct.comp (I.snd b) h)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.Limits.limit.lift
  (cifvar_1 cifvar_2) x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || LieEquiv.symm_trans : ∀ {R : Type u} {L₁ : Type v} {L₂ : Type w} {L₃ : Type w₁} [inst : CommRing R] [inst_1 : LieRing L₁]
  [inst_2 : LieRing L₂] [inst_3 : LieRing L₃] [inst_4 : LieAlgebra R L₁] [inst_5 : LieAlgebra R L₂]
  [inst_6 : LieAlgebra R L₃] (e₁ : L₁ ≃ₗ⁅R⁆ L₂) (e₂ : L₂ ≃ₗ⁅R⁆ L₃), (e₁.trans e₂).symm = e₂.symm.trans e₁.symm
Result.success

Testing || Computable.option_bind : ∀ {α : Type u_1} {β : Type u_2} {σ : Type u_4} [inst : Primcodable α] [inst_1 : Primcodable β] [inst_2 : Primcodable σ]
  {f : α → Option β} {g : α → β → Option σ}, Computable f → Computable₂ g → Computable fun a => (f a).bind (g a)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || tsum_setProd_singleton_left : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : AddCommMonoid α] [inst_1 : TopologicalSpace α] (b : β)
  (t : Set γ) (f : β × γ → α), ∑' (x : ↑({b} ×ˢ t)), f ↑x = ∑' (c : ↑t), f (b, ↑c)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type { x // x ∈ x_1 } of λ binder contains bound variables

Testing || CategoryTheory.Comma.instIsIsoRight : ∀ {A : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} A] {B : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} B]
  {T : Type u₃} [inst_2 : CategoryTheory.Category.{v₃, u₃} T] {L : CategoryTheory.Functor A T}
  {R : CategoryTheory.Functor B T} {X Y : CategoryTheory.Comma L R} (e : X ⟶ Y) [inst_3 : CategoryTheory.IsIso e],
  CategoryTheory.IsIso e.right
Result.exception ::
Duper saturated

Testing || SemidirectProduct.map_comp_inr : ∀ {N₁ : Type u_4} {G₁ : Type u_5} {N₂ : Type u_6} {G₂ : Type u_7} [inst : Group N₁] [inst_1 : Group G₁]
  [inst_2 : Group N₂] [inst_3 : Group G₂] {φ₁ : G₁ →* MulAut N₁} {φ₂ : G₂ →* MulAut N₂} (fn : N₁ →* N₂) (fg : G₁ →* G₂)
  (h : ∀ (g : G₁), fn.comp (MulEquiv.toMonoidHom (φ₁ g)) = (MulEquiv.toMonoidHom (φ₂ (fg g))).comp fn),
  (SemidirectProduct.map fn fg h).comp SemidirectProduct.inr = SemidirectProduct.inr.comp fg
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `{ left := x_2, right := x_1 }`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.any_toArray' : ∀ {α : Type u_1} {stop : ℕ} (p : α → Bool) (l : List α), stop = l.toArray.size → l.toArray.any p 0 stop = l.any p
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_1.any x_0 cifvar_8
  (cifvar_2 (cifvar_10 x_1))`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Batteries.HashMap.Imp.expand_size : ∀ {α : Type u_1} {β : Type u_2} {sz : ℕ} [inst : Hashable α] {buckets : Batteries.HashMap.Imp.Buckets α β},
  (Batteries.HashMap.Imp.expand sz buckets).buckets.size = buckets.size
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Batteries.HashMap.Imp.expand.proof_1
  x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.takeD_eq_take : ∀ {α : Type u} {n : ℕ} {l : List α} (a : α), n ≤ l.length → List.takeD n l a = List.take n l
Result.exception ::
Duper saturated

Testing || emultiplicity_mul : ∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] {p a b : α},
  Prime p → emultiplicity p (a * b) = emultiplicity p a + emultiplicity p b
Result.exception ::
(deterministic) timeout at `match`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Ordnode.findMin'_dual : ∀ {α : Type u_1} (t : Ordnode α) (x : α), t.dual.findMin' x = Ordnode.findMax' x t
Result.exception ::
Duper saturated

Testing || Submodule.map_coe : ∀ {R : Type u_1} {R₂ : Type u_3} {M : Type u_5} {M₂ : Type u_7} [inst : Semiring R] [inst_1 : Semiring R₂]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R₂ M₂]
  {σ₁₂ : R →+* R₂} [inst_6 : RingHomSurjective σ₁₂] {F : Type u_9} [inst_7 : FunLike F M M₂]
  [inst_8 : SemilinearMapClass F σ₁₂ M M₂] (f : F) (p : Submodule R M), ↑(Submodule.map f p) = ⇑f '' ↑p
Result.success

Testing || CategoryTheory.skeletonEquivalence_unitIso : ∀ (C : Type u₁) [inst : CategoryTheory.Category.{v₁, u₁} C],
  (CategoryTheory.skeletonEquivalence C).unitIso =
    CategoryTheory.NatIso.ofComponents (fun X => CategoryTheory.InducedCategory.isoMk (Nonempty.some ⋯).symm) ⋯
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In ∀
  (naturality :
    autoParam
      (∀ {X Y : CategoryTheory.Skeleton C} (f : X ⟶ Y),
        CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.id (CategoryTheory.Skeleton C)).map f)
            (CategoryTheory.InducedCategory.isoMk (Classical.choice ⋯).symm).hom =
          CategoryTheory.CategoryStruct.comp (CategoryTheory.InducedCategory.isoMk (Classical.choice ⋯).symm).hom
            (((CategoryTheory.fromSkeleton C).comp (CategoryTheory.toSkeletonFunctor C)).map f))
      _auto✝),
  (CategoryTheory.skeletonEquivalence C).unitIso =
    CategoryTheory.NatIso.ofComponents (fun X => CategoryTheory.InducedCategory.isoMk (Classical.choice ⋯).symm)
      naturality, type of dependent ∀ bound variable is of sort `Prop`

Testing || LaurentSeries.tendsto_valuation : ∀ (K : Type u_2) [inst : Field K]
  (a : IsDedekindDomain.HeightOneSpectrum.adicCompletion (RatFunc K) (Polynomial.idealX K)),
  Filter.Tendsto (⇑Valued.v) (Filter.comap (↑(RatFunc K)) (nhds a)) (nhds (Valued.v a))
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Order.Ico_pred_right_eq_insert : ∀ {α : Type u_1} [inst : LinearOrder α] [inst_1 : PredOrder α] {a b : α} [inst_2 : NoMinOrder α],
  a ≤ b → Set.Ioc (Order.pred a) b = insert a (Set.Ioc a b)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Set.Iic exfvar_6`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Elapsed time: 230143 ms

Summary:

0 E FiniteDimensional.trans
1 E Complex.instIsComplete
2 E ContDiffOn.norm_sq
3 E PartialHomeomorph.isOpen_image_iff_of_subset_source
4 E CategoryTheory.Functor.IsEventuallyConstantTo.coneπApp_eq_id
5 E CompHausLike.hasPullbacksOfInclusions
6 E List.mem_flatten
7 S Polynomial.cyclotomic_two
8 E BoxIntegral.Box.dist_le_distortion_mul
9 S mul_le_of_le_of_le_one_of_nonneg
10 E CategoryTheory.Limits.hasCoequalizers_of_hasPushouts_and_binary_coproducts
11 E Function.OfArity.uncurry_two_eq_uncurry
12 E mem_own_rightAddCoset
13 E Ideal.isHomogeneous_iff_forall_subset
14 E AlgebraicGeometry.Scheme.evaluation_naturality
15 S CategoryTheory.SingleObj.mapHom_comp
16 S isAddUnit_of_add_isAddUnit_right
17 E PMF.toOuterMeasure_uniformOfFintype_apply
18 E AlgebraicTopology.DoldKan.Γ₀.Obj.map_on_summand
19 E CircleDeg1Lift.le_iterate_of_add_int_le_map
20 E ProbabilityTheory.Kernel.iIndepFun.meas_biInter
21 S CategoryTheory.Functor.comp_obj
22 E genericPoint_closure
23 S AddMonoidHom.noncommCoprod.proof_2
24 E Finset.coe_mem
25 S Real.nat_cast_lt_toNNReal
26 E AddMonoidAlgebra.lift_apply
27 S Finset.sup_singleton
28 E Complex.I_mul_im
29 E Option.orElse_none'
30 E Module.Flat.iff_lTensor_exact
31 S Int.emod_negSucc
32 E Set.preimage_injective
33 S HurwitzZeta.completedCosZeta_one_sub
34 E List.TFAE.out
35 S CommRingCat.Under.equalizerFork'_ι
36 S OrderIso.map_csSup'
37 E Nat.ofDigits_lt_base_pow_length
38 S EMetric.preimage_add_left_ball
39 E Cardinal.induction_on_pi
40 S Turing.PartrecToTM2.tr_move
41 E Array.reflBEq_iff
42 S LinearMap.finiteDimensional
43 E sum_conjClasses_card_eq_card
44 S nonempty_Prop
45 E WithTop.instOrderedSub
46 E Ideal.comap_map_mk
47 E Std.DHashMap.Internal.Raw₀.contains_insertIfNew
48 E CategoryTheory.ShortComplex.opcyclesMap'_g'_assoc
49 S act_rel_of_act_rel_of_rel_act_rel
50 E hasContinuousInv₀_of_hasSmoothInv₀
51 E BitVec.msb_eq_getLsbD_last
52 E WittVector.mul_polyOfInterest_aux5
53 E CategoryTheory.MorphismProperty.pullback_fst
54 S Eq.ge
55 S Set.infinite_prod
56 E IsLocalization.submonoid_map_le_is_unit
57 E instNontrivialStalkPresheafSmoothSheaf
58 E CategoryTheory.Limits.colimitYonedaHomIsoLimitOp_π_apply
59 E Asymptotics.isEquivalent_iff_exists_eq_mul
60 E norm_add_sq_real
61 S Polynomial.natDegree_pos_of_not_isUnit_of_dvd_monic
62 E MeasureTheory.SimpleFunc.measurableSet_preimage
63 E EMetric.tendsto_nhds_nhds
64 S QuadraticModuleCat.forget₂_map
65 S ZeroHom.comp.proof_1
66 E Turing.PartrecToTM2.supports_insert
67 E ContinuousLinearEquiv.isOpen
68 E MeasureTheory.StronglyMeasurable.measurableSet_mulSupport
69 E DirichletCharacter.isMultiplicative_toArithmeticFunction
70 E mem_perms_of_finset_iff
71 E _private.Mathlib.Data.Real.Pi.Irrational.0.is_integer
72 E Order.height_eq_top_iff
73 S List.getD_map
74 E FiniteDimensional.exists_is_basis_integral
75 E LinearMap.prod_eq_inf_comap
76 E HahnSeries.toPowerSeriesAlg_apply
77 E Order.Iic_pred_of_not_isMin
78 S Complex.abs_of_nonneg
79 E eventually_uniformity_iterate_comp_subset
80 E Sum.Lex.Icc_inr_inr
81 E AlgebraicGeometry.LocallyRingedSpace.stalkMap_inv_hom_assoc
82 S Nat.even_sub
83 S List.mem_of_mem_inter_right
84 E Set.Finite.toFinset_insert
85 S QuotientAddGroup.quotientEquivSelf.proof_3
86 S List.eq_nil_of_map_eq_nil
87 S NumberField.InfinitePlace.comap_id
88 E RelIso.cast_trans
89 E Set.nontrivial_of_lt
90 S CategoryTheory.Groupoid.Free.of_eq
91 E Antitone.iUnion_comp_tendsto_atBot
92 E Filter.map_sigma_mk_comap
93 E ProbabilityTheory.mgf_smul_left
94 E CategoryTheory.ShortComplex.SnakeInput.L₃_exact
95 E PartialHomeomorph.eventually_left_inverse'
96 E CategoryTheory.ComposableArrows.homMk₃_app_zero
97 S ProbabilityTheory.Kernel.condKernelCountable_apply
98 S MonoidHom.submonoidComap_apply_coe
99 E Batteries.instTransCmpFlipOrdering
100 E LinearMap.BilinForm.nondegenerate_of_det_ne_zero
101 E NumberField.Units.dirichletUnitTheorem.unitLattice_span_eq_top
102 E translate_neg_right
103 S ContDiff.of_succ
104 E Matrix.det_updateCol_add_self
105 S uniformContinuous_const
106 E CategoryTheory.Adjunction.compPreadditiveYonedaIso_hom_app_app_apply
107 S ContinuousLinearEquiv.compContinuousMultilinearMapL_apply
108 E conjneg_conjneg
109 S ProbabilityTheory.Kernel.IsSFiniteKernel.snd
110 E CategoryTheory.preserves_mono_of_preservesLimit
111 E AddGroupNormClass.toNormedAddGroup.proof_1
112 S PadicInt.nonarchimedean
113 E CategoryTheory.Pretriangulated.instIsHomologicalOppositeAddCommGrpObjFunctorPreadditiveYoneda
114 E StrictConvexOn.lt_on_open_segment'
115 E OrderedCommGroup.toMulLeftReflectLE
116 E neg_of_smul_neg_right'
117 E Std.DHashMap.Internal.Raw₀.size_le_size_insert
118 E CategoryTheory.Zigzag.of_zag
119 E HomogeneousIdeal.toIdeal_iSup₂
120 E CategoryTheory.GrothendieckTopology.sheafifyLift_unique
121 E Asymptotics.IsBigO.eventually_integrableOn
122 S Associates.le_singleton_iff
123 E Subgroup.op_iInf
124 S mul_nsmul'
125 S Multiset.coe_eq_singleton
126 E Polynomial.opRingEquiv_op_monomial
127 E Monotone.map_liminf_of_continuousAt
128 E Set.ball_empty_iff
129 E AddSubmonoid.prod_le_iff
130 E Real.sin_pos_of_mem_Ioo
131 E Equiv.Perm.commute_of_mem_cycleFactorsFinset_commute
132 E Submonoid.prod_eq_bot_iff
133 E SatisfiesM_Option_eq
134 E WeierstrassCurve.variableChange_Δ
135 E RelEmbedding.toEmbedding_inj
136 S Fin.rev_bot
137 E CategoryTheory.Limits.hasBiproductsOfShape_finite
138 E Std.DHashMap.Internal.List.getValueCast!_eraseKey_self
139 S tsum_const_smul
140 E Finset.subset_singleton_iff
141 E PowerSeries.WithPiTopology.continuous_constantCoeff
142 E Submodule.comap_surjective_of_injective
143 E Ordnode.Valid'.of_lt
144 E Heyting.Regular.coe_injective
145 E CauchySeq.prod
146 S exists_le_le
147 E List.init_eq_of_concat_eq
148 E Fin.ofNat'_sub
149 S Equiv.Perm.SameCycle.extendDomain
150 E CategoryTheory.IsUniversalColimit.of_mapCocone
151 E hasSum_single
152 S MagmaCat.ofHom_apply
153 E ContMDiffMap.mdifferentiableAt
154 E MeasureTheory.levyProkhorovDist_self
155 S AddHom.fst_comp_prod
156 E AddMonoidHom.coe_ofClosureMEqTopLeft
157 E CategoryTheory.ShortComplex.Exact.epi_f
158 S AddMonoidHom.inverse.proof_3
159 E Auto.Embedding.Lam.LamEquiv.congr
160 E CategoryTheory.SingleFunctors.shiftIso_add'_inv_app
161 S Duper.rule15bTheorem
162 E Multiset.card_coe
163 E List.pairwise_iff
164 E AddSubgroup.isOpen_of_isClosed_of_finiteIndex
165 E parallelogram_law_with_norm
166 S MvPolynomial.eval₂_map
167 E Set.indicator_le_indicator
168 S AddHom.restrict_apply
169 E Part.ωSup_eq_none
170 E SimpleGraph.Connected.mono
171 E CochainComplex.mappingCone.lift_snd
172 E Submonoid.mem_prod
173 E CategoryTheory.sheafifyMap_sheafifyLift
174 E UniformOnFun.toFun_zero
175 E EuclideanGeometry.Sphere.secondInter_smul
176 S disjoint_sdiff_comm
177 E compl_add_closure_zero_eq
178 S Polynomial.Monic.natDegree_pos_of_not_isUnit
179 E AddSubgroup.eq_of_le_of_card_ge
180 E WittVector.mulN_coeff
181 E isIntegralCurveAt_comp_mul_ne_zero
182 E DomAddAct.instAddActionSubtypeAEEqFunMemAddAddSubgroupLp.proof_2
183 E AddSubmonoid.le_op_iff
184 S LinOrd.dualEquiv_inverse
185 E Complex.nnnorm_real
186 E Sublattice.mem_sInf
187 E CategoryTheory.ChosenFiniteProducts.lift_snd
188 E Cardinal.mk_quotient_le
189 E TrivSqZeroExt.snd_exp
190 E AlgebraicTopology.DoldKan.Q_f_idem
191 E Isometry.mapsTo_perpBisector
192 E CategoryTheory.Discrete.monoidal_leftUnitor
193 S contravariant_lt_of_contravariant_le
194 E Int.eq_mul_div_of_mul_eq_mul_of_dvd_left
195 E pointedToPartialFun_map
196 E MulRingSeminormClass.toRingSeminormClass
197 E CategoryTheory.ThinSkeleton.map_id_eq
198 E Ordinal.pred_lt_iff_is_succ
199 S Polynomial.lt_rootMultiplicity_iff_isRoot_iterate_derivative_of_mem_nonZeroDivisors
200 E List.Vector.mem_iff_get
201 E Std.Tactic.BVDecide.LRAT.Internal.CNF.Clause.mem_lrat_of_mem
202 E HomologicalComplex₂.d_f_comp_d_f
203 S grade_lt_grade_iff
204 E Matrix.vecMulVec_empty
205 S List.join_map_filter
206 S Matrix.circulant_add
207 S CategoryTheory.CostructuredArrow.map_obj_hom
208 E LinearMap.range_toContinuousLinearMap
209 E LinearEquiv.isUnit_det
210 E riemannZeta_eulerProduct_hasProd
211 E FiniteDimensional.finiteDimensional_subalgebra
212 E Set.iUnion_vadd_left_image
213 S SimpleGraph.edgeSet_ssubset_edgeSet
214 S isAtomic_iff_isCoatomic
215 E AlgebraicGeometry.isSurjectiveOnStalks_isLocalAtTarget
216 E hasGroupoid_continuousGroupoid
217 E SimpleGraph.Walk.reverse_singleton
218 S divp_assoc'
219 S Set.add_iUnion
220 S PiToModule.fromEnd_apply
221 E ContextFreeGrammar.derives_reverse_comm
222 E AlgebraicGeometry.Scheme.PartialMap.fromSpecStalkOfMem_compHom
223 E CochainComplex.HomComplex.δ_comp_zero_cocycle
224 E NumberField.mixedEmbedding.instIsZLatticeRealMixedSpaceIntegerLattice
225 S addEquivOfAddOrderOfEq.proof_1
226 S kstar_mul_kstar
227 S Real.rpow_eq_zero
228 E MvPowerSeries.coeff_mul_left_one_sub_of_lt_weightedOrder
229 S CategoryTheory.Arrow.w_mk_right_assoc
230 S CommRingCat.isLocalRingHom_comp
231 E Nat.eq_of_dvd_of_lt_two_mul
232 E Finsupp.Lex.single_strictAnti
233 S neg_iff_neg_of_mul_pos
234 E Derivation.coe_neg
235 E Quotient.finChoiceEquiv_symm_apply
236 S Filter.add_neBot_iff
237 E Filter.cocardinal_aleph0_eq_cofinite
238 S ContDiffAt.snd
239 E stdSimplex_unique
240 E Matrix.UnitaryGroup.star_mul_self
241 S List.find?_replicate_of_neg
242 E covBy_iff_wcovBy_and_ne
243 E MeasureTheory.toReal_laverage
244 E CofiniteTopology.nhds_eq
245 E ENat.one_lt_card_iff_nontrivial
246 E SetTheory.PGame.lf_of_le_moveLeft
247 S Finset.sdiff_empty
248 E Vector.continuous_insertIdx'
249 E Polynomial.nontrivial_iff
250 E AlgebraicGeometry.AffineScheme.Γ_preservesLimits
251 S Int.fract_sub_self
252 E OrderIso.bddBelow_image
253 S ContinuousMap.comp_id
254 E MvPolynomial.join₂_comp_map
255 E CircleDeg1Lift.map_sub_int
256 S Polynomial.natDegree_hermite
257 E Monotone.map_sInf_of_continuousAt
258 E MemHolder.nnHolderNorm_nsmul
259 S Int.lt.intro
260 S IsOpen.mul_left
261 E MulAction.IsBlock.empty
262 E MonoidAlgebra.opRingEquiv_single
263 E TwoSidedIdeal.mem_ker
264 E CategoryTheory.GradedObject.ι_mapBifunctorAssociator_inv
265 E AddSubmonoid.toAddZeroClass.proof_1
266 S List.subset_append_of_subset_left
267 E CompHausLike.instHasPropSigma
268 E tsupport_smul_subset_right
269 S NONote.NF
270 E Primrec.cond
271 E Submodule.Quotient.equiv_apply
272 E BitVec.neg_neg
273 S List.finRange_zero
274 S Finset.sups_nonempty
275 S Ordnode.Valid.merge
276 E SzemerediRegularity.increment_isEquipartition
277 E ChainComplex.quasiIsoAt₀_iff
278 S Vector.indexOf?_mk
279 S UpperSet.coe_compl
280 E Equiv.Perm.IsCycle.support_pow_eq_iff
281 E joinM_map_map
282 S Filter.ZeroAtFilter.neg
283 E Nimber.add_nat
284 E Grp.FilteredColimits.forget₂Mon_preservesFilteredColimits
285 E Auto.Embedding.Lam.LamBaseSort.eq_of_beq_eq_true
286 S HahnSeries.isWF_support
287 E PrimeSpectrum.localization_away_comap_range
288 S AddSubgroup.map.proof_2
289 E Small.trans_univLE
290 S ContinuousMap.addUnitsLift_symm_apply_apply_neg'
291 S CategoryTheory.ShortComplex.SnakeInput.id_f₁
292 E TensorProduct.piScalarRight_apply
293 S RootPairing.reflection_perm_involutive
294 E Set.instLawfulMonad
295 S decide_True'
296 E LSeries.abscissaOfAbsConv_one
297 E isLittleO_pow_pow_of_lt_left
298 E Ordinal.iSup_lt_lift
299 S SeparationQuotient.inducing_mk
300 S div_two_sub_self
301 S aestronglyMeasurable_lineDeriv_uncurry
302 S Int.Prime.dvd_pow'
303 E Filter.blimsup_not_sup
304 S Coheyting.boundary_inf_le
305 E CategoryTheory.IsFiltered.coeq₃_condition₁
306 S disjoint_compl_right
307 S Heyting.Regular.coe_sdiff
308 E CompHausLike.LocallyConstantModule.functorToPresheaves_obj_obj_isAddCommGroup
309 S Polynomial.Chebyshev.aeval_U
310 E lipschitzExtensionConstant_def
311 S SubMulAction.coe_copy
312 E Cardinal.mul_eq_max'
313 S AlgHom.val_comp_codRestrict
314 S CStarRing.norm_one
315 E Cardinal.mk_ne_zero_iff
316 E Fin.Ioi_zero_eq_map
317 E exists_mem_frontier_infDist_compl_eq_dist
318 E Filter.Tendsto.max
319 E List.Pi.forall_rel_cons_ext
320 S WithBot.toDual_lt_toDual_iff
321 E Nat.Partrec.Code.fixed_point
322 E IsAddQuantale.add_bot
323 E CategoryTheory.Equivalence.pi_functor
324 S Matroid.Matroidᵣ.coe_inj
325 E CategoryTheory.ShortComplex.LeftHomologyData.f'_i_assoc
326 S AddSubgroup.isComplement'_comm
327 E Equiv.mul_swap_involutive
328 S AddMonoid.not_isTorsion_iff
329 S Set.mem_iInter_of_mem
330 E FirstOrder.Language.LHom.id_onTerm
331 S Mod_.hom_ext
332 E Matrix.permanent_zero
333 S Ideal.radical_eq_iff
334 E NonemptyInterval.coe_pure
335 E exists_Ioo_extr_on_Icc
336 S PrimeSpectrum.comap_basicOpen
337 E CategoryTheory.HasExactLimitsOfShape.of_codomain_equivalence
338 E IsCyclotomicExtension.Rat.absdiscr_prime
339 E span_gramSchmidt_Iio
340 E Equiv.continuous_symm_iff
341 S SimpleGraph.instInhabited_default
342 E Nat.exists_not_and_succ_of_not_zero_of_exists
343 E ConvexOn.le_left_of_right_le'
344 S NormedAddGroupHom.Equalizer.ι_comp_lift
345 S CategoryTheory.Limits.MultispanIndex.multicoforkEquivSigmaCofork_functor
346 E CategoryTheory.Limits.instEpiFactorThruImageOfHasLimitWalkingParallelPairParallelPair
347 E Submonoid.unop_closure
348 E Pi.ringHom_apply
349 E ProbabilityTheory.Kernel.indepSet_zero_right
350 S InnerProductSpace.Core.sqrt_normSq_eq_norm
351 E Cardinal.natCast_le_toENat_iff
352 S AddSubsemigroup.mem_comap
353 S Equiv.prodAssoc_symm_apply
354 S Prop.exists_iff
355 E AntitoneOn.map_bddAbove
356 E add_sSup_distrib
357 E AddChar.sum_apply_eq_ite
358 E DualNumber.exp_smul_eps
359 S QuaternionAlgebra.Basis.liftHom_apply
360 E EReal.induction₂
361 S intervalIntegral.deriv_integral_right
362 S Finset.compls_subset_compls
363 S Sbtw.oangle_eq_right
364 E CategoryTheory.ShortComplex.LeftHomologyData.ofAbelian_i
365 E UV.disjoint_of_mem_compression_of_not_mem
366 S CategoryTheory.StructuredArrow.post_obj
367 E Equiv.Perm.VectorsProdEqOne.rotate_zero
368 E TrivSqZeroExt.instTopologicalRingOfTopologicalAddGroupOfContinuousSMulMulOpposite
369 S LipschitzWith.dist_right
370 S Set.Finite.powerset
371 S contDiff_iff_forall_nat_le
372 S CategoryTheory.Limits.compReflectsLimitsOfShape
373 E SimpleGraph.IsNClique.insert
374 E DilationEquiv.ratio_zpow
375 S instIsSuccArchimedeanMultiplicative
376 E Stream'.WSeq.liftRel_append
377 E TopologicalSpace.isTopologicalBasis_of_subbasis_of_inter
378 E LieSubmodule.le_normalizer
379 E List.exists_of_mem_keys
380 E AlgebraicTopology.DoldKan.Compatibility.equivalenceUnitIso_eq
381 S AffineEquiv.pointReflection_apply
382 S RCLike.nonpos_iff_exists_ofReal
383 E generateFrom_iUnion
384 E CategoryTheory.Adjunction.counit_epi_of_R_faithful
385 E ContinuousSup.measurableSup₂
386 S BoxIntegral.TaggedPrepartition.unionComplToSubordinate_boxes
387 E CategoryTheory.MonoidalCategory.whiskerLeft_inv_hom'_assoc
388 E SpectrumRestricts.nnreal_iff_spectralRadius_le
389 E Real.sin_nat_mul_pi_sub
390 E IsNonarchimedean.multiset_image_add
391 S DirectSum.of_eq_of_gradedMonoid_eq
392 E IsMinOn.of_isLocalMinOn_of_convexOn
393 S List.map₂Right'_nil_right
394 E Set.mulIndicator_one_preimage
395 E strictAntiOn_of_add_one_lt
396 S orderOf_eq_prime
397 E Polynomial.leadingCoeff_det_X_one_add_C
398 S Quaternion.normSq_coe
399 S Ideal.comap_comap
400 S MulHom.srange_top_of_surjective
401 S ContinuousLinearMap.proj_apply
402 S Order.Ioo_succ_right
403 E Sym2.GameAdd.fix_eq
404 E UniqueSums.of_same
405 S FreeAbelianGroup.add_bind
406 E CategoryTheory.ChosenFiniteProducts.leftUnitor_inv_snd_assoc
407 E ENNReal.log_strictMono
408 E OrderMonoidHom.copy_eq
409 E LowerSemicontinuous.add'
410 S Vector.continuous_insertNth
411 E RatFunc.algebraMap_apply_div
412 E CategoryTheory.braiding_inv_apply
413 E instOrderedSubPrimeMultiset
414 E IntermediateField.map_le_iff_le_comap
415 S CategoryTheory.Functor.mapTriangle_map_hom₁
416 E ZNum.cmp_to_int
417 E isLocalHomeomorphOn_iff_isOpenEmbedding_restrict
418 S Commute.invOf_left
419 E Rat.canLift
420 E Subring.mem_pointwise_smul_iff_inv_smul_mem
421 E AddSubgroup.card_dvd_of_surjective
422 S Subalgebra.topologicalClosure_minimal
423 E Valuation.isEquiv_iff_val_eq_one
424 E WeierstrassCurve.ofJ0_c₄
425 E CategoryTheory.Limits.id_preservesColimitsOfSize
426 S Finsupp.sumFinsuppAddEquivProdFinsupp_apply
427 E WithBot.unbot_coe
428 E Normal.minpoly_eq_iff_mem_orbit
429 S HahnSeries.SummableFamily.ext
430 S Bool.cond_pos
431 S AddUnits.neg_add_eq_iff_eq_add
432 E Polynomial.isRoot_cyclotomic_iff
433 S SimplexCategory.Truncated.instFullInclusion
434 E Ordinal.nfp_le_fp
435 E List.length_eraseP_add_one
436 S BitVec.eq_sub_iff_add_eq
437 S EuclideanGeometry.collinear_of_angle_eq_zero
438 E MeasureTheory.Measure.instNeZeroOfNonempty
439 E AddAction.IsFixedBlock.univ
440 E FreeGroup.invRev_involutive
441 E CategoryTheory.Adjunction.unit_rightAdjointUniq_hom_app_assoc
442 E Nat.Primes.coe_nat_injective
443 E Affine.Simplex.circumcenter_eq_affineCombination_of_pointsWithCircumcenter
444 E covBy_iff_lt_covBy_grade
445 E List.range'_subset_right_1
446 E AffineSubspace.SSameSide.trans
447 E Finset.dens_lt_dens
448 S Submonoid.closure_eq_of_le
449 E SetLike.prod_mem_graded
450 E Pi.mulSupport_mulSingle_one
451 S CategoryTheory.SemiadditiveOfBinaryBiproducts.add_eq_right_addition
452 S RCLike.nonneg_iff
453 E Finset.sup'_mono
454 S WithBot.zero_ne_bot
455 E IsCyclotomicExtension.discr_prime_pow_eq_unit_mul_pow
456 S TopHom.comp_apply
457 E Basis.finTwoProd_zero
458 E Set.piecewise_neg
459 E CategoryTheory.Adjunction.toEquivalence_inverse
460 S Units.val_inv_ofPowEqOne
461 E EMetric.diam_closedBall
462 E minpoly.coeff_zero_eq_zero
463 E Set.bijOn_iInter
464 E Module.End.HasUnifEigenvalue.lt
465 E CategoryTheory.Comonad.ComonadicityInternal.main_pair_F_cosplit
466 E AddSubgroup.map_eq_bot_iff
467 E CategoryTheory.hasExactColimitsOfShape_discrete_of_hasExactColimitsOfShape_finset_discrete
468 E NumberField.mixedEmbedding.fundamentalCone.normAtPlace_pos_of_mem
469 S Filter.disjoint_cocompact_left
470 E List.dlookup_kerase_ne
471 E iteratedFDerivWithin_comp_add_left'
472 E MonotoneOn.Ioc
473 E AlgebraicGeometry.StructureSheaf.comap_const
474 S ContinuousLinearMap.restrictScalars_zero
475 E CategoryTheory.Limits.colimit.ι_pre
476 S Module.AEval'_def
477 E MeasureTheory.Measure.integral_isAddLeftInvariant_eq_smul_of_hasCompactSupport
478 S Sublattice.mem_comap
479 S ContinuousAlgHom.uniformContinuous
480 S CategoryTheory.ShortComplex.rightHomologyFunctor_obj
481 E Opposite.equivToOpposite_symm_coe
482 S tendsto_nhdsWithin_iff
483 E Complex.integerComplement_eq
484 E CategoryTheory.Limits.hasImage_zero
485 S Std.DHashMap.getD_eq_fallback
486 S ULift.addRightCancelSemigroup.proof_2
487 E CategoryTheory.Functor.CoreMonoidal.μIso_hom_natural_right_assoc
488 E CircleDeg1Lift.translate_zpow
489 S TopologicalSpace.Compacts.equiv_symm
490 E OrderDual.instPosSMulReflectLE
491 E lowerClosure_vadd
492 S LTSeries.mk_length
493 S tendsto_neg_nhdsWithin_Iio
494 S Prod.instAddRightCancelMonoid.proof_5
495 E Set.pairwise_disjoint_Ioc_intCast
496 S CategoryTheory.OverPresheafAux.yonedaCollectionFunctor_map
497 E CategoryTheory.Limits.MulticospanIndex.sndPiMap_π_assoc
498 S LieEquiv.symm_trans
499 E Computable.option_bind
500 E tsum_setProd_singleton_left
501 E CategoryTheory.Comma.instIsIsoRight
502 E SemidirectProduct.map_comp_inr
503 E List.any_toArray'
504 E Batteries.HashMap.Imp.expand_size
505 E List.takeD_eq_take
506 E emultiplicity_mul
507 E Ordnode.findMin'_dual
508 S Submodule.map_coe
509 E CategoryTheory.skeletonEquivalence_unitIso
510 E LaurentSeries.tendsto_valuation
511 E Order.Ico_pred_right_eq_insert
