Config = {maxHeartbeats := 65536, timeout := 10, solverConfig := smt cvc5, logFile := evalAutoOut.txt}

Testing || Bornology.isBounded_sUnion : ‚àÄ {Œ± : Type u_2} [inst : Bornology Œ±] {S : Set (Set Œ±)},
  S.Finite ‚Üí (Bornology.IsBounded (‚ãÉ‚ÇÄ S) ‚Üî ‚àÄ s ‚àà S, Bornology.IsBounded s)
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type i ‚àà x_0 of Œª binder contains bound variables

Testing || iSup_eq_iSup_finset' : ‚àÄ {Œ± : Type u_2} {Œπ' : Sort u_7} [inst : CompleteLattice Œ±] (s : Œπ' ‚Üí Œ±), ‚®Ü i, s i = ‚®Ü t, ‚®Ü i ‚àà t, s i.down
Result.exception ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Œπ_| is 1
; rep: (as @|_Œπ_|_0 |_Œπ_|)
; cardinality of |_Œ±| is 2
; rep: (as @|_Œ±|_0 |_Œ±|)
; rep: (as @|_Œ±|_1 |_Œ±|)
(define-fun ___i__s_i () |_Œ±| (as @|_Œ±|_0 |_Œ±|))
(define-fun ___t____i___t____i_1___i____i___i_1____i_2___i____i___i_2____i_3___i____i___i_3____i_4___i____i___i_4__s_i.down () |_Œ±| (as @|_Œ±|_1 |_Œ±|))
)


Testing || Nat.le_add_one_of_avg_eq_left : ‚àÄ {a b : ‚Ñï}, a.avg b = a ‚Üí b ‚â§ a + 1
Result.success

Testing || LieModule.ofAssociativeModule : ‚àÄ {A : Type v} [inst : Ring A] {R : Type u} [inst_1 : CommRing R] [inst_2 : Algebra R A] {M : Type w}
  [inst_3 : AddCommGroup M] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module A M] [inst_6 : IsScalarTower R A M],
  LieModule R A M
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instHSMul`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || LinearMap.ker_noncommProd_eq_of_supIndep_ker : ‚àÄ {K : Type u} {V : Type v} [inst : DivisionRing K] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module K V]
  [inst_3 : FiniteDimensional K V] {Œπ : Type u_1} {f : Œπ ‚Üí V ‚Üí‚Çó[K] V} (s : Finset Œπ)
  (comm : (‚Üës).Pairwise (Commute on f)),
  (s.SupIndep fun i => LinearMap.ker (f i)) ‚Üí LinearMap.ker (s.noncommProd f comm) = ‚®Ü i ‚àà s, LinearMap.ker (f i)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `LinearMap.instFunLike`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AddSubgroup.coe_center : ‚àÄ (G : Type u_1) [inst : AddGroup G], ‚Üë(AddSubgroup.center G) = Set.addCenter G
Result.success

Testing || NonUnitalSubalgebra.toNonUnitalSubsemiring_injective : ‚àÄ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : NonUnitalNonAssocSemiring A] [inst_2 : _root_.Module R A],
  Function.Injective NonUnitalSubalgebra.toNonUnitalSubsemiring
Result.exception ::
Auto failed to find proof

Testing || CochainComplex.HomComplex.Cochain.ext‚ÇÄ : ‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C]
  {F G : CochainComplex C ‚Ñ§} (z‚ÇÅ z‚ÇÇ : CochainComplex.HomComplex.Cochain F G 0),
  (‚àÄ (p : ‚Ñ§), z‚ÇÅ.v p p ‚ãØ = z‚ÇÇ.v p p ‚ãØ) ‚Üí z‚ÇÅ = z‚ÇÇ
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `add_zero x_0`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Multiset.mem_of_mem_nsmul : ‚àÄ {Œ± : Type u_1} {a : Œ±} {s : Multiset Œ±} {n : ‚Ñï}, a ‚àà n ‚Ä¢ s ‚Üí a ‚àà s
Result.exception ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || CategoryTheory.StructuredArrow.IsUniversal.fac_assoc : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D]
  {S : D} {T : CategoryTheory.Functor C D} {f : CategoryTheory.StructuredArrow S T} (h : f.IsUniversal)
  (g : CategoryTheory.StructuredArrow S T) {Z : D} (h_1 : T.obj g.right ‚ü∂ Z),
  CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.CategoryStruct.comp (T.map (h.desc g)) h_1) =
    CategoryTheory.CategoryStruct.comp g.hom h_1
Result.exception ::
Auto failed to find proof

Testing || ContractingWith.fixedPoint_lipschitz_in_map : ‚àÄ {Œ± : Type u_1} [inst : MetricSpace Œ±] {K : NNReal} {f : Œ± ‚Üí Œ±} (hf : ContractingWith K f) [inst_1 : Nonempty Œ±]
  [inst_2 : CompleteSpace Œ±] {g : Œ± ‚Üí Œ±} (hg : ContractingWith K g) {C : ‚Ñù},
  (‚àÄ (z : Œ±), dist (f z) (g z) ‚â§ C) ‚Üí
    dist (ContractingWith.fixedPoint f hf) (ContractingWith.fixedPoint g hg) ‚â§ C / (1 - ‚ÜëK)
Result.exception ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || CategoryTheory.Functor.closedSieves_obj : ‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (J‚ÇÅ : CategoryTheory.GrothendieckTopology C) (X : C·µí·µñ),
  (CategoryTheory.Functor.closedSieves J‚ÇÅ).obj X = { S // J‚ÇÅ.IsClosed S }
Result.success

Testing || MeasureTheory.Measure.haar.le_index_mul : ‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : TopologicalSpace G] [inst_2 : TopologicalGroup G]
  (K‚ÇÄ : TopologicalSpace.PositiveCompacts G) (K : TopologicalSpace.Compacts G) {V : Set G},
  (interior V).Nonempty ‚Üí
    MeasureTheory.Measure.haar.index (‚ÜëK) V ‚â§
      MeasureTheory.Measure.haar.index ‚ÜëK ‚ÜëK‚ÇÄ * MeasureTheory.Measure.haar.index (‚ÜëK‚ÇÄ) V
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type g ‚àà t of Œª binder contains bound variables

Testing || MvPolynomial.mapAlgEquiv_refl : ‚àÄ {R : Type u} (œÉ : Type u_1) [inst : CommSemiring R] {A‚ÇÅ : Type u_2} [inst_1 : CommSemiring A‚ÇÅ]
  [inst_2 : Algebra R A‚ÇÅ], MvPolynomial.mapAlgEquiv œÉ AlgEquiv.refl = AlgEquiv.refl
Result.exception ::
Auto failed to find proof

Testing || PartialHomeomorph.MDifferentiable.mfderiv_bijective : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ùïú E H} {M : Type u_4}
  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] {E' : Type u_5} [inst_6 : NormedAddCommGroup E']
  [inst_7 : NormedSpace ùïú E'] {H' : Type u_6} [inst_8 : TopologicalSpace H'] {I' : ModelWithCorners ùïú E' H'}
  {M' : Type u_7} [inst_9 : TopologicalSpace M'] [inst_10 : ChartedSpace H' M'] {e : PartialHomeomorph M M'},
  PartialHomeomorph.MDifferentiable I I' e ‚Üí ‚àÄ {x : M}, x ‚àà e.source ‚Üí Function.Bijective ‚áë(mfderiv I I' (‚Üëe) x)
Result.exception ::
Auto failed to find proof

Testing || List.prod_ne_zero : ‚àÄ {M‚ÇÄ : Type u_4} [inst : MonoidWithZero M‚ÇÄ] {l : List M‚ÇÄ} [inst_1 : Nontrivial M‚ÇÄ] [inst_2 : NoZeroDivisors M‚ÇÄ],
  0 ‚àâ l ‚Üí l.prod ‚â† 0
Result.success

Testing || Ring.ne_bot_of_isMaximal_of_not_isField : ‚àÄ {R : Type u_1} [inst : CommSemiring R] [inst_1 : Nontrivial R] {M : Ideal R}, M.IsMaximal ‚Üí ¬¨IsField R ‚Üí M ‚â† ‚ä•
Result.exception ::
Auto failed to find proof

Testing || MonovaryOn.pow_left : ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : OrderedCommGroup Œ±] [inst_1 : OrderedCommGroup Œ≤] {s : Set Œπ}
  {f : Œπ ‚Üí Œ±} {g : Œπ ‚Üí Œ≤}, MonovaryOn f g s ‚Üí ‚àÄ (n : ‚Ñï), MonovaryOn (f ^ n) g s
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_7 i‚úù ‚â§ cifvar_7 i‚úù`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Complex.arg_coe_angle_eq_iff : ‚àÄ {x y : ‚ÑÇ}, ‚Üëx.arg = ‚Üëy.arg ‚Üî x.arg = y.arg
Result.success

Testing || Dynamics.dynEntourage_monotone : ‚àÄ {X : Type u_1} (T : X ‚Üí X) (n : ‚Ñï), Monotone fun U => Dynamics.dynEntourage T U n
Result.exception ::
Auto failed to find proof

Testing || HomologicalComplex.cycles_left_exact : ‚àÄ {C : Type u_1} {Œπ : Type u_2} [inst : CategoryTheory.Category.{u_3, u_1} C] [inst_1 : CategoryTheory.Abelian C]
  {c : ComplexShape Œπ} (S : CategoryTheory.ShortComplex (HomologicalComplex C c)),
  S.Exact ‚Üí
    ‚àÄ [inst_2 : CategoryTheory.Mono S.f] (i : Œπ) [inst_3 : S.X‚ÇÅ.HasHomology i] [inst_4 : S.X‚ÇÇ.HasHomology i]
      [inst_5 : S.X‚ÇÉ.HasHomology i],
      (CategoryTheory.ShortComplex.mk (HomologicalComplex.cyclesMap S.f i) (HomologicalComplex.cyclesMap S.g i) ‚ãØ).Exact
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `HomologicalComplex.instCategory`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || instHasFiniteLimitsLightCondMod : ‚àÄ (R : Type u) [inst : Ring R], CategoryTheory.Limits.HasFiniteLimits (LightCondMod R)
Result.success

Testing || List.getLast?_drop : ‚àÄ {Œ± : Type u_1} {n : ‚Ñï} {l : List Œ±}, (List.drop n l).getLast? = if l.length ‚â§ n then none else l.getLast?
Result.exception ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || AddGroup.fintypeOfKerEqRange.proof_1 : ‚àÄ {F G H : Type u_1} [inst : AddGroup F] [inst_1 : AddGroup G] [inst_2 : AddGroup H] (f : F ‚Üí+ G) (g : G ‚Üí+ H),
  g.ker = f.range ‚Üí g.ker ‚â§ f.range
Result.success

Testing || List.dedup_cons_of_mem' : ‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {a : Œ±} {l : List Œ±}, a ‚àà l.dedup ‚Üí (a :: l).dedup = l.dedup
Result.success

Testing || stronglyMeasurable_bot_iff : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} [inst : TopologicalSpace Œ≤] [inst_1 : Nonempty Œ≤] [inst_2 : T2Space Œ≤],
  MeasureTheory.StronglyMeasurable f ‚Üî ‚àÉ c, f = fun x => c
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_7 = fun x => c`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || PrimeSpectrum.vanishingIdeal_anti_mono : ‚àÄ {R : Type u} [inst : CommSemiring R] {s t : Set (PrimeSpectrum R)},
  s ‚äÜ t ‚Üí PrimeSpectrum.vanishingIdeal t ‚â§ PrimeSpectrum.vanishingIdeal s
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In Œ± ‚Üí
  Prop, type of ‚àÄ bound variable is not of sort `Prop`, and depends on bound variables

Testing || IsFractionRing.isDomain : ‚àÄ (A : Type u_4) [inst : CommRing A] {K : Type u_5} [inst_1 : CommRing K] [inst_2 : Algebra A K]
  [inst_3 : IsFractionRing A K] [inst : IsDomain A], IsDomain K
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `IsLocalization x_2 cifvar_11`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Finset.inj_on_of_surj_on_of_card_le : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Finset Œ±} {t : Finset Œ≤} (f : (a : Œ±) ‚Üí a ‚àà s ‚Üí Œ≤),
  (‚àÄ (a : Œ±) (ha : a ‚àà s), f a ha ‚àà t) ‚Üí
    (‚àÄ b ‚àà t, ‚àÉ a, ‚àÉ (ha : a ‚àà s), f a ha = b) ‚Üí
      s.card ‚â§ t.card ‚Üí ‚àÄ ‚¶Éa‚ÇÅ : Œ±‚¶Ñ (ha‚ÇÅ : a‚ÇÅ ‚àà s) ‚¶Éa‚ÇÇ : Œ±‚¶Ñ (ha‚ÇÇ : a‚ÇÇ ‚àà s), f a‚ÇÅ ha‚ÇÅ = f a‚ÇÇ ha‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a ‚àà s of Œª binder contains bound variables

Testing || CategoryTheory.Pretriangulated.productTriangle_obj‚ÇÅ : ‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.HasShift C ‚Ñ§] {J : Type u_1}
  (T : J ‚Üí CategoryTheory.Pretriangulated.Triangle C) [inst_2 : CategoryTheory.Limits.HasProduct fun j => (T j).obj‚ÇÅ]
  [inst_3 : CategoryTheory.Limits.HasProduct fun j => (T j).obj‚ÇÇ]
  [inst_4 : CategoryTheory.Limits.HasProduct fun j => (T j).obj‚ÇÉ]
  [inst_5 : CategoryTheory.Limits.HasProduct fun j => (CategoryTheory.shiftFunctor C 1).obj (T j).obj‚ÇÅ],
  (CategoryTheory.Pretriangulated.productTriangle T).obj‚ÇÅ = ‚àè·∂ú fun j => (T j).obj‚ÇÅ
Result.success

Testing || lt_div_iff_of_neg' : ‚àÄ {Œ± : Type u_2} [inst : LinearOrderedField Œ±] {a b c : Œ±}, c < 0 ‚Üí (a < b / c ‚Üî b < c * a)
Result.success

Testing || CochainComplex.mappingCone.inr_f_descCochain_v : ‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_3, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  {F G : CochainComplex C ‚Ñ§} (œÜ : F ‚ü∂ G) [inst_2 : HomologicalComplex.HasHomotopyCofiber œÜ] {K : CochainComplex C ‚Ñ§}
  {n m : ‚Ñ§} (Œ± : CochainComplex.HomComplex.Cochain F K m) (Œ≤ : CochainComplex.HomComplex.Cochain G K n) (h : m + 1 = n)
  (p‚ÇÅ p‚ÇÇ : ‚Ñ§) (h‚ÇÅ‚ÇÇ : p‚ÇÅ + n = p‚ÇÇ),
  CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr œÜ).f p‚ÇÅ)
      ((CochainComplex.mappingCone.descCochain œÜ Œ± Œ≤ h).v p‚ÇÅ p‚ÇÇ h‚ÇÅ‚ÇÇ) =
    Œ≤.v p‚ÇÅ p‚ÇÇ h‚ÇÅ‚ÇÇ
Result.exception ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || Cubic.natDegree_of_c_ne_zero : ‚àÄ {R : Type u_1} {P : Cubic R} [inst : Semiring R], P.a = 0 ‚Üí P.b = 0 ‚Üí P.c ‚â† 0 ‚Üí P.toPoly.natDegree = 1
Result.success

Testing || Unitization.norm_splitMul_snd_sq : ‚àÄ (ùïú : Type u_1) {E : Type u_2} [inst : DenselyNormedField ùïú] [inst_1 : NonUnitalNormedRing E] [inst_2 : StarRing E]
  [inst_3 : CStarRing E] [inst_4 : NormedSpace ùïú E] [inst_5 : IsScalarTower ùïú E E] [inst_6 : SMulCommClass ùïú E E]
  [inst_7 : StarRing ùïú] [inst_8 : StarModule ùïú E] (x : Unitization ùïú E),
  ‚Äñ((Unitization.splitMul ùïú E) x).2‚Äñ ^ 2 ‚â§ ‚Äñ((Unitization.splitMul ùïú E) (star x * x)).2‚Äñ
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || LinearMap.BilinForm.linMulLin_compLeft : ‚àÄ {R : Type u_1} {M : Type u_2} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : _root_.Module R M]
  {f g : M ‚Üí‚Çó[R] R} (l : M ‚Üí‚Çó[R] M),
  (LinearMap.BilinForm.linMulLin f g).compLeft l = LinearMap.BilinForm.linMulLin (f ‚àò‚Çó l) g
Result.success

Testing || CategoryTheory.MorphismProperty.Comma.mapRight_obj_hom : ‚àÄ {A : Type u_1} [inst : CategoryTheory.Category.{u_4, u_1} A] {B : Type u_2}
  [inst_1 : CategoryTheory.Category.{u_5, u_2} B] {T : Type u_3} [inst_2 : CategoryTheory.Category.{u_6, u_3} T]
  (L : CategoryTheory.Functor A T) {P : CategoryTheory.MorphismProperty T} {Q : CategoryTheory.MorphismProperty A}
  {W : CategoryTheory.MorphismProperty B} [inst_3 : Q.IsMultiplicative] [inst_4 : W.IsMultiplicative]
  {R‚ÇÅ R‚ÇÇ : CategoryTheory.Functor B T} (r : R‚ÇÅ ‚ü∂ R‚ÇÇ)
  (hr :
    ‚àÄ (X : CategoryTheory.MorphismProperty.Comma L R‚ÇÅ P Q W),
      P (CategoryTheory.CategoryStruct.comp X.hom (r.app X.right)))
  (X : CategoryTheory.MorphismProperty.Comma L R‚ÇÅ P Q W),
  ((CategoryTheory.MorphismProperty.Comma.mapRight L r hr).obj X).hom =
    CategoryTheory.CategoryStruct.comp X.hom (r.app X.right)
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.MorphismProperty T is not a `‚àÄ`

Testing || IsPrimitiveRoot.ne_zero : ‚àÄ {k : ‚Ñï} {M‚ÇÄ : Type u_7} [inst : CommMonoidWithZero M‚ÇÄ] [inst_1 : Nontrivial M‚ÇÄ] {Œ∂ : M‚ÇÄ},
  IsPrimitiveRoot Œ∂ k ‚Üí k ‚â† 0 ‚Üí Œ∂ ‚â† 0
Result.success

Testing || _private.Mathlib.Topology.MetricSpace.Gluing.0.Metric.eq_of_glueDist_eq_zero : ‚àÄ {X : Type u} {Y : Type v} {Z : Type w} [inst : MetricSpace X] [inst_1 : MetricSpace Y] (Œ¶ : Z ‚Üí X) (Œ® : Z ‚Üí Y)
  (Œµ : ‚Ñù), 0 < Œµ ‚Üí ‚àÄ (p q : X ‚äï Y), Metric.glueDist Œ¶ Œ® Œµ p q = 0 ‚Üí p = q
Result.exception ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || WeierstrassCurve.Affine.eval_negPolynomial : ‚àÄ {R : Type u} [inst : CommRing R] (W : WeierstrassCurve.Affine R) (x y : R),
  Polynomial.evalEval x y W.negPolynomial = W.negY x y
Result.success

Testing || Rat.cast_lt_zero : ‚àÄ {q : ‚Ñö} {K : Type u_5} [inst : LinearOrderedField K], ‚Üëq < 0 ‚Üî q < 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Rat.ofInt.proof_2 num`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CompositionAsSet.card_boundaries_eq_succ_length : ‚àÄ {n : ‚Ñï} (c : CompositionAsSet n), c.boundaries.card = c.length + 1
Result.success

Testing || Finset.prod_le_one' : ‚àÄ {Œπ : Type u_1} {N : Type u_5} [inst : OrderedCommMonoid N] {f : Œπ ‚Üí N} {s : Finset Œπ},
  (‚àÄ i ‚àà s, f i ‚â§ 1) ‚Üí ‚àè i ‚àà s, f i ‚â§ 1
Result.exception ::
Auto failed to find proof

Testing || SlashInvariantForm.coeHom_injective : ‚àÄ {Œì : Subgroup (Matrix.SpecialLinearGroup (Fin 2) ‚Ñ§)} {k : ‚Ñ§}, Function.Injective ‚áëSlashInvariantForm.coeHom
Result.success

Testing || CategoryTheory.StructuredArrow.toUnder_obj_left : ‚àÄ {T : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} T] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D]
  (X : T) (F : CategoryTheory.Functor D T)
  (X_1 : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit X) (F.comp (CategoryTheory.Functor.id T))),
  ((CategoryTheory.StructuredArrow.toUnder X F).obj X_1).left = X_1.left
Result.success

Testing || ContinuousWithinAt.mono_of_mem_nhdsWithin : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s t : Set Œ±}
  {x : Œ±}, ContinuousWithinAt f t x ‚Üí t ‚àà nhdsWithin x s ‚Üí ContinuousWithinAt f s x
Result.success

Testing || AddSubmonoid.closure_singleton_le_iff_mem : ‚àÄ {M : Type u_1} [inst : AddZeroClass M] (m : M) (p : AddSubmonoid M), AddSubmonoid.closure {m} ‚â§ p ‚Üî m ‚àà p
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!11 (!0 (!1 (!2 !3))) !4) = (!0 (!1 (!2 !3)) !4)) is not type correct

Testing || Set.biUnion_of_singleton : ‚àÄ {Œ± : Type u_1} (s : Set Œ±), ‚ãÉ x ‚àà s, {x} = s
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type i ‚àà s of Œª binder contains bound variables

Testing || ULift.down_ratCast : ‚àÄ {Œ± : Type u} [inst : RatCast Œ±] (q : ‚Ñö), (‚Üëq).down = ‚Üëq
Result.success

Testing || Set.smul_set_eq_empty : ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : SMul Œ± Œ≤] {s : Set Œ≤} {a : Œ±}, a ‚Ä¢ s = ‚àÖ ‚Üî s = ‚àÖ
Result.success

Testing || MeasurableSet.coe_sdiff : ‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] (s t : Subtype MeasurableSet), ‚Üë(s \ t) = ‚Üës \ ‚Üët
Result.success

Testing || Matrix.charpoly_fromBlocks_zero‚ÇÅ‚ÇÇ : ‚àÄ {R : Type u_1} [inst : CommRing R] {m : Type u_3} {n : Type u_4} [inst_1 : DecidableEq m] [inst_2 : DecidableEq n]
  [inst_3 : Fintype m] [inst_4 : Fintype n] (M‚ÇÅ‚ÇÅ : Matrix m m R) (M‚ÇÇ‚ÇÅ : Matrix n m R) (M‚ÇÇ‚ÇÇ : Matrix n n R),
  (Matrix.fromBlocks M‚ÇÅ‚ÇÅ 0 M‚ÇÇ‚ÇÅ M‚ÇÇ‚ÇÇ).charpoly = M‚ÇÅ‚ÇÅ.charpoly * M‚ÇÇ‚ÇÇ.charpoly
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_55
  (cifvar_3 x_0 cifvar_5 x_1 x_2)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Limits.PullbackCone.IsLimit.equivPullbackObj_symm_apply_fst : ‚àÄ {X Y S : Type v} {f : X ‚ü∂ S} {g : Y ‚ü∂ S} {c : CategoryTheory.Limits.PullbackCone f g}
  (hc : CategoryTheory.Limits.IsLimit c) (x : CategoryTheory.Limits.Types.PullbackObj f g),
  c.fst ((CategoryTheory.Limits.PullbackCone.IsLimit.equivPullbackObj hc).symm x) = (‚Üëx).1
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: X ‚ü∂ S is not a `‚àÄ`

Testing || IsLocalization.isAlgebraic : ‚àÄ {R : Type u} (S : Type u_1) [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : Algebra R S] [inst_3 : Nontrivial R]
  (M : Submonoid R) [inst_4 : IsLocalization M S], Algebra.IsAlgebraic R S
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `{ x // cifvar_7 x_0 x }`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Finset.addEnergy_eq_sum_sq' : ‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Add Œ±] (s t : Finset Œ±),
  s.addEnergy t =
    ‚àë a ‚àà s + t,
      (Finset.filter
            (fun x =>
              match x with
              | (x, y) => x + y = a)
            (s √óÀ¢ t)).card ^
        2
Result.exception ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || AddMonoidHom.addCommMonoid.proof_1 : ‚àÄ {M : Type u_1} {N : Type u_2} [inst : AddZeroClass M] [inst_1 : AddCommMonoid N] (a b c : M ‚Üí+ N),
  a + b + c = a + (b + c)
Result.success

Testing || ContinuousLinearEquiv.symm_trans_apply : ‚àÄ {R‚ÇÅ : Type u_3} {R‚ÇÇ : Type u_4} {R‚ÇÉ : Type u_5} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] [inst_2 : Semiring R‚ÇÉ]
  {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {œÉ‚ÇÇ‚ÇÅ : R‚ÇÇ ‚Üí+* R‚ÇÅ} [inst_3 : RingHomInvPair œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÅ] [inst_4 : RingHomInvPair œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÅ‚ÇÇ]
  {œÉ‚ÇÇ‚ÇÉ : R‚ÇÇ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÉ‚ÇÇ : R‚ÇÉ ‚Üí+* R‚ÇÇ} [inst_5 : RingHomInvPair œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÉ‚ÇÇ] [inst_6 : RingHomInvPair œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÇ‚ÇÉ]
  {œÉ‚ÇÅ‚ÇÉ : R‚ÇÅ ‚Üí+* R‚ÇÉ} {œÉ‚ÇÉ‚ÇÅ : R‚ÇÉ ‚Üí+* R‚ÇÅ} [inst_7 : RingHomInvPair œÉ‚ÇÅ‚ÇÉ œÉ‚ÇÉ‚ÇÅ] [inst_8 : RingHomInvPair œÉ‚ÇÉ‚ÇÅ œÉ‚ÇÅ‚ÇÉ]
  [inst_9 : RingHomCompTriple œÉ‚ÇÅ‚ÇÇ œÉ‚ÇÇ‚ÇÉ œÉ‚ÇÅ‚ÇÉ] [inst_10 : RingHomCompTriple œÉ‚ÇÉ‚ÇÇ œÉ‚ÇÇ‚ÇÅ œÉ‚ÇÉ‚ÇÅ] {M‚ÇÅ : Type u_6}
  [inst_11 : TopologicalSpace M‚ÇÅ] [inst_12 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_7} [inst_13 : TopologicalSpace M‚ÇÇ]
  [inst_14 : AddCommMonoid M‚ÇÇ] {M‚ÇÉ : Type u_8} [inst_15 : TopologicalSpace M‚ÇÉ] [inst_16 : AddCommMonoid M‚ÇÉ]
  [inst_17 : _root_.Module R‚ÇÅ M‚ÇÅ] [inst_18 : _root_.Module R‚ÇÇ M‚ÇÇ] [inst_19 : _root_.Module R‚ÇÉ M‚ÇÉ] (e‚ÇÅ : M‚ÇÇ ‚âÉSL[œÉ‚ÇÇ‚ÇÅ] M‚ÇÅ)
  (e‚ÇÇ : M‚ÇÉ ‚âÉSL[œÉ‚ÇÉ‚ÇÇ] M‚ÇÇ) (c : M‚ÇÅ), (e‚ÇÇ.trans e‚ÇÅ).symm c = e‚ÇÇ.symm (e‚ÇÅ.symm c)
Result.success

Testing || CategoryTheory.Coverage.eq_top_pullback : ‚àÄ {C : Type u_2} [inst : CategoryTheory.Category.{u_1, u_2} C] {X Y : C} {S T : CategoryTheory.Sieve X},
  S ‚â§ T ‚Üí ‚àÄ (f : Y ‚ü∂ X), S.arrows f ‚Üí CategoryTheory.Sieve.pullback f T = ‚ä§
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.Presieve X is not a `‚àÄ`

Testing || TopCat.stalkToFiber_injective : ‚àÄ {X : TopCat} {T : ‚ÜëX ‚Üí Type v} (P : TopCat.LocalPredicate T) (x : ‚ÜëX),
  (‚àÄ (U V : TopologicalSpace.OpenNhds x) (fU : (y : ‚Ü•U.obj) ‚Üí T ‚Üëy),
      P.pred fU ‚Üí
        ‚àÄ (fV : (y : ‚Ü•V.obj) ‚Üí T ‚Üëy),
          P.pred fV ‚Üí
            fU ‚ü®x, ‚ãØ‚ü© = fV ‚ü®x, ‚ãØ‚ü© ‚Üí
              ‚àÉ W iU iV, ‚àÄ (w : ‚Ü•W.obj), fU ((fun x_4 => ‚ü®‚Üëx_4, ‚ãØ‚ü©) w) = fV ((fun x_4 => ‚ü®‚Üëx_4, ‚ãØ‚ü©) w)) ‚Üí
    Function.Injective (TopCat.stalkToFiber P x)
Result.exception ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Complex.equivRealProdCLM_symm_apply : ‚àÄ (p : ‚Ñù √ó ‚Ñù), Complex.equivRealProdCLM.symm p = ‚Üëp.1 + ‚Üëp.2 * Complex.I
Result.success

Testing || tendstoLocallyUniformlyOn_TFAE : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œπ : Type x} [inst : UniformSpace Œ≤] {s : Set Œ±} [inst_1 : TopologicalSpace Œ±]
  [inst_2 : LocallyCompactSpace Œ±] (G : Œπ ‚Üí Œ± ‚Üí Œ≤) (g : Œ± ‚Üí Œ≤) (p : Filter Œπ),
  IsOpen s ‚Üí
    [TendstoLocallyUniformlyOn G g p s, ‚àÄ K ‚äÜ s, IsCompact K ‚Üí TendstoUniformlyOn G g p K,
        ‚àÄ x ‚àà s, ‚àÉ v ‚àà nhdsWithin x s, TendstoUniformlyOn G g p v].TFAE
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_23 x_0).HasBasis
  (fun s => cifvar_13 (cifvar_14 (cifvar_23 x_0) s) (cifvar_9 s)) fun s => s`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || nhdsWithin_Ici_neBot : ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : Preorder Œ±] {a b : Œ±}, a ‚â§ b ‚Üí (nhdsWithin b (Set.Ici a)).NeBot
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!6 (!0 !1) !2) = (!0 !1 !2)) is not type correct

Testing || Multiset.Nat.antidiagonalTuple_zero_right : ‚àÄ (k : ‚Ñï), Multiset.Nat.antidiagonalTuple k 0 = {0}
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: In Fin x_0 ‚Üí
  ‚Ñï, type of ‚àÄ bound variable is not of sort `Prop`, and depends on bound variables

Testing || Part.instLawfulMonad : LawfulMonad Part
Result.exception ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x_1 of Œª binder contains bound variables

Testing || List.naturality : ‚àÄ {F G : Type u ‚Üí Type u} [inst : Applicative F] [inst_1 : Applicative G] [inst_2 : LawfulApplicative G]
  [inst_3 : LawfulApplicative F] (Œ∑ : ApplicativeTransformation F G) {Œ± : Type u_1} {Œ≤ : Type u} (f : Œ± ‚Üí F Œ≤)
  (x : List Œ±), (fun {Œ±} => Œ∑.app Œ±) (List.traverse f x) = List.traverse ((fun {Œ±} => Œ∑.app Œ±) ‚àò f) x
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `x_1 <*> x_2`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.instIsSplitMonoComp : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z}
  [hf : CategoryTheory.IsSplitMono f] [hg : CategoryTheory.IsSplitMono g],
  CategoryTheory.IsSplitMono (CategoryTheory.CategoryStruct.comp f g)
Result.exception ::
Auto failed to find proof

Testing || CategoryTheory.ShortComplex.leftHomologyFunctor_additive : ‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  [inst_2 : CategoryTheory.Limits.HasKernels C] [inst_3 : CategoryTheory.Limits.HasCokernels C],
  (CategoryTheory.ShortComplex.leftHomologyFunctor C).Additive
Result.exception ::
Auto failed to find proof

Testing || MvPowerSeries.coeff_eq_zero_of_lt_lexOrder : ‚àÄ {œÉ : Type u_1} {R : Type u_2} [inst : Semiring R] [inst_1 : LinearOrder œÉ] [inst_2 : WellFoundedGT œÉ]
  {œÜ : MvPowerSeries œÉ R} {d : œÉ ‚Üí‚ÇÄ ‚Ñï}, ‚Üë(toLex d) < œÜ.lexOrder ‚Üí (MvPowerSeries.coeff R d) œÜ = 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `LinearMap.instFunLike`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || ULift.addRightCancelMonoid.proof_1 : ‚àÄ {Œ± : Type u_1}, Function.Injective ‚áëEquiv.ulift
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Function.Injective (cifvar_4 x_0)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || instHasCountableSeparatingOnIsOpenOfT0SpaceOfSecondCountableTopologyElem : ‚àÄ {X : Type u_1} [inst : TopologicalSpace X] {s : Set X} [inst_1 : T0Space ‚Üës] [inst_2 : SecondCountableTopology ‚Üës],
  HasCountableSeparatingOn X IsOpen s
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!12 !25 !26) = !0) is not type correct

Testing || CategoryTheory.Functor.lanCompColimIso_hom_app : ‚àÄ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_4, u_1} C]
  [inst_1 : CategoryTheory.Category.{u_5, u_2} D] (L : CategoryTheory.Functor C D) {H : Type u_3}
  [inst_2 : CategoryTheory.Category.{u_6, u_3} H] [inst_3 : ‚àÄ (F : CategoryTheory.Functor C H), L.HasLeftKanExtension F]
  [inst_4 : CategoryTheory.Limits.HasColimitsOfShape C H] [inst_5 : CategoryTheory.Limits.HasColimitsOfShape D H]
  (X : CategoryTheory.Functor C H),
  L.lanCompColimIso.hom.app X = ((L.lan.obj X).colimitIsoOfIsLeftKanExtension (L.lanUnit.app X)).hom
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.instCategoryStructuredArrow
  x_0 (cifvar_3 (cifvar_4 cifvar_5) cifvar_6)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MeasureTheory.exists_upperSemicontinuous_le_integral_le : ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : MeasurableSpace Œ±] [inst_2 : BorelSpace Œ±]
  {Œº : MeasureTheory.Measure Œ±} [inst_3 : Œº.WeaklyRegular] (f : Œ± ‚Üí NNReal),
  MeasureTheory.Integrable (fun x => ‚Üë(f x)) Œº ‚Üí
    ‚àÄ {Œµ : ‚Ñù},
      0 < Œµ ‚Üí
        ‚àÉ g,
          (‚àÄ (x : Œ±), g x ‚â§ f x) ‚àß
            UpperSemicontinuous g ‚àß
              MeasureTheory.Integrable (fun x => ‚Üë(g x)) Œº ‚àß ‚à´ (x : Œ±), ‚Üë(f x) ‚àÇŒº - Œµ ‚â§ ‚à´ (x : Œ±), ‚Üë(g x) ‚àÇŒº
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `UpperSemicontinuous g`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || pathConnectedSpace_iff_univ : ‚àÄ {X : Type u_1} [inst : TopologicalSpace X], PathConnectedSpace X ‚Üî IsPathConnected Set.univ
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm ((!11 !18 !14) = !0) is not type correct

Testing || Ordinal.derivFamily_isNormal : ‚àÄ {Œπ : Type u_1} [inst : Small.{u, u_1} Œπ] (f : Œπ ‚Üí Ordinal.{u} ‚Üí Ordinal.{u}), Ordinal.IsNormal (Ordinal.derivFamily f)
Result.success

Testing || CochainComplex.mappingCone.inr_f_d : ‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_3, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  {F G : CochainComplex C ‚Ñ§} (œÜ : F ‚ü∂ G) [inst_2 : HomologicalComplex.HasHomotopyCofiber œÜ] (n‚ÇÅ n‚ÇÇ : ‚Ñ§),
  CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr œÜ).f n‚ÇÅ)
      ((CochainComplex.mappingCone œÜ).d n‚ÇÅ n‚ÇÇ) =
    CategoryTheory.CategoryStruct.comp (G.d n‚ÇÅ n‚ÇÇ) ((CochainComplex.mappingCone.inr œÜ).f n‚ÇÇ)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_16.d cifvar_15 x_1`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AddMonoidHom.isCentralScalar : ‚àÄ {R : Type u_1} {A : Type u_4} {B : Type u_5} [inst : Monoid R] [inst_1 : AddMonoid A] [inst_2 : AddCommMonoid B]
  [inst_3 : DistribMulAction R B] [inst_4 : DistribMulAction R·µê·µí·µñ B] [inst_5 : IsCentralScalar R B],
  IsCentralScalar R (A ‚Üí+ B)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `instHSMul`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.prod_preservesConnectedLimits : ‚àÄ {C : Type u‚ÇÇ} [inst : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} C] [inst_1 : CategoryTheory.Limits.HasBinaryProducts C]
  {J : Type v‚ÇÇ} [inst_2 : CategoryTheory.SmallCategory J] [inst_3 : CategoryTheory.IsConnected J] (X : C),
  CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.Limits.prod.functor.obj X)
Result.exception ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || CategoryTheory.Limits.reflectsLimit_of_reflectsIsomorphisms : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D]
  {J : Type w} [inst_2 : CategoryTheory.Category.{w', w} J] (F : CategoryTheory.Functor J C)
  (G : CategoryTheory.Functor C D) [inst_3 : G.ReflectsIsomorphisms] [inst_4 : CategoryTheory.Limits.HasLimit F]
  [inst_5 : CategoryTheory.Limits.PreservesLimit F G], CategoryTheory.Limits.ReflectsLimit F G
Result.exception ::
Auto failed to find proof

Testing || BialgHom.coe_coe : ‚àÄ {R : Type u_1} {A : Type u_2} {B : Type u_3} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]
  [inst_3 : Semiring B] [inst_4 : Algebra R B] [inst_5 : CoalgebraStruct R A] [inst_6 : CoalgebraStruct R B]
  {F : Type u_6} [inst_7 : FunLike F A B] [inst_8 : BialgHomClass F R A B] (f : F), ‚áë‚Üëf = ‚áëf
Result.exception ::
Auto failed to find proof

Testing || Int.div_def : ‚àÄ (a b : ‚Ñ§), a / b = a.ediv b
Result.success

Testing || Subgroup.center.smulCommClass_left : ‚àÄ {G : Type u_1} [inst : Group G], SMulCommClass (‚Ü•(Subgroup.center G)) G G
Result.success

Testing || Matrix.SpecialLinearGroup.coe_mul : ‚àÄ {n : Type u} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R]
  (A B : Matrix.SpecialLinearGroup n R), ‚Üë(A * B) = ‚ÜëA * ‚ÜëB
Result.success

Testing || IsMinFilter.undual : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Preorder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±} {a : Œ±},
  IsMinFilter (‚áëOrderDual.toDual ‚àò f) l a ‚Üí IsMaxFilter f l a
Result.success

Testing || Batteries.TransCmp.cmp_congr_left' : ‚àÄ {x : Sort u_1} {cmp : x ‚Üí x ‚Üí Ordering} [inst : Batteries.TransCmp cmp] {x_1 y : x},
  cmp x_1 y = Ordering.eq ‚Üí cmp x_1 = cmp y
Result.exception ::
Auto failed to find proof

Testing || CategoryTheory.Pi.sum_obj_obj : ‚àÄ {I : Type w‚ÇÄ} (C : I ‚Üí Type u‚ÇÅ) [inst : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)] {J : Type w‚ÇÄ}
  {D : J ‚Üí Type u‚ÇÅ} [inst_1 : (j : J) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (D j)] (X : (i : I) ‚Üí C i) (Y : (j : J) ‚Üí D j)
  (s : I ‚äï J),
  ((CategoryTheory.Pi.sum C).obj X).obj Y s =
    match s with
    | Sum.inl i => X i
    | Sum.inr j => Y j
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `X i`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.eraseP_cons : ‚àÄ {Œ± : Type u_1} {p : Œ± ‚Üí Bool} (a : Œ±) (l : List Œ±), List.eraseP p (a :: l) = bif p a then l else a :: List.eraseP p l
Result.exception ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
; cardinality of Empty is 1
; rep: (as @Empty_0 Empty)
; cardinality of |_Œ±| is 1
; rep: (as @|_Œ±|_0 |_Œ±|)
(define-fun _a () |_Œ±| (as @|_Œ±|_0 |_Œ±|))
(define-fun _l () |_List_Œ±| (_List.cons (as @|_Œ±|_1 |_Œ±|) _pl___))
(define-fun _List.eraseP_p ((_arg_1 |_List_Œ±|)) |_List_Œ±| (ite (= (_List.cons (as @|_Œ±|_0 |_Œ±|) (_List.cons (as @|_Œ±|_1 |_Œ±|) _pl___)) _arg_1) _pl___ (_List.cons (as @|_Œ±|_0 |_Œ±|) _pl___)))
(define-fun _p ((_arg_1 |_Œ±|)) Bool true)
)


Testing || Ordinal.sup_add_nat : ‚àÄ (o : Ordinal.{u_1}), (Ordinal.sup fun n => o + ‚Üën) = o + Ordinal.omega0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Ordinal.IsNormal fun x =>
  cifvar_3 x_0 x`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Square.fromArrowArrowFunctor_obj_f‚ÇÉ‚ÇÑ : ‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (f : CategoryTheory.Arrow (CategoryTheory.Arrow C)),
  (CategoryTheory.Square.fromArrowArrowFunctor.obj f).f‚ÇÉ‚ÇÑ = f.hom.right
Result.success

Testing || CategoryTheory.Pi.ext : ‚àÄ {I : Type w‚ÇÄ} (C : I ‚Üí Type u‚ÇÅ) [inst : (i : I) ‚Üí CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} (C i)] {X Y : (i : I) ‚Üí C i}
  {f g : X ‚ü∂ Y}, (‚àÄ (i : I), f i = g i) ‚Üí f = g
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: X ‚ü∂ Y is not a `‚àÄ`

Testing || AddSubgroup.op.proof_1 : ‚àÄ {G : Type u_1} [inst : AddGroup G] (H : AddSubgroup G) {a b : G·µÉ·µí·µñ},
  a ‚àà AddOpposite.unop ‚Åª¬π' ‚ÜëH ‚Üí b ‚àà AddOpposite.unop ‚Åª¬π' ‚ÜëH ‚Üí AddOpposite.unop b + AddOpposite.unop a ‚àà H
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (‚àÄ x0 : #1, (‚àÄ x1 : #1, ((!0 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || InnerProductGeometry.norm_add_sq_eq_norm_sq_add_norm_sq' : ‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] (x y : V),
  InnerProductGeometry.angle x y = Real.pi / 2 ‚Üí ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ = ‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ
Result.exception ::
Auto.LamReif.reifTermCheckType :: LamTerm (‚àÄ x0 : #0, (‚àÄ x1 : #0, ((!22 (x0 =) x1) = (x0 = x1)))) is not type correct

Testing || Polynomial.ofFinsupp_nsmul : ‚àÄ {R : Type u} [inst : Semiring R] (a : ‚Ñï) (b : AddMonoidAlgebra R ‚Ñï), { toFinsupp := a ‚Ä¢ b } = a ‚Ä¢ { toFinsupp := b }
Result.success

Testing || Finset.Colex.initSeg_nonempty : ‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {s : Finset Œ±} [inst_1 : Fintype Œ±], (Finset.Colex.initSeg s).Nonempty
Result.exception ::
Auto failed to find proof

Testing || Choose.choose_modEq_prod_range_choose : ‚àÄ {n k p : ‚Ñï} [inst : Fact (Nat.Prime p)] {a : ‚Ñï},
  n < p ^ a ‚Üí k < p ^ a ‚Üí ‚Üë(n.choose k) ‚â° ‚àè i ‚àà Finset.range a, ‚Üë((n / p ^ i % p).choose (k / p ^ i % p)) [ZMOD ‚Üëp]
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `‚àè i ‚àà cifvar_13 x_4,
  cifvar_11 (cifvar_18 (cifvar_16 x_0 (cifvar_5 x_2 i)) x_2) (cifvar_18 (cifvar_16 x_1 (cifvar_5 x_2 i)) x_2)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MeasureTheory.VectorMeasure.map_zero : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MeasurableSpace Œ±] [inst_1 : MeasurableSpace Œ≤] {M : Type u_3}
  [inst_2 : AddCommMonoid M] [inst_3 : TopologicalSpace M] (f : Œ± ‚Üí Œ≤), MeasureTheory.VectorMeasure.map 0 f = 0
Result.exception ::
Auto failed to find proof

Testing || Matrix.updateCol_submatrix_equiv : ‚àÄ {l : Type u_1} {m : Type u_2} {n : Type u_3} {o : Type u_4} {Œ± : Type v} [inst : DecidableEq o]
  [inst_1 : DecidableEq n] (A : Matrix m n Œ±) (j : o) (c : l ‚Üí Œ±) (e : l ‚âÉ m) (f : o ‚âÉ n),
  (A.submatrix ‚áëe ‚áëf).updateCol j c = (A.updateCol (f j) fun i => c (e.symm i)).submatrix ‚áëe ‚áëf
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix m n Œ± is not a `‚àÄ`

Testing || CategoryTheory.MonoidalCategory.pentagon_inv_hom_hom_hom_hom_assoc : ‚àÄ {C : Type u} [ùíû : CategoryTheory.Category.{v, u} C] [inst : CategoryTheory.MonoidalCategory C] {W X Y Z Z_1 : C}
  (h :
    CategoryTheory.MonoidalCategory.tensorObj W
        (CategoryTheory.MonoidalCategory.tensorObj X (CategoryTheory.MonoidalCategory.tensorObj Y Z)) ‚ü∂
      Z_1),
  CategoryTheory.CategoryStruct.comp
      (CategoryTheory.MonoidalCategory.whiskerRight (CategoryTheory.MonoidalCategory.associator W X Y).inv Z)
      (CategoryTheory.CategoryStruct.comp
        (CategoryTheory.MonoidalCategory.associator (CategoryTheory.MonoidalCategory.tensorObj W X) Y Z).hom
        (CategoryTheory.CategoryStruct.comp
          (CategoryTheory.MonoidalCategory.associator W X (CategoryTheory.MonoidalCategory.tensorObj Y Z)).hom h)) =
    CategoryTheory.CategoryStruct.comp
      (CategoryTheory.MonoidalCategory.associator W (CategoryTheory.MonoidalCategory.tensorObj X Y) Z).hom
      (CategoryTheory.CategoryStruct.comp
        (CategoryTheory.MonoidalCategory.whiskerLeft W (CategoryTheory.MonoidalCategory.associator X Y Z).hom) h)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.MonoidalCategory.whiskerRight
  x_0 x_1`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MeasureTheory.L1.SimpleFunc.coe_posPart : ‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} (f : ‚Ü•(MeasureTheory.Lp.simpleFunc ‚Ñù 1 Œº)),
  ‚Üë(MeasureTheory.L1.SimpleFunc.posPart f) = MeasureTheory.Lp.posPart ‚Üëf
Result.success

Testing || Multiset.disjoint_union_right : ‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s t u : Multiset Œ±}, Disjoint s (t ‚à™ u) ‚Üî Disjoint s t ‚àß Disjoint s u
Result.success

Testing || NatOrdinal.toOrdinal_max : ‚àÄ (a b : NatOrdinal), NatOrdinal.toOrdinal (a ‚äî b) = NatOrdinal.toOrdinal a ‚äî NatOrdinal.toOrdinal b
Result.success

Testing || SimpleGraph.Path.cons_isCycle : ‚àÄ {V : Type u} {G : SimpleGraph V} {u v : V} (p : G.Path v u) (h : G.Adj u v),
  s(u, v) ‚àâ (‚Üëp).edges ‚Üí (SimpleGraph.Walk.cons h ‚Üëp).IsCycle
Result.exception ::
Auto failed to find proof

Testing || AddChar.wInner_cWeight_eq_one_iff_eq : ‚àÄ {G : Type u_1} {R : Type u_3} [inst : AddCommGroup G] [inst_1 : RCLike R] {œà‚ÇÅ œà‚ÇÇ : AddChar G R} [inst_2 : Fintype G],
  RCLike.wInner RCLike.cWeight ‚áëœà‚ÇÅ ‚áëœà‚ÇÇ = 1 ‚Üî œà‚ÇÅ = œà‚ÇÇ
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `RCLike.wInner
  (cifvar_10 (cifvar_11 (cifvar_12 cifvar_13))) (cifvar_14 x_0) (cifvar_14 x_1)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || min_sub_sub_left : ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedAddCommGroup Œ±] (a b c : Œ±), (a - b) ‚äì (a - c) = a - b ‚äî c
Result.success

Testing || CategoryTheory.Endofunctor.algebraPreadditive_homGroup_add_f : ‚àÄ (C : Type u‚ÇÅ) [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.Preadditive C]
  (F : CategoryTheory.Functor C C) [inst_2 : F.Additive] (A‚ÇÅ A‚ÇÇ : CategoryTheory.Endofunctor.Algebra F) (Œ± Œ≤ : A‚ÇÅ ‚ü∂ A‚ÇÇ),
  (Œ± + Œ≤).f = Œ±.f + Œ≤.f
Result.success

Testing || AlgebraicGeometry.Scheme.toSpecŒì_naturality_assoc : ‚àÄ {X Y : AlgebraicGeometry.Scheme} (f : X ‚ü∂ Y) {Z : AlgebraicGeometry.Scheme}
  (h : AlgebraicGeometry.Spec (Y.presheaf.obj (Opposite.op ‚ä§)) ‚ü∂ Z),
  CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp Y.toSpecŒì h) =
    CategoryTheory.CategoryStruct.comp X.toSpecŒì
      (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map (AlgebraicGeometry.Scheme.Hom.appTop f)) h)
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || DirichletCharacter.LSeries.mul_mu_eq_one : ‚àÄ {N : ‚Ñï} (œá : DirichletCharacter ‚ÑÇ N) {s : ‚ÑÇ},
  1 < s.re ‚Üí LSeries (fun n => œá ‚Üën) s * LSeries ((fun n => œá ‚Üën) * fun n => ‚Üë(ArithmeticFunction.moebius n)) s = 1
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `LSeriesSummable
  (fun n => cifvar_24 x_0 (cifvar_25 n)) x_1`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || IsPrimitiveRoot.pow_ne_one_of_pos_of_lt : ‚àÄ {M : Type u_1} [inst : CommMonoid M] {k l : ‚Ñï} {Œ∂ : M}, IsPrimitiveRoot Œ∂ k ‚Üí 0 < l ‚Üí l < k ‚Üí Œ∂ ^ l ‚â† 1
Result.success

Testing || tsum_setElem_eq_tsum_setElem_diff : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : AddCommMonoid Œ±] [inst_1 : TopologicalSpace Œ±] {f : Œ≤ ‚Üí Œ±} (s t : Set Œ≤),
  (‚àÄ b ‚àà t, f b = 0) ‚Üí ‚àë' (a : ‚Üës), f ‚Üëa = ‚àë' (a : ‚Üë(s \ t)), f ‚Üëa
Result.exception ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || Set.piMap_image_pi : ‚àÄ {Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} {Œ≤ : Œπ ‚Üí Type u_3} {s : Set Œπ} {f : (i : Œπ) ‚Üí Œ± i ‚Üí Œ≤ i},
  (‚àÄ i ‚àâ s, Function.Surjective (f i)) ‚Üí ‚àÄ (t : (i : Œπ) ‚Üí Set (Œ± i)), Pi.map f '' s.pi t = s.pi fun i => f i '' t i
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `f x_0`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || fermatLastTheoremFor_iff_rat : ‚àÄ {n : ‚Ñï}, FermatLastTheoremFor n ‚Üî FermatLastTheoremWith ‚Ñö n
Result.exception ::
Auto failed to find proof

Testing || MeasureTheory.FinMeasAdditive.smul_measure : ‚àÄ {Œ± : Type u_1} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} {Œ≤ : Type u_7} [inst : AddCommMonoid Œ≤]
  {T : Set Œ± ‚Üí Œ≤} (c : ENNReal), c ‚â† 0 ‚Üí MeasureTheory.FinMeasAdditive Œº T ‚Üí MeasureTheory.FinMeasAdditive (c ‚Ä¢ Œº) T
Result.success

Testing || Finset.mulETransformRight_snd : ‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] [inst_1 : Group Œ±] (e : Œ±) (x : Finset Œ± √ó Finset Œ±),
  (Finset.mulETransformRight e x).2 = x.2 ‚à© e‚Åª¬π ‚Ä¢ x.2
Result.success

Testing || Associates.eq_pow_of_mul_eq_pow : ‚àÄ {Œ± : Type u_1} [inst : CancelCommMonoidWithZero Œ±] [inst_1 : UniqueFactorizationMonoid Œ±] {a b c : Associates Œ±},
  a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí (‚àÄ (d : Associates Œ±), d ‚à£ a ‚Üí d ‚à£ b ‚Üí ¬¨Prime d) ‚Üí ‚àÄ {k : ‚Ñï}, a * b = c ^ k ‚Üí ‚àÉ d, a = d ^ k
Result.exception ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Testing || Sigma.card_Ioo : ‚àÄ {Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [inst : DecidableEq Œπ] [inst_1 : (i : Œπ) ‚Üí Preorder (Œ± i)]
  [inst_2 : (i : Œπ) ‚Üí LocallyFiniteOrder (Œ± i)] (a b : (i : Œπ) √ó Œ± i),
  (Finset.Ioo a b).card = if h : a.fst = b.fst then (Finset.Ioo (h ‚ñ∏ a.snd) b.snd).card else 0
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `if h :
    cifvar_9 (cifvar_10 cifvar_4) (cifvar_10 cifvar_5) then cifvar_11 (x_0 (cifvar_12 cifvar_13 h) cifvar_14)
else cifvar_15`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.Limits.colimit.Œπ_coconeMorphism : ‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J] {C : Type u} [inst_1 : CategoryTheory.Category.{v, u} C]
  {F : CategoryTheory.Functor J C} [inst_2 : CategoryTheory.Limits.HasColimit F] (c : CategoryTheory.Limits.Cocone F)
  (j : J),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ F j)
      (CategoryTheory.Limits.colimit.coconeMorphism c).hom =
    c.Œπ.app j
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.Limits.colimit.Œπ
  cifvar_1 x_1`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Real.continuousOn_logb : ‚àÄ {b : ‚Ñù}, ContinuousOn (Real.logb b) {0}·∂ú
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `ContinuousOn
  (fun x => cifvar_6 (cifvar_7 cifvar_8 x) y) x_0`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AlgebraicGeometry.Proj.pullbackAwayŒπIso_inv_snd : ‚àÄ {R : Type u_1} {A : Type u_2} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A] (ùíú : ‚Ñï ‚Üí Submodule R A)
  [inst_3 : GradedAlgebra ùíú] {f : A} {m : ‚Ñï} (f_deg : f ‚àà ùíú m) (hm : 0 < m) {m' : ‚Ñï} {g : A} (g_deg : g ‚àà ùíú m')
  (hm' : 0 < m') {x : A} (hx : x = f * g),
  CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Proj.pullbackAwayŒπIso ùíú f_deg hm g_deg hm' hx).inv
      (CategoryTheory.Limits.pullback.snd (AlgebraicGeometry.Proj.awayŒπ ùíú f f_deg hm)
        (AlgebraicGeometry.Proj.awayŒπ ùíú g g_deg hm')) =
    AlgebraicGeometry.Spec.map (CommRingCat.ofHom (HomogeneousLocalization.awayMap ùíú f_deg ‚ãØ))
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || ProbabilityTheory.IsCondKernelCDF.integral : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {mŒ± : MeasurableSpace Œ±} {mŒ≤ : MeasurableSpace Œ≤}
  {Œ∫ : ProbabilityTheory.Kernel Œ± (Œ≤ √ó ‚Ñù)} {ŒΩ : ProbabilityTheory.Kernel Œ± Œ≤} {f : Œ± √ó Œ≤ ‚Üí StieltjesFunction},
  ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ ‚Üí
    ‚àÄ (a : Œ±) (x : ‚Ñù), ‚à´ (b : Œ≤), ‚Üë(f (a, b)) x ‚àÇŒΩ a = ((Œ∫ a) (Set.univ √óÀ¢ Set.Iic x)).toReal
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `‚à´ (b : Œ≤),
  cifvar_18 (cifvar_19 (cifvar_20 a b)) x ‚àÇcifvar_17 (cifvar_6 x_1 a) s`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || BoundedContinuousFunction.integrable_of_nnreal : ‚àÄ {X : Type u_1} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] (Œº : MeasureTheory.Measure X)
  [inst_2 : MeasureTheory.IsFiniteMeasure Œº] [inst_3 : OpensMeasurableSpace X] (f : BoundedContinuousFunction X NNReal),
  MeasureTheory.Integrable (NNReal.toReal ‚àò ‚áëf) Œº
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Continuous (cifvar_17 x_0)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || AlgebraicGeometry.Scheme.Opens.fromSpecStalkOfMem_Œπ_assoc : ‚àÄ {X : AlgebraicGeometry.Scheme} (U : X.Opens) (x : ‚Üë‚ÜëX.toPresheafedSpace) (hxU : x ‚àà U) {Z : AlgebraicGeometry.Scheme}
  (h : X ‚ü∂ Z),
  CategoryTheory.CategoryStruct.comp (U.fromSpecStalkOfMem x hxU) (CategoryTheory.CategoryStruct.comp U.Œπ h) =
    CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) h
Result.exception ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.wideSubcategoryInclusion.map : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] (P : CategoryTheory.MorphismProperty C)
  [inst_1 : P.IsMultiplicative] {X Y : CategoryTheory.WideSubcategory P} {f : X ‚ü∂ Y},
  (CategoryTheory.wideSubcategoryInclusion P).map f = ‚Üëf
Result.exception ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.MorphismProperty C is not a `‚àÄ`

Testing || IntervalIntegrable.mono : ‚àÄ {E : Type u_3} [inst : NormedAddCommGroup E] {f : ‚Ñù ‚Üí E} {a b c d : ‚Ñù} {Œº ŒΩ : MeasureTheory.Measure ‚Ñù},
  IntervalIntegrable f ŒΩ a b ‚Üí Set.uIcc c d ‚äÜ Set.uIcc a b ‚Üí Œº ‚â§ ŒΩ ‚Üí IntervalIntegrable f Œº c d
Result.success

Testing || Cardinal.aleph_max : ‚àÄ (o‚ÇÅ o‚ÇÇ : Ordinal.{u_1}), Cardinal.aleph (o‚ÇÅ ‚äî o‚ÇÇ) = Cardinal.aleph o‚ÇÅ ‚äî Cardinal.aleph o‚ÇÇ
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Monotone (cifvar_2 x_0)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Filter.pure_vadd_pure : ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : VAdd Œ± Œ≤] {a : Œ±} {b : Œ≤}, pure a +·µ• pure b = pure (a +·µ• b)
Result.exception ::
Monomorphization failed because currently the procedure cannot deal with expression `Filter.map
  (fun x => cifvar_2 x x_1) x_0`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Equiv.Perm.IsSwap.isCycle : ‚àÄ {Œ± : Type u_2} {f : Equiv.Perm Œ±} [inst : DecidableEq Œ±], f.IsSwap ‚Üí f.IsCycle
Result.exception ::
Auto failed to find proof

Testing || legendreSym.at_zero : ‚àÄ (p : ‚Ñï) [inst : Fact (Nat.Prime p)], legendreSym p 0 = 0
Result.success

Testing || PowerSeries.rescale_mk : ‚àÄ {R : Type u_1} [inst : CommSemiring R] (f : ‚Ñï ‚Üí R) (a : R),
  (PowerSeries.rescale a) (PowerSeries.mk f) = PowerSeries.mk fun n => a ^ n * f n
Result.success

Testing || Tropical.untrop_lt_iff : ‚àÄ {R : Type u} [inst : LT R] {x y : Tropical R}, Tropical.untrop x < Tropical.untrop y ‚Üî x < y
Result.success

Testing || Orientation.oangle_add_right_smul_rotation_pi_div_two : ‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [hd2 : Fact (Module.finrank ‚Ñù V = 2)]
  (o : Orientation ‚Ñù V (Fin 2)) {x : V},
  x ‚â† 0 ‚Üí ‚àÄ (r : ‚Ñù), o.oangle x (x + r ‚Ä¢ (o.rotation ‚Üë(Real.pi / 2)) x) = ‚Üë(Real.arctan r)
Result.exception ::
Auto.Solver.SMT.getSexp :: Incomplete input 

Elapsed time: 136012 ms

Summary:

0 E Bornology.isBounded_sUnion
1 E iSup_eq_iSup_finset'
2 S Nat.le_add_one_of_avg_eq_left
3 E LieModule.ofAssociativeModule
4 E LinearMap.ker_noncommProd_eq_of_supIndep_ker
5 S AddSubgroup.coe_center
6 E NonUnitalSubalgebra.toNonUnitalSubsemiring_injective
7 E CochainComplex.HomComplex.Cochain.ext‚ÇÄ
8 E Multiset.mem_of_mem_nsmul
9 E CategoryTheory.StructuredArrow.IsUniversal.fac_assoc
10 E ContractingWith.fixedPoint_lipschitz_in_map
11 S CategoryTheory.Functor.closedSieves_obj
12 E MeasureTheory.Measure.haar.le_index_mul
13 E MvPolynomial.mapAlgEquiv_refl
14 E PartialHomeomorph.MDifferentiable.mfderiv_bijective
15 S List.prod_ne_zero
16 E Ring.ne_bot_of_isMaximal_of_not_isField
17 E MonovaryOn.pow_left
18 S Complex.arg_coe_angle_eq_iff
19 E Dynamics.dynEntourage_monotone
20 E HomologicalComplex.cycles_left_exact
21 S instHasFiniteLimitsLightCondMod
22 E List.getLast?_drop
23 S AddGroup.fintypeOfKerEqRange.proof_1
24 S List.dedup_cons_of_mem'
25 E stronglyMeasurable_bot_iff
26 E PrimeSpectrum.vanishingIdeal_anti_mono
27 E IsFractionRing.isDomain
28 E Finset.inj_on_of_surj_on_of_card_le
29 S CategoryTheory.Pretriangulated.productTriangle_obj‚ÇÅ
30 S lt_div_iff_of_neg'
31 E CochainComplex.mappingCone.inr_f_descCochain_v
32 S Cubic.natDegree_of_c_ne_zero
33 E Unitization.norm_splitMul_snd_sq
34 S LinearMap.BilinForm.linMulLin_compLeft
35 E CategoryTheory.MorphismProperty.Comma.mapRight_obj_hom
36 S IsPrimitiveRoot.ne_zero
37 E _private.Mathlib.Topology.MetricSpace.Gluing.0.Metric.eq_of_glueDist_eq_zero
38 S WeierstrassCurve.Affine.eval_negPolynomial
39 E Rat.cast_lt_zero
40 S CompositionAsSet.card_boundaries_eq_succ_length
41 E Finset.prod_le_one'
42 S SlashInvariantForm.coeHom_injective
43 S CategoryTheory.StructuredArrow.toUnder_obj_left
44 S ContinuousWithinAt.mono_of_mem_nhdsWithin
45 E AddSubmonoid.closure_singleton_le_iff_mem
46 E Set.biUnion_of_singleton
47 S ULift.down_ratCast
48 S Set.smul_set_eq_empty
49 S MeasurableSet.coe_sdiff
50 E Matrix.charpoly_fromBlocks_zero‚ÇÅ‚ÇÇ
51 E CategoryTheory.Limits.PullbackCone.IsLimit.equivPullbackObj_symm_apply_fst
52 E IsLocalization.isAlgebraic
53 E Finset.addEnergy_eq_sum_sq'
54 S AddMonoidHom.addCommMonoid.proof_1
55 S ContinuousLinearEquiv.symm_trans_apply
56 E CategoryTheory.Coverage.eq_top_pullback
57 E TopCat.stalkToFiber_injective
58 S Complex.equivRealProdCLM_symm_apply
59 E tendstoLocallyUniformlyOn_TFAE
60 E nhdsWithin_Ici_neBot
61 E Multiset.Nat.antidiagonalTuple_zero_right
62 E Part.instLawfulMonad
63 E List.naturality
64 E CategoryTheory.instIsSplitMonoComp
65 E CategoryTheory.ShortComplex.leftHomologyFunctor_additive
66 E MvPowerSeries.coeff_eq_zero_of_lt_lexOrder
67 E ULift.addRightCancelMonoid.proof_1
68 E instHasCountableSeparatingOnIsOpenOfT0SpaceOfSecondCountableTopologyElem
69 E CategoryTheory.Functor.lanCompColimIso_hom_app
70 E MeasureTheory.exists_upperSemicontinuous_le_integral_le
71 E pathConnectedSpace_iff_univ
72 S Ordinal.derivFamily_isNormal
73 E CochainComplex.mappingCone.inr_f_d
74 E AddMonoidHom.isCentralScalar
75 E CategoryTheory.prod_preservesConnectedLimits
76 E CategoryTheory.Limits.reflectsLimit_of_reflectsIsomorphisms
77 E BialgHom.coe_coe
78 S Int.div_def
79 S Subgroup.center.smulCommClass_left
80 S Matrix.SpecialLinearGroup.coe_mul
81 S IsMinFilter.undual
82 E Batteries.TransCmp.cmp_congr_left'
83 E CategoryTheory.Pi.sum_obj_obj
84 E List.eraseP_cons
85 E Ordinal.sup_add_nat
86 S CategoryTheory.Square.fromArrowArrowFunctor_obj_f‚ÇÉ‚ÇÑ
87 E CategoryTheory.Pi.ext
88 E AddSubgroup.op.proof_1
89 E InnerProductGeometry.norm_add_sq_eq_norm_sq_add_norm_sq'
90 S Polynomial.ofFinsupp_nsmul
91 E Finset.Colex.initSeg_nonempty
92 E Choose.choose_modEq_prod_range_choose
93 E MeasureTheory.VectorMeasure.map_zero
94 E Matrix.updateCol_submatrix_equiv
95 E CategoryTheory.MonoidalCategory.pentagon_inv_hom_hom_hom_hom_assoc
96 S MeasureTheory.L1.SimpleFunc.coe_posPart
97 S Multiset.disjoint_union_right
98 S NatOrdinal.toOrdinal_max
99 E SimpleGraph.Path.cons_isCycle
100 E AddChar.wInner_cWeight_eq_one_iff_eq
101 S min_sub_sub_left
102 S CategoryTheory.Endofunctor.algebraPreadditive_homGroup_add_f
103 E AlgebraicGeometry.Scheme.toSpecŒì_naturality_assoc
104 E DirichletCharacter.LSeries.mul_mu_eq_one
105 S IsPrimitiveRoot.pow_ne_one_of_pos_of_lt
106 E tsum_setElem_eq_tsum_setElem_diff
107 E Set.piMap_image_pi
108 E fermatLastTheoremFor_iff_rat
109 S MeasureTheory.FinMeasAdditive.smul_measure
110 S Finset.mulETransformRight_snd
111 E Associates.eq_pow_of_mul_eq_pow
112 E Sigma.card_Ioo
113 E CategoryTheory.Limits.colimit.Œπ_coconeMorphism
114 E Real.continuousOn_logb
115 E AlgebraicGeometry.Proj.pullbackAwayŒπIso_inv_snd
116 E ProbabilityTheory.IsCondKernelCDF.integral
117 E BoundedContinuousFunction.integrable_of_nnreal
118 E AlgebraicGeometry.Scheme.Opens.fromSpecStalkOfMem_Œπ_assoc
119 E CategoryTheory.wideSubcategoryInclusion.map
120 S IntervalIntegrable.mono
121 E Cardinal.aleph_max
122 E Filter.pure_vadd_pure
123 E Equiv.Perm.IsSwap.isCycle
124 S legendreSym.at_zero
125 S PowerSeries.rescale_mk
126 S Tropical.untrop_lt_iff
127 E Orientation.oangle_add_right_smul_rotation_pi_div_two
