Config = {maxHeartbeats := 65536, timeout := 10, solverConfig = tptp zeport-lams /home/indprinciples/Programs/zipperposition/portfolio, logFile := evalOut.txt}

Testing || Int.natAbs_one : Int.natAbs 1 = 1
Result.autoException ::
Auto failed to find proof

Testing || HNNExtension.NormalWord.group_smul_def : ∀ {G : Type u_1} [inst : Group G] {A B : Subgroup G} {d : HNNExtension.NormalWord.TransversalPair G A B} (g : G)
  (w : HNNExtension.NormalWord d), g • w = { head := g * w.head, toList := w.toList, chain := ⋯, mem_set := ⋯ }
Result.autoException ::
Auto failed to find proof

Testing || Batteries.RBNode.balance2_eq : ∀ {α : Type u_1} {c : Batteries.RBColor} {n : ℕ} {l : Batteries.RBNode α} {v : α} {r : Batteries.RBNode α},
  r.Balanced c n → l.balance2 v r = Batteries.RBNode.node Batteries.RBColor.black l v r
Result.autoException ::
Auto failed to find proof

Testing || PMF.toOuterMeasure_bind_apply : ∀ {α : Type u_1} {β : Type u_2} (p : PMF α) (f : α → PMF β) (s : Set β),
  (p.bind f).toOuterMeasure s = ∑' (a : α), p a * (f a).toOuterMeasure s
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_1.indicator (cifvar_10 x_0) x`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || PEquiv.single_trans_single_of_ne : ∀ {α : Type u} {β : Type v} {γ : Type w} [inst : DecidableEq α] [inst_1 : DecidableEq β] [inst_2 : DecidableEq γ]
  {b₁ b₂ : β}, b₁ ≠ b₂ → ∀ (a : α) (c : γ), (PEquiv.single a b₁).trans (PEquiv.single b₂ c) = ⊥
Result.success

Testing || Equiv.bijOn_swap : ∀ {α : Type u_1} {s : Set α} [inst : DecidableEq α] {a b : α}, a ∈ s → b ∈ s → Set.BijOn (⇑(Equiv.swap a b)) s s
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Set.BijOn (cifvar_7 x_0) x_1 x_2`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || Matrix.kroneckerMap_zero_right : ∀ {α : Type u_2} {β : Type u_4} {γ : Type u_6} {l : Type u_8} {m : Type u_9} {n : Type u_10} {p : Type u_11}
  [inst : Zero β] [inst_1 : Zero γ] (f : α → β → γ),
  (∀ (a : α), f a 0 = 0) → ∀ (A : Matrix l m α), Matrix.kroneckerMap f A 0 = 0
Result.autoException ::
Auto failed to find proof

Testing || HomogeneousIdeal.toIdeal_add : ∀ {ι : Type u_1} {σ : Type u_2} {A : Type u_3} [inst : Semiring A] [inst_1 : DecidableEq ι] [inst_2 : AddMonoid ι]
  [inst_3 : SetLike σ A] [inst_4 : AddSubmonoidClass σ A] {𝒜 : ι → σ} [inst_5 : GradedRing 𝒜]
  (I J : HomogeneousIdeal 𝒜), (I + J).toIdeal = I.toIdeal + J.toIdeal
Result.autoException ::
Auto failed to find proof

Testing || List.nodup_rotate : ∀ {α : Type u} {l : List α} {n : ℕ}, (l.rotate n).Nodup ↔ l.Nodup
Result.success

Testing || Submodule.le_comap_pow_of_le_comap : ∀ {R : Type u_1} {M : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (p : Submodule R M)
  {f : M →ₗ[R] M}, p ≤ Submodule.comap f p → ∀ (k : ℕ), p ≤ Submodule.comap (f ^ k) p
Result.autoException ::
Auto failed to find proof

Testing || FiniteField.isSquare_neg_two_iff : ∀ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare (-2) ↔ Fintype.card F % 8 ≠ 5 ∧ Fintype.card F % 8 ≠ 7
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `quadraticChar cifvar_54`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || HasSum.hasSum_at_zero : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] (a : ℕ → E), HasSum (fun n => 0 ^ n • a n) (a 0)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `SMulWithZero.toSMulZeroClass`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || AddOreLocalization.oreSub_add_oreSub : ∀ {R : Type u_1} [inst : AddMonoid R] {S : AddSubmonoid R} [inst_1 : AddOreLocalization.AddOreSet S] {r₁ r₂ : R}
  {s₁ s₂ : ↥S},
  r₁ -ₒ s₁ + (r₂ -ₒ s₂) = AddOreLocalization.oreMin r₁ s₂ + r₂ -ₒ (AddOreLocalization.oreSubtra r₁ s₂ + s₁)
Result.autoException ::
Auto failed to find proof

Testing || sectionOfRetractionKerToTensor_algebraMap : ∀ {R P S : Type u} [inst : CommRing R] [inst_1 : CommRing P] [inst_2 : CommRing S] [inst_3 : Algebra R P]
  [inst_4 : Algebra P S] (l : TensorProduct P S (Ω[P⁄R]) →ₗ[P] ↥(RingHom.ker (algebraMap P S)))
  (hl : l ∘ₗ KaehlerDifferential.kerToTensor R P S = LinearMap.id) [inst_5 : Algebra R S] [inst_6 : IsScalarTower R P S]
  (hf' : RingHom.ker (algebraMap P S) ^ 2 = ⊥) (hf : Function.Surjective ⇑(algebraMap P S)) (x : P),
  (sectionOfRetractionKerToTensor l hl hf' hf) ((algebraMap P S) x) = x - ↑(l (1 ⊗ₜ[P] (KaehlerDifferential.D R P) x))
Result.autoException ::
Auto failed to find proof

Testing || Set.up_image : ∀ {α : Type u_1} {β : Type u_2} [inst : MulOneClass α] [inst_1 : MulOneClass β] (f : α →* β) (s : Set α),
  Set.up (⇑f '' s) = (SetSemiring.imageHom f) (Set.up s)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Limits.pullbackConeOfRightIso_π_app_right : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z)
  [inst_1 : CategoryTheory.IsIso g],
  (CategoryTheory.Limits.pullbackConeOfRightIso f g).π.app CategoryTheory.Limits.WalkingCospan.right =
    CategoryTheory.CategoryStruct.comp f (CategoryTheory.inv g)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.PreGaloisCategory.fiberEqualizerEquiv_symm_ι_apply : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{u₂, u₁} C] (F : CategoryTheory.Functor C FintypeCat)
  [inst_1 : CategoryTheory.PreGaloisCategory C] [inst_2 : CategoryTheory.PreGaloisCategory.FiberFunctor F] {X Y : C}
  {f g : X ⟶ Y} (x : ↑(F.obj X)) (h : F.map f x = F.map g x),
  F.map (CategoryTheory.Limits.equalizer.ι f g)
      ((CategoryTheory.PreGaloisCategory.fiberEqualizerEquiv F f g).symm ⟨x, h⟩) =
    x
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: F.obj X ⟶ F.obj Y is not a `∀`

Testing || CategoryTheory.Limits.prod.lift_fst_snd : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C}
  [inst_1 : CategoryTheory.Limits.HasBinaryProduct X Y],
  CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd =
    CategoryTheory.CategoryStruct.id (X ⨯ Y)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.Limits.limit.lift
  (cifvar_1 cifvar_2 cifvar_3) x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || Matrix.SpecialLinearGroup.mem_center_iff : ∀ {n : Type u} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R]
  {A : Matrix.SpecialLinearGroup n R},
  A ∈ Subgroup.center (Matrix.SpecialLinearGroup n R) ↔ ∃ r, r ^ Fintype.card n = 1 ∧ (Matrix.scalar n) r = ↑A
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix n n R is not a `∀`

Testing || LinearPMap.zero_domain : ∀ {R : Type u_1} [inst : Ring R] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {F : Type u_3}
  [inst_3 : AddCommGroup F] [inst_4 : Module R F], LinearPMap.domain 0 = ⊤
Result.autoException ::
Auto failed to find proof

Testing || char_dvd_card_solutions_of_sum_lt : ∀ {K : Type u_1} {σ : Type u_2} {ι : Type u_3} [inst : Fintype K] [inst_1 : Field K] [inst_2 : Fintype σ]
  [inst_3 : DecidableEq σ] [inst_4 : DecidableEq K] (p : ℕ) [inst_5 : CharP K p] {s : Finset ι}
  {f : ι → MvPolynomial σ K},
  ∑ i ∈ s, (f i).totalDegree < Fintype.card σ → p ∣ Fintype.card { x // ∀ i ∈ s, (MvPolynomial.eval x) (f i) = 0 }
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `GroupWithZero.toMonoidWithZero`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || NNRat.num_coe : ∀ (q : ℚ≥0), (↑q).num = ↑q.num
Result.autoException ::
Auto failed to find proof

Testing || Int.bmod_one_is_zero : ∀ (x : ℤ), x.bmod 1 = 0
Result.autoException ::
Auto failed to find proof

Testing || Nat.rel_of_forall_rel_succ_of_lt : ∀ {β : Type v} (r : β → β → Prop) [inst : IsTrans β r] {f : ℕ → β},
  (∀ (n : ℕ), r (f n) (f (n + 1))) → ∀ ⦃a b : ℕ⦄, a < b → r (f a) (f b)
Result.autoException ::
Auto failed to find proof

Testing || le_of_forall_pos_sub_le : ∀ {α : Type u_1} [inst : AddGroup α] [inst_1 : LinearOrder α] [inst_2 : AddLeftMono α] [inst_3 : DenselyOrdered α]
  {a b : α}, (∀ (ε : α), 0 < ε → a - ε ≤ b) → a ≤ b
Result.success

Testing || HomologicalComplexUpToQuasiIso.Q_map_eq_of_homotopy : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_3, u_1} C] {ι : Type u_2} {c : ComplexShape ι}
  [inst_1 : CategoryTheory.Preadditive C] [inst_2 : CategoryTheory.CategoryWithHomology C]
  [inst_3 : (HomologicalComplex.quasiIso C c).HasLocalization] [inst_4 : c.QFactorsThroughHomotopy C]
  {K L : HomologicalComplex C c} {f g : K ⟶ L},
  Homotopy f g → HomologicalComplexUpToQuasiIso.Q.map f = HomologicalComplexUpToQuasiIso.Q.map g
Result.autoException ::
Auto failed to find proof

Testing || Finset.nonempty_Ico : ∀ {α : Type u_2} {a b : α} [inst : Preorder α] [inst_1 : LocallyFiniteOrder α], (Finset.Ico a b).Nonempty ↔ a < b
Result.success

Testing || Sum.LiftRel.exists_of_isLeft_right : ∀ {α : Type u} {β : Type v} {γ : Type u_1} {δ : Type u_2} {r : α → γ → Prop} {s : β → δ → Prop} {x : α ⊕ β} {y : γ ⊕ δ},
  Sum.LiftRel r s x y → y.isLeft = true → ∃ a c, r a c ∧ x = Sum.inl a ∧ y = Sum.inl c
Result.success

Testing || FirstOrder.Language.Hom.id_comp : ∀ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : L.Structure M] [inst_1 : L.Structure N] (f : L.Hom M N),
  (FirstOrder.Language.Hom.id L N).comp f = f
Result.autoException ::
Auto failed to find proof

Testing || Pi.single_inj : ∀ {I : Type u} (f : I → Type v₁) [inst : DecidableEq I] [inst_1 : (i : I) → Zero (f i)] (i : I) {x y : f i},
  Pi.single i x = Pi.single i y ↔ x = y
Result.autoException ::
Auto failed to find proof

Testing || WeierstrassCurve.preΨ'_one : ∀ {R : Type r} [inst : CommRing R] (W : WeierstrassCurve R), W.preΨ' 1 = 1
Result.autoException ::
Auto failed to find proof

Testing || Matrix.updateColumn_conjTranspose : ∀ {m : Type u_2} {n : Type u_3} {α : Type v} {M : Matrix m n α} {i : m} {b : n → α} [inst : DecidableEq m]
  [inst_1 : Star α], M.conjTranspose.updateColumn i (star b) = (M.updateRow i b).conjTranspose
Result.success

Testing || conformalAt_iff : ∀ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup F]
  [inst_2 : InnerProductSpace ℝ E] [inst_3 : InnerProductSpace ℝ F] {f : E → F} {x : E} {f' : E →L[ℝ] F},
  HasFDerivAt f f' x → (ConformalAt f x ↔ ∃ c, 0 < c ∧ ∀ (u v : E), inner (f' u) (f' v) = c * inner u v)
Result.success

Testing || List.prod_hom₂_nonempty : ∀ {ι : Type u_1} {M : Type u_4} {N : Type u_5} {P : Type u_6} [inst : Monoid M] [inst_1 : Monoid N] [inst_2 : Monoid P]
  {l : List ι} (f : M → N → P),
  (∀ (a b : M) (c d : N), f (a * b) (c * d) = f a c * f b d) →
    ∀ (f₁ : ι → M) (f₂ : ι → N),
      l ≠ [] → (List.map (fun i => f (f₁ i) (f₂ i)) l).prod = f (List.map f₁ l).prod (List.map f₂ l).prod
Result.autoException ::
Auto failed to find proof

Testing || Filter.mem_of_superset : ∀ {α : Type u_1} {f : Filter α} {x y : Set α}, x ∈ f → x ⊆ y → y ∈ f
Result.autoException ::
Auto failed to find proof

Testing || ContinuousLinearEquiv.contDiffWithinAt_comp_iff : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {G : Type uG}
  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace 𝕜 G] {s : Set E} {f : E → F} {x : E} {n : ℕ∞} (e : G ≃L[𝕜] E),
  ContDiffWithinAt 𝕜 n (f ∘ ⇑e) (⇑e ⁻¹' s) (e.symm x) ↔ ContDiffWithinAt 𝕜 n f s x
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_23 ∘ cifvar_24 x_3`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || eq_sub_of_add_eq' : ∀ {G : Type u_3} [inst : AddCommGroup G] {a b c : G}, c + a = b → a = b - c
Result.success

Testing || Primrec.pred : Primrec Nat.pred
Result.success

Testing || MeasurableSet.cylinder : ∀ {ι : Type u_2} {α : ι → Type u_1} [inst : (i : ι) → MeasurableSpace (α i)] (s : Finset ι)
  {S : Set ((i : { x // x ∈ s }) → α ↑i)}, MeasurableSet S → MeasurableSet (MeasureTheory.cylinder s S)
Result.autoException ::
Auto failed to find proof

Testing || ZMod.intCast_eq_intCast_iff : ∀ (a b : ℤ) (c : ℕ), ↑a = ↑b ↔ a ≡ b [ZMOD ↑c]
Result.autoException ::
Auto failed to find proof

Testing || List.getI_eq_default : ∀ {α : Type u} (l : List α) [inst : Inhabited α] {n : ℕ}, l.length ≤ n → l.getI n = default
Result.autoException ::
Auto failed to find proof

Testing || NonUnitalSubsemiring.comap_top : ∀ {R : Type u} {S : Type v} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_1}
  [inst_2 : FunLike F R S] [inst_3 : NonUnitalRingHomClass F R S] (f : F), NonUnitalSubsemiring.comap f ⊤ = ⊤
Result.autoException ::
Auto failed to find proof

Testing || Monotone.rightLim_le : ∀ {α : Type u_1} {β : Type u_2} [inst : LinearOrder α] [inst_1 : ConditionallyCompleteLinearOrder β]
  [inst_2 : TopologicalSpace β] [inst_3 : OrderTopology β] {f : α → β},
  Monotone f → ∀ {x y : α}, x < y → Function.rightLim f x ≤ f y
Result.autoException ::
Auto failed to find proof

Testing || AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom_toStalk : ∀ (R : Type u) [inst : CommRing R] (x : ↑(AlgebraicGeometry.PrimeSpectrum.Top R)) (f : R),
  (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x) ((AlgebraicGeometry.StructureSheaf.toStalk R x) f) =
    (algebraMap R (Localization.AtPrime x.asIdeal)) f
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.isPrime`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || ringExpChar.eq_iff : ∀ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] {q : ℕ}, ringExpChar R = q ↔ ExpChar R q
Result.success

Testing || TopologicalSpace.NoetherianSpace.finite : ∀ {α : Type u_1} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace.NoetherianSpace α] [inst : T2Space α], Finite α
Result.success

Testing || Subalgebra.mem_op : ∀ {R : Type u_2} {A : Type u_3} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] {x : Aᵐᵒᵖ}
  {S : Subalgebra R A}, x ∈ S.op ↔ MulOpposite.unop x ∈ S
Result.autoException ::
Auto failed to find proof

Testing || MvQPF.Cofix.bisim₂ : ∀ {n : ℕ} {F : TypeVec.{u} (n + 1) → Type u} [q : MvQPF F] {α : TypeVec.{u} n}
  (r : MvQPF.Cofix F α → MvQPF.Cofix F α → Prop),
  (∀ (x y : MvQPF.Cofix F α), r x y → MvFunctor.LiftR' (α.RelLast' r) x.dest y.dest) →
    ∀ (x y : MvQPF.Cofix F α), r x y → x = y
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: TypeVec.{u} (n + 1) is not a `∀`

Testing || CategoryTheory.BicategoricalCoherence.whiskerLeft_iso : ∀ {B : Type u} [inst : CategoryTheory.Bicategory B] {a b c : B} (f : a ⟶ b) (g h : b ⟶ c)
  [inst_1 : CategoryTheory.BicategoricalCoherence g h],
  CategoryTheory.BicategoricalCoherence.iso =
    CategoryTheory.Bicategory.whiskerLeftIso f CategoryTheory.BicategoricalCoherence.iso
Result.autoException ::
Auto failed to find proof

Testing || Nat.sq_add_sq_mul : ∀ {a b x y u v : ℕ}, a = x ^ 2 + y ^ 2 → b = u ^ 2 + v ^ 2 → ∃ r s, a * b = r ^ 2 + s ^ 2
Result.autoException ::
Auto failed to find proof

Testing || Set.iUnion_smul_left_image : ∀ {α : Type u_2} {β : Type u_3} [inst : SMul α β] {s : Set α} {t : Set β}, ⋃ a ∈ s, a • t = s • t
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a ∈ x_0 of λ binder contains bound variables

Testing || IsGroupHom.comp : ∀ {α : Type u} {β : Type v} [inst : Group α] [inst_1 : Group β] {f : α → β},
  IsGroupHom f → ∀ {γ : Type u_1} [inst_2 : Group γ] {g : β → γ}, IsGroupHom g → IsGroupHom (g ∘ f)
Result.autoException ::
Auto failed to find proof

Testing || LieSubmodule.sup_lie : ∀ {R : Type u} {L : Type v} {M : Type w} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : AddCommGroup M]
  [inst_3 : Module R M] [inst_4 : LieRingModule L M] (N : LieSubmodule R L M) [inst_5 : LieAlgebra R L]
  (I J : LieIdeal R L), ⁅I ⊔ J, N⁆ = ⁅I, N⁆ ⊔ ⁅J, N⁆
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{ x // cifvar_17 x_1 x }`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || mem_ball_zero_iff : ∀ {E : Type u_6} [inst : SeminormedAddGroup E] {a : E} {r : ℝ}, a ∈ Metric.ball 0 r ↔ ‖a‖ < r
Result.success

Testing || ContinuousConstSMul.continuous_const_smul : ∀ {Γ : Type u_1} {T : Type u_2} {inst : TopologicalSpace T} {inst_1 : SMul Γ T} [self : ContinuousConstSMul Γ T]
  (γ : Γ), Continuous fun x => γ • x
Result.autoException ::
Auto failed to find proof

Testing || Cardinal.lift_mk_shrink' : ∀ (α : Type u) [inst : Small.{v, u} α],
  Cardinal.lift.{u, v} (Cardinal.mk (Shrink.{v, u} α)) = Cardinal.lift.{v, u} (Cardinal.mk α)
Result.autoException ::
Auto failed to find proof

Testing || SetTheory.PGame.Domineering.snd_pred_mem_erase_of_mem_left : ∀ {b : SetTheory.PGame.Domineering.Board} {m : ℤ × ℤ},
  m ∈ SetTheory.PGame.Domineering.left b → (m.1, m.2 - 1) ∈ Finset.erase b m
Result.autoException ::
Auto failed to find proof

Testing || Ordnode.Valid'.node4L : ∀ {α : Type u_1} [inst : Preorder α] {l : Ordnode α} {x : α} {m : Ordnode α} {y : α} {r : Ordnode α} {o₁ : WithBot α}
  {o₂ : WithTop α},
  Ordnode.Valid' o₁ l ↑x →
    Ordnode.Valid' (↑x) m ↑y →
      Ordnode.Valid' (↑y) r o₂ →
        0 < m.size →
          l.size = 0 ∧ m.size = 1 ∧ r.size ≤ 1 ∨
              0 < l.size ∧
                Ordnode.ratio * r.size ≤ m.size ∧
                  Ordnode.delta * l.size ≤ m.size + r.size ∧
                    3 * (m.size + r.size) ≤ 16 * l.size + 9 ∧ m.size ≤ Ordnode.delta * r.size →
            Ordnode.Valid' o₁ (l.node4L x m y r) o₂
Result.autoException ::
Auto failed to find proof

Testing || MeasureTheory.setToFun_sub : ∀ {α : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℝ E]
  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ℝ F] {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}
  [inst_4 : CompleteSpace F] {T : Set α → E →L[ℝ] F} {C : ℝ} {f g : α → E}
  (hT : MeasureTheory.DominatedFinMeasAdditive μ T C),
  MeasureTheory.Integrable f μ →
    MeasureTheory.Integrable g μ →
      MeasureTheory.setToFun μ T hT (f - g) = MeasureTheory.setToFun μ T hT f - MeasureTheory.setToFun μ T hT g
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Pretriangulated.mem_distTriang_op_iff : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.HasShift C ℤ]
  [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Preadditive C]
  [inst_4 : ∀ (n : ℤ), (CategoryTheory.shiftFunctor C n).Additive] [inst_5 : CategoryTheory.Pretriangulated C]
  (T : CategoryTheory.Pretriangulated.Triangle Cᵒᵖ),
  T ∈ CategoryTheory.Pretriangulated.distinguishedTriangles ↔
    Opposite.unop ((CategoryTheory.Pretriangulated.triangleOpEquivalence C).inverse.obj T) ∈
      CategoryTheory.Pretriangulated.distinguishedTriangles
Result.autoException ::
Auto failed to find proof

Testing || LinearMap.lTensor_neg : ∀ {R : Type u_1} [inst : CommSemiring R] {M : Type u_2} {N : Type u_3} {P : Type u_4} [inst_1 : AddCommGroup M]
  [inst_2 : AddCommGroup N] [inst_3 : AddCommGroup P] [inst_4 : Module R M] [inst_5 : Module R N] [inst_6 : Module R P]
  (f : N →ₗ[R] P), LinearMap.lTensor M (-f) = -LinearMap.lTensor M f
Result.autoException ::
Auto failed to find proof

Testing || AddLocalization.rec.proof_3 : ∀ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {p : AddLocalization S → Sort u_2}
  (f : (a : M) → (b : ↥S) → p (AddLocalization.mk a b)),
  (∀ {a c : M} {b d : ↥S} (h : (AddLocalization.r S) (a, b) (c, d)), ⋯ ▸ f a b = f c d) →
    ∀ (y z : M × ↥S) (h : (AddOreLocalization.oreEqv S M) y z), ⋯ ▸ ⋯ ▸ f y.1 y.2 = ⋯ ▸ f z.1 z.2
Result.autoException ::
Auto failed to find proof

Testing || Unitization.lift_symm_apply : ∀ {R : Type u_2} {A : Type u_3} [inst : CommSemiring R] [inst_1 : NonUnitalSemiring A] [inst_2 : Module R A]
  [inst_3 : SMulCommClass R A A] [inst_4 : IsScalarTower R A A] {C : Type u_5} [inst_5 : Semiring C]
  [inst_6 : Algebra R C] (φ : Unitization R A →ₐ[R] C),
  Unitization.lift.symm φ = (NonUnitalAlgHomClass.toNonUnitalAlgHom φ).comp (Unitization.inrNonUnitalAlgHom R A)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Limits.Types.binaryCoproductColimit_desc : ∀ (X Y : Type u) (s : CategoryTheory.Limits.BinaryCofan X Y) (a : X ⊕ Y),
  (CategoryTheory.Limits.Types.binaryCoproductColimit X Y).desc s a = Sum.elim s.inl s.inr a
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: (CategoryTheory.Limits.Types.binaryCoproductCocone X Y).pt ⟶
  s.pt is not a `∀`

Testing || LinearIsometry.map_ne : ∀ {R : Type u_1} {R₂ : Type u_2} {E₂ : Type u_6} {F : Type u_9} [inst : Semiring R] [inst_1 : Semiring R₂]
  {σ₁₂ : R →+* R₂} [inst_2 : SeminormedAddCommGroup E₂] [inst_3 : Module R₂ E₂] [inst_4 : NormedAddCommGroup F]
  [inst_5 : Module R F] (f₁ : F →ₛₗᵢ[σ₁₂] E₂) {x y : F}, x ≠ y → f₁ x ≠ f₁ y
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Function.Injective (cifvar_5 x_0)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || Relation.comp_assoc : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} {δ : Type u_4} {r : α → β → Prop} {p : β → γ → Prop} {q : γ → δ → Prop},
  Relation.Comp (Relation.Comp r p) q = Relation.Comp r (Relation.Comp p q)
Result.autoException ::
Auto failed to find proof

Testing || Int.succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul : ∀ {p : ℕ},
  Nat.Prime p →
    ∀ {m n : ℤ} {k l : ℕ},
      ↑(p ^ k) ∣ m → ↑(p ^ l) ∣ n → ↑(p ^ (k + l + 1)) ∣ m * n → ↑(p ^ (k + 1)) ∣ m ∨ ↑(p ^ (l + 1)) ∣ n
Result.success

Testing || Subring.coe_center : ∀ (R : Type u) [inst : Ring R], ↑(Subring.center R) = Set.center R
Result.autoException ::
Auto failed to find proof

Testing || AntivaryOn.sum_mul_le_sum_mul_comp_perm : ∀ {ι : Type u_1} {α : Type u_2} [inst : LinearOrderedSemiring α] [inst_1 : ExistsAddOfLE α] {s : Finset ι}
  {σ : Equiv.Perm ι} {f g : ι → α}, AntivaryOn f g ↑s → {x | σ x ≠ x} ⊆ ↑s → ∑ i ∈ s, f i * g i ≤ ∑ i ∈ s, f i * g (σ i)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `∑ i ∈ x_0,
  cifvar_12 (cifvar_13 i) (cifvar_14 (cifvar_15 x_1 i))`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || RightOrdContinuous.lt_iff : ∀ {α : Type u} {β : Type v} [inst : SemilatticeInf α] [inst_1 : SemilatticeInf β] {f : α → β},
  RightOrdContinuous f → Function.Injective f → ∀ {x y : α}, f x < f y ↔ x < y
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `SemilatticeSup.toPartialOrder`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || Batteries.Vector.push_pop_back : ∀ {α : Type u_1} {n : ℕ} (v : Batteries.Vector α (n + 1)), Batteries.Vector.push v.back v.pop = v
Result.autoException ::
Auto.Lemma.rewriteUMonoRigid? :: Motive fun _a =>
  ∀ {α : Type u_1} {n : ℕ} {v : Batteries.Vector α n} {x : α} {i : ℕ} (h : i < n),
    (Batteries.Vector.push x v)[i] = v[i] is not type correct

Testing || CategoryTheory.Adjunction.toEquivalence_inverse : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor D C} (adj : F ⊣ G)
  [inst_2 : ∀ (X : C), CategoryTheory.IsIso (adj.unit.app X)]
  [inst_3 : ∀ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)], adj.toEquivalence.inverse = G
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_7 cifvar_8).app x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || FractionalIdeal.fg_of_isUnit : ∀ {R : Type u_1} [inst : CommRing R] {S : Submonoid R} {P : Type u_2} [inst_1 : CommRing P] [inst_2 : Algebra R P]
  (I : FractionalIdeal S P), IsUnit I → (↑I).FG
Result.autoException ::
Auto failed to find proof

Testing || minpoly.natSepDegree_eq_one_iff_eq_X_sub_C_pow : ∀ {F : Type u} {E : Type v} [inst : Field F] [inst_1 : Ring E] [inst_2 : IsDomain E] [inst_3 : Algebra F E] (q : ℕ)
  [hF : ExpChar F q] {x : E},
  (minpoly F x).natSepDegree = 1 ↔
    ∃ n, Polynomial.map (algebraMap F E) (minpoly F x) = (Polynomial.X - Polynomial.C x) ^ q ^ n
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `HasDistribNeg.toInvolutiveNeg`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || IsAddRightRegular.add : ∀ {R : Type u_1} [inst : AddSemigroup R] {a b : R},
  IsAddRightRegular a → IsAddRightRegular b → IsAddRightRegular (a + b)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(fun x => cifvar_4 x x_0) ∘
  fun x => cifvar_4 x x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || StarConvex.preimage_add_left : ∀ {𝕜 : Type u_1} {E : Type u_2} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E] [inst_2 : Module 𝕜 E] {x z : E}
  {s : Set E}, StarConvex 𝕜 (x + z) s → StarConvex 𝕜 x ((fun x => x + z) ⁻¹' s)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(fun x => cifvar_1 x_1 x) ⁻¹' x_2`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || fixedPoints_submonoid_sup : ∀ (M : Type u_1) (α : Type u_2) [inst : Monoid M] [inst_1 : MulAction M α] {P Q : Submonoid M},
  MulAction.fixedPoints (↥(P ⊔ Q)) α = MulAction.fixedPoints (↥P) α ∩ MulAction.fixedPoints (↥Q) α
Result.autoException ::
Auto failed to find proof

Testing || add_neg_cancel_comm : ∀ {G : Type u_1} [inst : AddCommGroup G] (a b : G), a + b + -a = b
Result.success

Testing || StructureGroupoid.LocalInvariantProp.liftPropAt_symm_of_mem_maximalAtlas : ∀ {H : Type u_1} {M : Type u_2} [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]
  {G : StructureGroupoid H} {e : PartialHomeomorph M H} {Q : (H → H) → Set H → H → Prop} [inst_3 : HasGroupoid M G]
  {x : H},
  G.LocalInvariantProp G Q →
    (∀ (y : H), Q id Set.univ y) →
      e ∈ StructureGroupoid.maximalAtlas M G → x ∈ e.target → ChartedSpace.LiftPropAt Q (↑e.symm) x
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `∀ᶠ (y : H) in cifvar_20 x_1,
  cifvar_16 (cifvar_17 x_0 (cifvar_18 (cifvar_19 x_0) y)) y`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || MeasureTheory.tendsto_of_uncrossing_lt_top : ∀ {Ω : Type u_1} {f : ℕ → Ω → ℝ} {ω : Ω},
  Filter.liminf (fun n => ↑‖f n ω‖₊) Filter.atTop < ⊤ →
    (∀ (a b : ℚ), a < b → MeasureTheory.upcrossings (↑a) (↑b) f ω < ⊤) →
      ∃ c, Filter.Tendsto (fun n => f n ω) Filter.atTop (nhds c)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `∃ᶠ (n : ℕ) in x_0,
  cifvar_17 (cifvar_18 n cifvar_6) a`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || BitVec.shiftLeft_add_distrib : ∀ {w : ℕ} {x y : BitVec w} {n : ℕ}, (x + y) <<< n = x <<< n + y <<< n
Result.autoException ::
Auto failed to find proof

Testing || Std.DHashMap.Internal.AssocList.get_eq : ∀ {α : Type u} {β : Type v} [inst : BEq α] {l : Std.DHashMap.Internal.AssocList α fun x => β} {a : α}
  {h : Std.DHashMap.Internal.AssocList.contains a l = true},
  Std.DHashMap.Internal.AssocList.get a l h = Std.DHashMap.Internal.List.getValue a l.toList ⋯
Result.autoException ::
Auto failed to find proof

Testing || UniqueFactorizationMonoid.pow_eq_pow_iff : ∀ {M : Type u_1} [inst : CancelCommMonoidWithZero M] {q : M}, ¬IsUnit q → q ≠ 0 → ∀ {m n : ℕ}, q ^ m = q ^ n ↔ m = n
Result.success

Testing || MvPolynomial.radical_le_vanishingIdeal_zeroLocus : ∀ {k : Type u_1} [inst : Field k] {σ : Type u_2} (I : Ideal (MvPolynomial σ k)),
  I.radical ≤ MvPolynomial.vanishingIdeal (MvPolynomial.zeroLocus I)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{J |
  cifvar_15 (cifvar_1 x_0 J) (cifvar_16 J)}`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || SimpleGraph.Walk.not_nil_cons : ∀ {V : Type u} {G : SimpleGraph V} {u v w : V} {h : G.Adj u v} {p : G.Walk v w}, ¬(SimpleGraph.Walk.cons h p).Nil
Result.autoException ::
Auto failed to find proof

Testing || Isometry.preimage_emetric_ball : ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] {f : α → β},
  Isometry f → ∀ (x : α) (r : ENNReal), f ⁻¹' EMetric.ball (f x) r = EMetric.ball x r
Result.success

Testing || CategoryTheory.isCoseparating_empty_of_thin : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : Quiver.IsThin C], CategoryTheory.IsCoseparating ∅
Result.autoException ::
Auto failed to find proof

Testing || ENNReal.fun_eq_funMulInvSnorm_mul_snorm : ∀ {α : Type u_1} [inst : MeasurableSpace α] {μ : MeasureTheory.Measure α} {p : ℝ} (f : α → ENNReal),
  ∫⁻ (a : α), f a ^ p ∂μ ≠ 0 →
    ∫⁻ (a : α), f a ^ p ∂μ ≠ ⊤ → ∀ {a : α}, f a = ENNReal.funMulInvSnorm f p μ a * (∫⁻ (c : α), f c ^ p ∂μ) ^ (1 / p)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `∫⁻ (c : α),
  cifvar_11 (cifvar_6 c) x_1 ∂x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || CategoryTheory.IsFiltered.of_isRightAdjoint : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.IsFiltered C] {D : Type u₁}
  [inst_2 : CategoryTheory.Category.{v₁, u₁} D] (R : CategoryTheory.Functor C D) [inst : R.IsRightAdjoint],
  CategoryTheory.IsFiltered D
Result.autoException ::
Auto failed to find proof

Testing || heq_rec_iff_heq : ∀ {α : Sort u_2} {β : Sort u_1} {a b : α} {C : α → Sort u_1} {x : β} {y : C a} {e : a = b}, HEq x (e ▸ y) ↔ HEq x y
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.braiding_tensorUnit_left_assoc : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C]
  [inst_2 : CategoryTheory.BraidedCategory C] (X : C) {Z : C}
  (h : CategoryTheory.MonoidalCategory.tensorObj X (𝟙_ C) ⟶ Z),
  CategoryTheory.CategoryStruct.comp (β_ (𝟙_ C) X).hom h =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).hom
      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.rightUnitor X).inv h)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.MonoidalCategory.leftUnitor
  x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || lipschitzOnWith_iff_norm_div_le : ∀ {E : Type u_3} {F : Type u_4} [inst : SeminormedGroup E] [inst_1 : SeminormedGroup F] {s : Set E} {f : E → F}
  {C : NNReal}, LipschitzOnWith C f s ↔ ∀ ⦃x : E⦄, x ∈ s → ∀ ⦃y : E⦄, y ∈ s → ‖f x / f y‖ ≤ ↑C * ‖x / y‖
Result.success

Testing || ProbabilityTheory.IsMeasurableRatCDF.tendsto_atBot_zero : ∀ {α : Type u_1} [inst : MeasurableSpace α] {f : α → ℚ → ℝ},
  ProbabilityTheory.IsMeasurableRatCDF f → ∀ (a : α), Filter.Tendsto (f a) Filter.atBot (nhds 0)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Filter.Tendsto (cifvar_8 x_0)
  cifvar_3 (cifvar_4 cifvar_5)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || ULift.up_injective : ∀ {α : Type u}, Function.Injective ULift.up
Result.autoException ::
Auto failed to find proof

Testing || IsCyclotomicExtension.Rat.absdiscr_prime_pow_succ : ∀ (p : ℕ+) (k : ℕ) (K : Type u) [inst : Field K] [hp : Fact (Nat.Prime ↑p)] [inst_1 : CharZero K]
  [inst_2 : IsCyclotomicExtension {p ^ (k + 1)} ℚ K],
  NumberField.discr K = (-1) ^ (↑p ^ k * (↑p - 1) / 2) * ↑↑p ^ (↑p ^ k * ((↑p - 1) * (k + 1) - 1))
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{ x // cifvar_27 x_0 x }`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || SemilatticeSup.ext : ∀ {α : Type u_1} {A B : SemilatticeSup α}, (∀ (x y : α), x ≤ y ↔ x ≤ y) → A = B
Result.autoException ::
Auto failed to find proof

Testing || balanced_zero : ∀ {𝕜 : Type u_1} {E : Type u_3} [inst : SeminormedRing 𝕜] [inst_1 : AddCommGroup E] [inst_2 : Module 𝕜 E], Balanced 𝕜 0
Result.autoException ::
Auto failed to find proof

Testing || Orientation.oangle_rotation_oangle_left : ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : Fact (Module.finrank ℝ V = 2)]
  (o : Orientation ℝ V (Fin 2)) (x y : V), o.oangle ((o.rotation (o.oangle x y)) x) y = 0
Result.autoException ::
Auto failed to find proof

Testing || Finsupp.card_Ioc : ∀ {ι : Type u_1} {α : Type u_2} [inst : PartialOrder α] [inst_1 : Zero α] [inst_2 : LocallyFiniteOrder α]
  (f g : ι →₀ α), (Finset.Ioc f g).card = ∏ i ∈ f.support ∪ g.support, (Finset.Icc (f i) (g i)).card - 1
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `∏
  i ∈ cifvar_8 (cifvar_9 x_0) (cifvar_9 x_1), cifvar_13 (cifvar_15 (cifvar_19 x_0 i) (cifvar_19 x_1 i))`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || SubfieldClass.coe_ratCast : ∀ {K : Type u} [inst : DivisionRing K] {S : Type u_1} [inst_1 : SetLike S K] [h : SubfieldClass S K] (s : S) (x : ℚ),
  ↑↑x = ↑x
Result.autoException ::
Auto failed to find proof

Testing || AnalyticOn.iteratedFDeriv : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type v} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f : E → F}
  {s : Set E} [inst_5 : CompleteSpace F], AnalyticOnNhd 𝕜 f s → ∀ (n : ℕ), AnalyticOnNhd 𝕜 (iteratedFDeriv 𝕜 n f) s
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Fin.fintype n`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || Set.image2_inter_subset_left : ∀ {α : Type u_1} {β : Type u_3} {γ : Type u_5} {f : α → β → γ} {s s' : Set α} {t : Set β},
  Set.image2 f (s ∩ s') t ⊆ Set.image2 f s t ∩ Set.image2 f s' t
Result.autoException ::
Auto failed to find proof

Testing || Irrational.div_nat : ∀ {x : ℝ}, Irrational x → ∀ {m : ℕ}, m ≠ 0 → Irrational (x / ↑m)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Oplax.category_comp : ∀ {B : Type u₁} [inst : CategoryTheory.Bicategory B] {C : Type u₂} [inst_1 : CategoryTheory.Bicategory C]
  (F G : CategoryTheory.OplaxFunctor B C) {X Y Z : F ⟶ G} (Γ : CategoryTheory.Oplax.Modification X Y)
  (Δ : CategoryTheory.Oplax.Modification Y Z), CategoryTheory.CategoryStruct.comp Γ Δ = Γ.vcomp Δ
Result.autoException ::
Auto failed to find proof

Testing || homothety_inv_two : ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Field k] [inst_1 : CharZero k] [inst_2 : AddCommGroup V]
  [inst_3 : Module k V] [inst_4 : AddTorsor V P] (a b : P), (AffineMap.homothety a 2⁻¹) b = midpoint k a b
Result.autoException ::
Auto failed to find proof

Testing || MulActionHom.map_smul : ∀ {M' : Type u_1} {X : Type u_5} [inst : SMul M' X] {Y : Type u_6} [inst_1 : SMul M' Y] (f : X →ₑ[id] Y) (m : M')
  (x : X), f (m • x) = m • f x
Result.success

Testing || AlgebraicGeometry.Scheme.OpenCover.gluedCoverT'_snd_fst : ∀ {X : AlgebraicGeometry.Scheme} (𝒰 : X.OpenCover) (x y z : 𝒰.J),
  CategoryTheory.CategoryStruct.comp (𝒰.gluedCoverT' x y z)
      (CategoryTheory.CategoryStruct.comp
        (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map z))
          (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map x)))
        (CategoryTheory.Limits.pullback.fst (𝒰.map y) (𝒰.map x))) =
    CategoryTheory.CategoryStruct.comp
      (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map y))
        (CategoryTheory.Limits.pullback.fst (𝒰.map x) (𝒰.map z)))
      (CategoryTheory.Limits.pullback.snd (𝒰.map x) (𝒰.map y))
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_16.map x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || List.unattach_join : ∀ {α : Type u_1} {p : α → Prop} {l : List (List { x // p x })}, l.join.unattach = (List.map List.unattach l).join
Result.autoException ::
Auto failed to find proof

Testing || ContinuousLinearEquiv.piCongrRight_symm_apply : ∀ {R₁ : Type u_1} [inst : Semiring R₁] {ι : Type u_9} {M : ι → Type u_10} [inst_1 : (i : ι) → TopologicalSpace (M i)]
  [inst_2 : (i : ι) → AddCommMonoid (M i)] [inst_3 : (i : ι) → Module R₁ (M i)] {N : ι → Type u_11}
  [inst_4 : (i : ι) → TopologicalSpace (N i)] [inst_5 : (i : ι) → AddCommMonoid (N i)]
  [inst_6 : (i : ι) → Module R₁ (N i)] (f : (i : ι) → M i ≃L[R₁] N i) (n : (i : ι) → N i) (i : ι),
  (ContinuousLinearEquiv.piCongrRight f).symm n i = (f i).symm (n i)
Result.autoException ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || Int.le_iff_pos_of_dvd : ∀ {a b : ℤ}, 0 < a → a ∣ b → (a ≤ b ↔ 0 < b)
Result.success

Testing || Real.zpow_le_of_le_log : ∀ {x y : ℝ} {n : ℤ}, 0 < y → Real.log x ≤ ↑n * Real.log y → x ≤ y ^ n
Result.success

Testing || Ideal.radical_eq_top : ∀ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, I.radical = ⊤ ↔ I = ⊤
Result.autoException ::
Auto failed to find proof

Testing || AlgebraicGeometry.ΓSpec.toOpen_comp_locallyRingedSpaceAdjunction_homEquiv_app : ∀ {X : AlgebraicGeometry.LocallyRingedSpace} {R : Type u} [inst : CommRing R]
  (f : AlgebraicGeometry.LocallyRingedSpace.Γ.rightOp.obj X ⟶ Opposite.op (CommRingCat.of R))
  (U :
    (TopologicalSpace.Opens
        ↑↑(AlgebraicGeometry.Spec.toLocallyRingedSpace.obj (Opposite.op (CommRingCat.of R))).toPresheafedSpace)ᵒᵖ),
  CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toOpen R (Opposite.unop U))
      (((AlgebraicGeometry.ΓSpec.locallyRingedSpaceAdjunction.homEquiv X (Opposite.op (CommRingCat.of R))) f).c.app U) =
    CategoryTheory.CategoryStruct.comp f.unop (X.presheaf.map (CategoryTheory.homOfLE ⋯).op)
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WeierstrassCurve.Affine.nonsingular_negAdd : ∀ {F : Type u} [inst : Field F] {W : WeierstrassCurve.Affine F} {x₁ x₂ y₁ y₂ : F},
  W.Nonsingular x₁ y₁ →
    W.Nonsingular x₂ y₂ →
      (x₁ = x₂ → y₁ ≠ W.negY x₂ y₂) →
        W.Nonsingular (W.addX x₁ x₂ (W.slope x₁ x₂ y₁ y₂)) (W.negAddY x₁ x₂ y₁ (W.slope x₁ x₂ y₁ y₂))
Result.autoException ::
Auto failed to find proof

Testing || finrank_le_one : ∀ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]
  [inst_3 : NoZeroSMulDivisors R M] [inst_4 : StrongRankCondition R] (v : M),
  (∀ (w : M), ∃ c, c • v = w) → Module.finrank R M ≤ 1
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `One.toOfNat1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || Option.map₂_coe_left : ∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} (f : α → β → γ) (a : α) (b : Option β),
  Option.map₂ f (some a) b = Option.map (fun b => f a b) b
Result.autoException ::
Auto failed to find proof

Testing || DomMulAct.inducing_mk_symm : ∀ {M : Type u_1} [inst : TopologicalSpace M], IsInducing ⇑DomMulAct.mk.symm
Result.success

Testing || ContinuousAlternatingMap.map_update_zero : ∀ {R : Type u_1} {M : Type u_2} {N : Type u_4} {ι : Type u_6} [inst : Semiring R] [inst_1 : AddCommMonoid M]
  [inst_2 : Module R M] [inst_3 : TopologicalSpace M] [inst_4 : AddCommMonoid N] [inst_5 : Module R N]
  [inst_6 : TopologicalSpace N] (f : M [⋀^ι]→L[R] N) [inst_7 : DecidableEq ι] (m : ι → M) (i : ι),
  f (Function.update m i 0) = 0
Result.autoException ::
Auto failed to find proof

Testing || ArithmeticFunction.pmul_apply : ∀ {R : Type u_1} [inst : MulZeroClass R] {f g : ArithmeticFunction R} {x : ℕ}, (f.pmul g) x = f x * g x
Result.autoException ::
Auto failed to find proof

Testing || List.dropLast_prefix : ∀ {α : Type u_1} (l : List α), l.dropLast <+: l
Result.autoException ::
Auto failed to find proof

Testing || AlgebraicGeometry.Scheme.homOfLE_ι : ∀ (X : AlgebraicGeometry.Scheme) {U V : X.Opens} (e : U ≤ V), CategoryTheory.CategoryStruct.comp (X.homOfLE e) V.ι = U.ι
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_12
      (cifvar_13 (cifvar_14 (cifvar_15 (cifvar_17 x_0))))).instFunLike
  (cifvar_12 (cifvar_13 (cifvar_14 (cifvar_15 cifvar_16))))`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || Set.range_list_getI : ∀ {α : Type u_1} [inst : Inhabited α] (l : List α), Set.range l.getI = insert default {x | x ∈ l}
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Set.range fun n =>
  cifvar_8 (cifvar_9 x_0 n) x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || IsQuotientMap.isClopen_preimage : ∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y},
  IsQuotientMap f → ∀ {s : Set Y}, IsClopen (f ⁻¹' s) ↔ IsClopen s
Result.autoException ::
Auto failed to find proof

Testing || Bifunctor.id_fst : ∀ {F : Type u₀ → Type u₁ → Type u₂} [inst : Bifunctor F] [inst_1 : LawfulBifunctor F] {α : Type u₀} {β : Type u₁}
  (x : F α β), Bifunctor.fst id x = x
Result.success

Testing || Auto.Embedding.Lam.LamTerm.rwGenAll_atom : ∀ {conv : Auto.Embedding.Lam.LamTerm → Option Auto.Embedding.Lam.LamTerm} {n : ℕ},
  Auto.Embedding.Lam.LamTerm.rwGenAll conv (Auto.Embedding.Lam.LamTerm.atom n) =
    some ((conv (Auto.Embedding.Lam.LamTerm.atom n)).getD (Auto.Embedding.Lam.LamTerm.atom n))
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `match cifvar_7 x_0 with
| some t' => cifvar_5 t'
| none => cifvar_5 x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)

Testing || Multiset.Nodup.product : ∀ {α : Type u_1} {β : Type v} {s : Multiset α} {t : Multiset β}, s.Nodup → t.Nodup → (s ×ˢ t).Nodup
Result.autoException ::
Auto failed to find proof

Testing || Set.toFinset_congr : ∀ {α : Type u_1} {s t : Set α} [inst : Fintype ↑s] [inst_1 : Fintype ↑t], s = t → s.toFinset = t.toFinset
Result.autoException ::
Auto failed to find proof

Testing || List.suffix_iff_eq_append : ∀ {α : Type u_1} {l₁ l₂ : List α}, l₁ <:+ l₂ ↔ List.take (l₂.length - l₁.length) l₂ ++ l₁ = l₂
Result.autoException ::
Auto failed to find proof

Elapsed time: 746848 ms
