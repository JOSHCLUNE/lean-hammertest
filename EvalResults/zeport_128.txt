Config = {maxHeartbeats := 65536, timeout := 10, solverConfig = tptp zeport-lams /home/indprinciples/Programs/zipperposition/portfolio, logFile := evalOut.txt}

Testing || AEMeasurable.inf : ∀ {M : Type u_1} [inst : MeasurableSpace M] {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}
  {f g : α → M} [inst_1 : Min M] [inst_2 : MeasurableInf₂ M],
  AEMeasurable f μ → AEMeasurable g μ → AEMeasurable (fun a => f a ⊓ g a) μ
Result.autoException ::
Auto failed to find proof

Testing || Std.HashSet.getD_insert : ∀ {α : Type u} {x : BEq α} {x_1 : Hashable α} {m : Std.HashSet α} [inst : EquivBEq α] [inst : LawfulHashable α]
  {k a fallback : α}, (m.insert k).getD a fallback = if (k == a) = true ∧ k ∉ m then k else m.getD a fallback
Result.autoException ::
application type mismatch
  Std.HashSet α = { inner := Std.HashSet α }.inner
argument
  { inner := Std.HashSet α }.inner
has type
  Std.HashMap α Unit : Type u
but is expected to have type
  Type u : Type (u + 1)

Testing || LinOrd.Iso.mk_inv : ∀ {α β : LinOrd} (e : ↑α ≃o ↑β), (LinOrd.Iso.mk e).inv = ↑e.symm
Result.success

Testing || List.sublistsLen_length : ∀ {α : Type u} (l : List α), List.sublistsLen l.length l = [l]
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `List.map (cifvar_9 x_1)
  (cifvar_2 x_0 x_2)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || GenContFract.zeroth_contAux_eq_one_zero : ∀ {K : Type u_1} {g : GenContFract K} [inst : DivisionRing K], g.contsAux 0 = { a := 1, b := 0 }
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Stream' (GenContFract.Pair K) is not a `∀`

Testing || Rat.cast_sub_of_ne_zero : ∀ {α : Type u_3} [inst : DivisionRing α] {p q : ℚ}, ↑p.den ≠ 0 → ↑q.den ≠ 0 → ↑(p - q) = ↑p - ↑q
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `a.den_nz`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || _private.Mathlib.Combinatorics.SimpleGraph.Triangle.Counting.0.SimpleGraph.edgeDensity_badVertices_le : ∀ {α : Type u_1} (G : SimpleGraph α) [inst : DecidableRel G.Adj] {ε : ℝ} {s t : Finset α},
  0 ≤ ε → 2 * ε ≤ ↑(G.edgeDensity s t) → ↑(G.edgeDensity (SimpleGraph.badVertices G ε s t) t) ≤ ↑(G.edgeDensity s t) - ε
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `AddGroup.toSubtractionMonoid`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || _private.Mathlib.Combinatorics.Additive.SmallTripling.0.Finset.small_pos_neg_pos_add : ∀ {G : Type u_1} [inst : DecidableEq G] [inst_1 : AddGroup G] {A : Finset G} {K : ℝ},
  ↑(3 • A).card ≤ K * ↑A.card → ↑(A + -A + A).card ≤ K ^ 3 * ↑A.card
Result.autoException ::
Auto failed to find proof

Testing || AddMonoid.exponent_pi_eq_zero : ∀ {ι : Type u_1} {M : ι → Type u_2} [inst : (i : ι) → AddMonoid (M i)] {j : ι},
  AddMonoid.exponent (M j) = 0 → AddMonoid.exponent ((i : ι) → M i) = 0
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `n • g`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || isLUB_sSup : ∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] (s : Set α), IsLUB s (sSup s)
Result.autoException ::
Auto failed to find proof

Testing || Algebra.coe_sInf : ∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]
  (S : Set (Subalgebra R A)), ↑(sInf S) = ⋂ s ∈ S, ↑s
Result.autoException ::
Auto failed to find proof

Testing || Set.image_mul_left_Ioo : ∀ {α : Type u_1} [inst : LinearOrderedField α] {a : α},
  0 < a → ∀ (b c : α), (fun x => a * x) '' Set.Ioo b c = Set.Ioo (a * b) (a * c)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(fun x => cifvar_9 x x_2) ''
  cifvar_6 x_0 x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || FirstOrder.Language.ElementaryEmbedding.map_rel : ∀ {L : FirstOrder.Language} {M : Type u_1} {N : Type u_2} [inst : L.Structure M] [inst_1 : L.Structure N]
  (φ : L.ElementaryEmbedding M N) {n : ℕ} (r : L.Relations n) (x : Fin n → M),
  FirstOrder.Language.Structure.RelMap r (⇑φ ∘ x) ↔ FirstOrder.Language.Structure.RelMap r x
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_13 x_0 ∘ cifvar_14`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || hnot_le_iff_codisjoint_left : ∀ {α : Type u_2} [inst : CoheytingAlgebra α] {a b : α}, ￢a ≤ b ↔ Codisjoint b a
Result.success

Testing || SemistandardYoungTableau.copy_eq : ∀ {μ : YoungDiagram} (T : SemistandardYoungTableau μ) (entry' : ℕ → ℕ → ℕ) (h : entry' = ⇑T), T.copy entry' h = T
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_8 x_0 = cifvar_8 x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux_map' : ∀ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_4, u_1} C]
  [inst_1 : CategoryTheory.Category.{u_3, u_2} D] {G : CategoryTheory.Functor C D} {A : Type w}
  [inst_2 : CategoryTheory.Category.{w', w} A] {J : CategoryTheory.GrothendieckTopology C}
  {K : CategoryTheory.GrothendieckTopology D} [inst_3 : G.IsCocontinuous J K] {F : CategoryTheory.Functor Cᵒᵖ A}
  (hF : CategoryTheory.Presheaf.IsSheaf J F) {R : CategoryTheory.Functor Dᵒᵖ A} (α : G.op.comp R ⟶ F) {X : D}
  {S : K.Cover X} (s : CategoryTheory.Limits.Multifork (S.index R)) {Y Y' : C} (f : G.obj Y ⟶ X) (f' : G.obj Y' ⟶ X)
  {W : C} (a : W ⟶ Y) (b : W ⟶ Y'),
  CategoryTheory.CategoryStruct.comp (G.map a) f = CategoryTheory.CategoryStruct.comp (G.map b) f' →
    CategoryTheory.CategoryStruct.comp (CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux hF α s f) (F.map a.op) =
      CategoryTheory.CategoryStruct.comp (CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux hF α s f') (F.map b.op)
Result.autoException ::
Auto failed to find proof

Testing || AlgebraicGeometry.Spec.toSheafedSpace_obj : ∀ (R : CommRingCatᵒᵖ),
  AlgebraicGeometry.Spec.toSheafedSpace.obj R = AlgebraicGeometry.Spec.sheafedSpaceObj (Opposite.unop R)
Result.autoException ::
application type mismatch
  CommRing α = Opposite.unop (Opposite.op (CommRing α))
argument
  Opposite.unop (Opposite.op (CommRing α))
has type
  CommRingCat : Type (u + 1)
but is expected to have type
  Type u : Type (u + 1)

Testing || Set.image_preimage : ∀ {α : Type u_1} {β : Type u_2} {f : α → β}, GaloisConnection (Set.image f) (Set.preimage f)
Result.autoException ::
Auto failed to find proof

Testing || deriv_sinh : ∀ {f : ℝ → ℝ} {x : ℝ}, DifferentiableAt ℝ f x → deriv (fun x => Real.sinh (f x)) x = Real.cosh (f x) * deriv f x
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WCovBy.le_of_lt : ∀ {α : Type u_1} [inst : LinearOrder α] {a b c : α}, a ⩿ b → c < b → c ≤ a
Result.autoException ::
Auto failed to find proof

Testing || Bool.not_eq_not : ∀ {a b : Bool}, ¬a = !b ↔ a = b
Result.success

Testing || CategoryTheory.Limits.coneOfSectionCompYoneda_pt : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {J : Type w} [inst_1 : CategoryTheory.Category.{t, w} J]
  (F : CategoryTheory.Functor J Cᵒᵖ) (X : C) (s : ↑(F.comp (CategoryTheory.yoneda.obj X)).sections),
  (CategoryTheory.Limits.coneOfSectionCompYoneda F X s).pt = Opposite.op X
Result.autoException ::
application type mismatch
  Opposite.op unop = Opposite.unop (Opposite.op (Opposite.op unop))
argument
  Opposite.unop (Opposite.op (Opposite.op unop))
has type
  C : Type u
but is expected to have type
  Cᵒᵖ : Type u

Testing || WittVector.wittMul_vars : ∀ (p : ℕ) [hp : Fact (Nat.Prime p)] (n : ℕ), (WittVector.wittMul p n).vars ⊆ Finset.univ ×ˢ Finset.range (n + 1)
Result.autoException ::
Auto failed to find proof

Testing || Real.borel_eq_generateFrom_Ioi_rat : borel ℝ = MeasurableSpace.generateFrom (⋃ a, {Set.Ioi ↑a})
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x ∈ x_1 of λ binder contains bound variables

Testing || HomologicalComplex₂.comm_f : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_4, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  {I₁ : Type u_2} {I₂ : Type u_3} {c₁ : ComplexShape I₁} {c₂ : ComplexShape I₂} {K L : HomologicalComplex₂ C c₁ c₂}
  (f : K ⟶ L) (i₁ i₁' : I₁) (i₂ : I₂),
  CategoryTheory.CategoryStruct.comp ((f.f i₁).f i₂) ((L.d i₁ i₁').f i₂) =
    CategoryTheory.CategoryStruct.comp ((K.d i₁ i₁').f i₂) ((f.f i₁').f i₂)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_17.d cifvar_16 x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Asymptotics.IsBigO.comp_tendsto : ∀ {α : Type u_1} {β : Type u_2} {E : Type u_3} {F : Type u_4} [inst : Norm E] [inst_1 : Norm F] {f : α → E} {g : α → F}
  {l : Filter α}, f =O[l] g → ∀ {k : β → α} {l' : Filter β}, Filter.Tendsto k l' l → (f ∘ k) =O[l'] (g ∘ k)
Result.autoException ::
Auto failed to find proof

Testing || Filter.Tendsto.cexp : ∀ {α : Type u_1} {l : Filter α} {f : α → ℂ} {z : ℂ},
  Filter.Tendsto f l (nhds z) → Filter.Tendsto (fun x => Complex.exp (f x)) l (nhds (Complex.exp z))
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || IsLocalizedModule.fromLocalizedModule'_add : ∀ {R : Type u_1} [inst : CommSemiring R] (S : Submonoid R) {M : Type u_2} {M' : Type u_3} [inst_1 : AddCommMonoid M]
  [inst_2 : AddCommMonoid M'] [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R M'] (f : M →ₗ[R] M')
  [inst_5 : IsLocalizedModule S f] (x y : LocalizedModule S M),
  IsLocalizedModule.fromLocalizedModule' S f (x + y) =
    IsLocalizedModule.fromLocalizedModule' S f x + IsLocalizedModule.fromLocalizedModule' S f y
Result.autoException ::
Auto failed to find proof

Testing || AffineSubspace.affineSpan_coe : ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module k V]
  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k ↑s = s
Result.autoException ::
Auto failed to find proof

Testing || ENat.mem_nhds_natCast_iff : ∀ (n : ℕ) {s : Set ℕ∞}, s ∈ nhds ↑n ↔ ↑n ∈ s
Result.success

Testing || HasProd.div : ∀ {α : Type u_1} {β : Type u_2} [inst : CommGroup α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalGroup α]
  {f g : β → α} {a₁ a₂ : α}, HasProd f a₁ → HasProd g a₂ → HasProd (fun b => f b / g b) (a₁ / a₂)
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || IsLocalization.coeSubmodule_fg : ∀ {R : Type u_1} [inst : CommSemiring R] (S : Type u_2) [inst_1 : CommSemiring S] [inst_2 : Algebra R S],
  Function.Injective ⇑(algebraMap R S) → ∀ (I : Ideal R), (IsLocalization.coeSubmodule S I).FG ↔ Submodule.FG I
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Function.Injective
  (cifvar_10 x_0)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.IsPullback.of_right : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂}
  {h₁₂ : X₁₂ ⟶ X₁₃} {h₂₁ : X₂₁ ⟶ X₂₂} {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃},
  CategoryTheory.IsPullback (CategoryTheory.CategoryStruct.comp h₁₁ h₁₂) v₁₁ v₁₃
      (CategoryTheory.CategoryStruct.comp h₂₁ h₂₂) →
    CategoryTheory.CategoryStruct.comp h₁₁ v₁₂ = CategoryTheory.CategoryStruct.comp v₁₁ h₂₁ →
      CategoryTheory.IsPullback h₁₂ v₁₂ v₁₃ h₂₂ → CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁
Result.success

Testing || Nat.nonempty_properDivisors : ∀ {n : ℕ}, n.properDivisors.Nonempty ↔ 1 < n
Result.autoException ::
Auto failed to find proof

Testing || RingEquiv.map_prod : ∀ {α : Type u_1} {R : Type u_2} {S : Type u_3} [inst : CommSemiring R] [inst_1 : CommSemiring S] (g : R ≃+* S)
  (f : α → R) (s : Finset α), g (∏ x ∈ s, f x) = ∏ x ∈ s, g (f x)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `∏ x ∈ x_1,
  cifvar_2 x_0 (cifvar_10 x)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || dist_smul : ∀ {M : Type u} {X : Type w} [inst : PseudoMetricSpace X] [inst_1 : SMul M X] [inst_2 : IsometricSMul M X] (c : M)
  (x y : X), dist (c • x) (c • y) = dist x y
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Isometry fun x => cifvar_4 x_0 x`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || map_mul_right_nhds₀ : ∀ {G₀ : Type u_3} [inst : TopologicalSpace G₀] [inst_1 : GroupWithZero G₀] [inst_2 : ContinuousMul G₀] {a : G₀},
  a ≠ 0 → ∀ (b : G₀), Filter.map (fun x => x * a) (nhds b) = nhds (b * a)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Filter.map (cifvar_11 x_0)
  (cifvar_7 x_1)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Nat.find_le : ∀ {n : ℕ} {p : ℕ → Prop} [inst : DecidablePred p] {h : ∃ n, p n}, p n → Nat.find h ≤ n
Result.autoException ::
Auto failed to find proof

Testing || Finset.subset_mul_left : ∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : MulOneClass α] (s : Finset α) {t : Finset α}, 1 ∈ t → s ⊆ s * t
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `a.decidableEq b`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || IterateAddAct.ext : ∀ {α : Type u_1} {f : α → α} {x y : IterateAddAct f}, x.val = y.val → x = y
Result.autoException ::
application type mismatch
  ℕ = { val := ℕ }.val
argument
  { val := ℕ }.val
has type
  ℕ : Type
but is expected to have type
  Type : Type 1

Testing || Mathlib.Vector.mem_cons_of_mem : ∀ {α : Type u_1} {n : ℕ} (a a' : α) (v : Mathlib.Vector α n), a' ∈ v.toList → a' ∈ (a ::ᵥ v).toList
Result.success

Testing || Measurable.set_lintegral_kernel : ∀ {α : Type u_1} {β : Type u_2} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} {κ : ProbabilityTheory.Kernel α β}
  [inst : ProbabilityTheory.IsSFiniteKernel κ] {f : β → ENNReal},
  Measurable f → ∀ {s : Set β}, MeasurableSet s → Measurable fun a => ∫⁻ (b : β) in s, f b ∂κ a
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Nat.dvd_zero : ∀ (a : ℕ), a ∣ 0
Result.autoException ::
Auto failed to find proof

Testing || Function.Embedding.toEquivRange_symm_apply_self : ∀ {α : Type u_1} {β : Type u_2} [inst : Fintype α] [inst_1 : DecidableEq β] (f : α ↪ β) (a : α),
  f.toEquivRange.symm ⟨f a, ⋯⟩ = a
Result.autoException ::
Auto failed to find proof

Testing || Matrix.star_dotProduct_star : ∀ {m : Type u_2} {α : Type v} [inst : Fintype m] [inst_1 : NonUnitalSemiring α] [inst_2 : StarRing α] (v w : m → α),
  Matrix.dotProduct (star v) (star w) = star (Matrix.dotProduct w v)
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Finset.singleton_infs_singleton : ∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : SemilatticeInf α] {a b : α}, {a} ⊼ {b} = {a ⊓ b}
Result.success

Testing || IsConjRoot.isIntegral : ∀ {R : Type u_1} {A : Type u_5} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A] {x y : A},
  IsIntegral R x → IsConjRoot R x y → IsIntegral R y
Result.autoException ::
Auto failed to find proof

Testing || SimpleGraph.Walk.transfer_transfer : ∀ {V : Type u} {G : SimpleGraph V} {u v : V} (p : G.Walk u v) {H : SimpleGraph V} (hp : ∀ e ∈ p.edges, e ∈ H.edgeSet)
  {K : SimpleGraph V} (hp' : ∀ e ∈ (p.transfer H hp).edges, e ∈ K.edgeSet),
  (p.transfer H hp).transfer K hp' = p.transfer K ⋯
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type (p.transfer H hp).edges =
  x✝ of λ binder contains bound variables

Testing || CategoryTheory.ofTypeMonad_μ_app : ∀ (m : Type u → Type u) [inst : Monad m] [inst_1 : LawfulMonad m] {α : Type u} (a : m (m α)),
  (CategoryTheory.ofTypeMonad m).μ.app α a = joinM a
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: ((CategoryTheory.ofTypeMonad m).comp
        (CategoryTheory.ofTypeMonad m).toFunctor).obj
    α ⟶
  (CategoryTheory.ofTypeMonad m).obj α is not a `∀`

Testing || measure_Ioc_lt_top : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : CompactIccSpace α] {m : MeasurableSpace α}
  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.IsLocallyFiniteMeasure μ] {a b : α}, μ (Set.Ioc a b) < ⊤
Result.success

Testing || List.takeDTR_go_eq : ∀ {α : Type u_1} {dflt : α} {acc : Array α} (n : ℕ) (l : List α),
  List.takeDTR.go dflt n l acc = acc.toList ++ List.takeD n l dflt
Result.autoException ::
application type mismatch
  α✝ = { toList := α✝ }.toList
argument
  { toList := α✝ }.toList
has type
  List α✝ : Type u_1
but is expected to have type
  Type u_1 : Type (u_1 + 1)

Testing || Symmetric.iff : ∀ {α : Type u_1} {r : α → α → Prop}, Symmetric r → ∀ (x y : α), r x y ↔ r y x
Result.autoException ::
Auto failed to find proof

Testing || LieModuleEquiv.symm_apply_apply : ∀ {R : Type u} {L : Type v} {M : Type w} {N : Type w₁} [inst : CommRing R] [inst_1 : LieRing L]
  [inst_2 : AddCommGroup M] [inst_3 : AddCommGroup N] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R N]
  [inst_6 : LieRingModule L M] [inst_7 : LieRingModule L N] (e : M ≃ₗ⁅R,L⁆ N) (x : M), e.symm (e x) = x
Result.autoException ::
Auto failed to find proof

Testing || AffineIndependent.mem_affineSpan_iff : ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module k V]
  [inst_3 : AddTorsor V P] {ι : Type u_4} [inst_4 : Nontrivial k] {p : ι → P},
  AffineIndependent k p → ∀ (i : ι) (s : Set ι), p i ∈ affineSpan k (p '' s) ↔ i ∈ s
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : (#5 → Prop), ((∃x1 : #5, x0 x1) = (!14 x0))) is not type correct

Testing || CategoryTheory.ofTypeMonad_obj : ∀ (m : Type u → Type u) [inst : Monad m] [inst_1 : LawfulMonad m] (a : Type u),
  (CategoryTheory.ofTypeMonad m).obj a = m a
Result.success

Testing || Set.center_eq_univ : ∀ (M : Type u_1) [inst : CommSemigroup M], Set.center M = Set.univ
Result.autoException ::
Auto failed to find proof

Testing || LinearIsometryEquiv.differentiableOn : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {s : Set E}
  (iso : E ≃ₗᵢ[𝕜] F), DifferentiableOn 𝕜 (⇑iso) s
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Differentiable cifvar_5
  (cifvar_8 x_0)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || TwoUniqueSums.of_addHom : ∀ {G : Type u} {H : Type v} [inst : Add G] [inst_1 : Add H] (f : H →ₙ+ G),
  (∀ ⦃a b c d : H⦄, a + b = c + d → f a = f c ∧ f b = f d → a = c ∧ b = d) → ∀ [inst : TwoUniqueSums G], TwoUniqueSums H
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.image (cifvar_3 x_5) x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || SimpleGraph.Walk.map_toDeleteEdges_eq : ∀ {V : Type u} {G : SimpleGraph V} {v w : V} (s : Set (Sym2 V)) {p : G.Walk v w} (hp : ∀ e ∈ p.edges, e ∉ s),
  SimpleGraph.Walk.map (SimpleGraph.Hom.mapSpanningSubgraphs ⋯) (SimpleGraph.Walk.toDeleteEdges s p hp) = p
Result.autoException ::
Auto failed to find proof

Testing || LinearEquiv.symm_apply_apply : ∀ {R : Type u_1} {S : Type u_5} {M : Type u_6} {M₂ : Type u_8} [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] {module_M : _root_.Module R M}
  {module_S_M₂ : _root_.Module S M₂} {σ : R →+* S} {σ' : S →+* R} {re₁ : RingHomInvPair σ σ'}
  {re₂ : RingHomInvPair σ' σ} (e : M ≃ₛₗ[σ] M₂) (b : M), e.symm (e b) = b
Result.autoException ::
Auto failed to find proof

Testing || Valuation.IsEquiv.ne_zero : ∀ {R : Type u_3} {Γ₀ : Type u_4} {Γ'₀ : Type u_5} [inst : Ring R] [inst_1 : LinearOrderedCommMonoidWithZero Γ₀]
  [inst_2 : LinearOrderedCommMonoidWithZero Γ'₀] {v₁ : Valuation R Γ₀} {v₂ : Valuation R Γ'₀},
  v₁.IsEquiv v₂ → ∀ {r : R}, v₁ r ≠ 0 ↔ v₂ r ≠ 0
Result.success

Testing || List.pwFilter_map : ∀ {α : Type u_1} {R : α → α → Prop} {β : Type u_2} [inst : DecidableRel R] (f : β → α) (l : List β),
  List.pwFilter R (List.map f l) = List.map f (List.pwFilter (fun x y => R (f x) (f y)) l)
Result.autoException ::
Auto failed to find proof

Testing || Relator.RightUnique.forall₂ : ∀ {α : Type u_1} {β : Type u_2} {R : α → β → Prop}, Relator.RightUnique R → Relator.RightUnique (List.Forall₂ R)
Result.autoException ::
Auto failed to find proof

Testing || CFC.quasispectrum_zero_eq : ∀ {R : Type u_1} {A : Type u_2} {p : A → Prop} [inst : CommSemiring R] [inst_1 : Nontrivial R] [inst_2 : StarRing R]
  [inst_3 : MetricSpace R] [inst_4 : TopologicalSemiring R] [inst_5 : ContinuousStar R] [inst_6 : NonUnitalRing A]
  [inst_7 : StarRing A] [inst_8 : TopologicalSpace A] [inst_9 : _root_.Module R A] [inst_10 : IsScalarTower R A A]
  [inst_11 : SMulCommClass R A A] [instCFCₙ : NonUnitalContinuousFunctionalCalculus R p], quasispectrum R 0 = {0}
Result.autoException ::
Auto failed to find proof

Testing || taylor_mean_remainder_cauchy : ∀ {f : ℝ → ℝ} {x x₀ : ℝ} {n : ℕ},
  x₀ < x →
    ContDiffOn ℝ (↑n) f (Set.Icc x₀ x) →
      DifferentiableOn ℝ (iteratedDerivWithin n f (Set.Icc x₀ x)) (Set.Ioo x₀ x) →
        ∃ x' ∈ Set.Ioo x₀ x,
          f x - taylorWithinEval f n (Set.Icc x₀ x) x₀ x =
            iteratedDerivWithin (n + 1) f (Set.Icc x₀ x) x' * (x - x') ^ n / ↑n.factorial * (x - x₀)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Idempotents.DoldKan.N_obj : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  [inst_2 : CategoryTheory.IsIdempotentComplete C] [inst_3 : CategoryTheory.Limits.HasFiniteCoproducts C]
  (X : CategoryTheory.SimplicialObject C),
  CategoryTheory.Idempotents.DoldKan.N.obj X =
    (CategoryTheory.Idempotents.toKaroubiEquivalence (ChainComplex C ℕ)).inverse.obj
      (AlgebraicTopology.DoldKan.N₁.obj X)
Result.success

Testing || HomogeneousLocalization.val_zsmul : ∀ {ι : Type u_1} {R : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A]
  {𝒜 : ι → Submodule R A} (x : Submonoid A) (n : ℤ) (y : HomogeneousLocalization 𝒜 x), (n • y).val = n • y.val
Result.success

Testing || Filter.NeBot.mul_zero_nonneg : ∀ {α : Type u_2} [inst : MulZeroClass α] {f : Filter α}, f.NeBot → 0 ≤ f * 0
Result.autoException ::
Auto failed to find proof

Testing || sdiff_sdiff : ∀ {α : Type u_2} [inst : GeneralizedCoheytingAlgebra α] (a b c : α), (a \ b) \ c = a \ (b ⊔ c)
Result.success

Testing || Rat.ofInt_eq_cast : ∀ (n : ℤ), Rat.ofInt n = ↑n
Result.success

Testing || QPF.Fix.ind_rec : ∀ {F : Type u → Type u} [q : QPF F] {α : Type u} (g₁ g₂ : QPF.Fix F → α),
  (∀ (x : F (QPF.Fix F)), g₁ <$> x = g₂ <$> x → g₁ (QPF.Fix.mk x) = g₂ (QPF.Fix.mk x)) → ∀ (x : QPF.Fix F), g₁ x = g₂ x
Result.autoException ::
Auto failed to find proof

Testing || Polynomial.eval_one_cyclotomic_not_prime_pow : ∀ {R : Type u_1} [inst : Ring R] {n : ℕ},
  (∀ {p : ℕ}, Nat.Prime p → ∀ (k : ℕ), p ^ k ≠ n) → Polynomial.eval 1 (Polynomial.cyclotomic n R) = 1
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Function.Injective fun x =>
  cifvar_2 x_0 x`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || leibniz_cross : ∀ {R : Type u_1} [inst : CommRing R] (u v w : Fin 3 → R),
  (crossProduct u) ((crossProduct v) w) = (crossProduct ((crossProduct u) v)) w + (crossProduct v) ((crossProduct u) w)
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Real.one_sub_le_exp_neg : ∀ (x : ℝ), 1 - x ≤ Real.exp (-x)
Result.success

Testing || Monovary.sum_smul_comp_perm_le_sum_smul : ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : LinearOrderedSemiring α] [inst_1 : ExistsAddOfLE α]
  [inst_2 : LinearOrderedCancelAddCommMonoid β] [inst_3 : _root_.Module α β] [inst_4 : PosSMulMono α β]
  {σ : Equiv.Perm ι} {f : ι → α} {g : ι → β} [inst_5 : Fintype ι],
  Monovary f g → ∑ i : ι, f i • g (σ i) ≤ ∑ i : ι, f i • g i
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `∑ i ∈ x_0,
  cifvar_10 (cifvar_11 i) (cifvar_12 (cifvar_13 cifvar_14 (cifvar_13 x_1 i)))`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || IndexedPartition.disjoint : ∀ {ι : Type u_1} {α : Type u_2} {s : ι → Set α}, IndexedPartition s → Pairwise (Disjoint on s)
Result.autoException ::
Auto failed to find proof

Testing || isConjRoot_iff_mem_minpoly_rootSet : ∀ {K : Type u_2} {S : Type u_4} [inst : CommRing S] [inst_1 : Field K] [inst_2 : Algebra K S] [inst_3 : IsDomain S]
  {x y : S}, IsIntegral K x → (IsConjRoot K x y ↔ y ∈ (minpoly K x).rootSet S)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_2.toFinset`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.Perm.eraseP : ∀ {α : Type u_1} (f : α → Bool) {l₁ l₂ : List α},
  List.Pairwise (fun a b => f a = true → f b = true → False) l₁ →
    l₁.Perm l₂ → (List.eraseP f l₁).Perm (List.eraseP f l₂)
Result.autoException ::
Auto failed to find proof

Testing || Fin.appendIsometry_symm_apply : ∀ {α : Type u} [inst : PseudoEMetricSpace α] (m n : ℕ) (f : Fin (m + n) → α),
  (Fin.appendIsometry m n).symm f = (fun i => f (Fin.castAdd n i), fun i => f (Fin.natAdd m i))
Result.success

Testing || AddUnits.addRight_bijective : ∀ {M : Type u_3} [inst : AddMonoid M] (a : AddUnits M), Function.Bijective fun x => x + ↑a
Result.autoException ::
Auto failed to find proof

Testing || SimpleGraph.Walk.length_transfer : ∀ {V : Type u} {G : SimpleGraph V} {u v : V} (p : G.Walk u v) {H : SimpleGraph V} (hp : ∀ e ∈ p.edges, e ∈ H.edgeSet),
  (p.transfer H hp).length = p.length
Result.autoException ::
Auto failed to find proof

Testing || CliffordAlgebra.forall_mul_self_eq_iff : ∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  {Q : QuadraticForm R M} {A : Type u_4} [inst_3 : Ring A] [inst_4 : Algebra R A],
  IsUnit 2 →
    ∀ (f : M →ₗ[R] A),
      (∀ (x : M), f x * f x = (algebraMap R A) (Q x)) ↔
        (LinearMap.mul R A).compl₂ f ∘ₗ f + (LinearMap.mul R A).flip.compl₂ f ∘ₗ f =
          LinearMap.compr₂ (QuadraticMap.polarBilin Q) (Algebra.linearMap R A)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `QuadraticMap.polar (cifvar_10 x_0)
  a b`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Topology.IsQuotientMap.image_connectedComponent : ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},
  Topology.IsQuotientMap f →
    (∀ (y : β), IsConnected (f ⁻¹' {y})) → ∀ (a : α), f '' connectedComponent a = connectedComponent (f a)
Result.success

Testing || isPiSystem_iUnion_of_monotone : ∀ {α : Type u_3} {ι : Type u_4} [inst : SemilatticeSup ι] (p : ι → Set (Set α)),
  (∀ (n : ι), IsPiSystem (p n)) → Monotone p → IsPiSystem (⋃ n, p n)
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #1, ((!0 x0) = (!5 x0 (λx1 : #2, (∀ x2 : #2, ((!6 x0 x2) → ((!7 (!8 x1 x2)) → (!6 x0 (!8 x1 x2))))))))) is not type correct

Testing || Setoid.eq_of_mem_eqv_class : ∀ {α : Type u_1} {c : Set (Set α)},
  (∀ (a : α), ∃! b, b ∈ c ∧ a ∈ b) → ∀ {x : α} {b b' : Set α}, b ∈ c → x ∈ b → b' ∈ c → x ∈ b' → b = b'
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `∃! b,
  cifvar_2 (cifvar_3 cifvar_4 b) (cifvar_5 b x_0)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || univLE_max : UnivLE.{u, max u v}
Result.autoException ::
Auto failed to find proof

Testing || hasLineDerivAt_zero : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {F : Type u_2} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace 𝕜 F] {E : Type u_3} [inst_3 : AddCommGroup E] [inst_4 : _root_.Module 𝕜 E] {f : E → F} {x : E},
  HasLineDerivAt 𝕜 f 0 x 0
Result.autoException ::
Auto failed to find proof

Testing || Complex.polarCoord_apply : ∀ (a : ℂ), ↑Complex.polarCoord a = (Complex.abs a, a.arg)
Result.autoException ::
Auto failed to find proof

Testing || Complex.cosh_sub : ∀ (x y : ℂ), Complex.cosh (x - y) = Complex.cosh x * Complex.cosh y - Complex.sinh x * Complex.sinh y
Result.success

Testing || MeasureTheory.Measure.restrict_apply' : ∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s t : Set α},
  MeasurableSet s → (μ.restrict s) t = μ (t ∩ s)
Result.success

Testing || Inseparable.mem_open_iff : ∀ {X : Type u_1} [inst : TopologicalSpace X] {x y : X} {s : Set X}, Inseparable x y → IsOpen s → (x ∈ s ↔ y ∈ s)
Result.success

Testing || CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse_map_base : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (F : CategoryTheory.Functor C CategoryTheory.Cat)
  {X Y : CategoryTheory.Grothendieck F} (f : X ⟶ Y),
  ((CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse F).map f).base = f.base
Result.success

Testing || UniqueFactorizationMonoid.squarefree_iff_nodup_normalizedFactors : ∀ {R : Type u_1} [inst : CancelCommMonoidWithZero R] [inst_1 : UniqueFactorizationMonoid R]
  [inst_2 : NormalizationMonoid R] {x : R},
  x ≠ 0 → (Squarefree x ↔ (UniqueFactorizationMonoid.normalizedFactors x).Nodup)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Multiset.count a x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || ContDiffAt.prod_map : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {n : WithTop ℕ∞}
  {E' : Type u_3} [inst_5 : NormedAddCommGroup E'] [inst_6 : NormedSpace 𝕜 E'] {F' : Type u_4}
  [inst_7 : NormedAddCommGroup F'] [inst_8 : NormedSpace 𝕜 F'] {f : E → F} {g : E' → F'} {x : E} {y : E'},
  ContDiffAt 𝕜 n f x → ContDiffAt 𝕜 n g y → ContDiffAt 𝕜 n (Prod.map f g) (x, y)
Result.success

Testing || MeasureTheory.isClosed_aeStronglyMeasurable' : ∀ {α : Type u_1} {F : Type u_2} {p : ENNReal} [inst : NormedAddCommGroup F] {m m0 : MeasurableSpace α}
  {μ : MeasureTheory.Measure α} [inst_1 : Fact (1 ≤ p)] [inst_2 : CompleteSpace F],
  m ≤ m0 → IsClosed {f | MeasureTheory.AEStronglyMeasurable' m (↑↑f) μ}
Result.autoException ::
Auto failed to find proof

Testing || ProbabilityTheory.Kernel.fst_comp : ∀ {α : Type u_1} {β : Type u_2} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} {γ : Type u_3} {δ : Type u_4}
  {mγ : MeasurableSpace γ} {mδ : MeasurableSpace δ} (κ : ProbabilityTheory.Kernel α β)
  (η : ProbabilityTheory.Kernel β (γ × δ)), (η.comp κ).fst = η.fst.comp κ
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || TypeVec.dropFun_id : ∀ {n : ℕ} {α : TypeVec.{u_1} (n + 1)}, TypeVec.dropFun TypeVec.id = TypeVec.id
Result.success

Testing || Real.cos_sq_add_sin_sq : ∀ (x : ℝ), Real.cos x ^ 2 + Real.sin x ^ 2 = 1
Result.success

Testing || Equiv.addCommSemigroup.proof_1 : ∀ {α : Type u_2} {β : Type u_1} (e : α ≃ β) [inst : AddCommSemigroup β] (x y : α), e (e.symm (e x + e y)) = e x + e y
Result.success

Testing || Nat.lcm_pos : ∀ {m n : ℕ}, 0 < m → 0 < n → 0 < m.lcm n
Result.success

Testing || PProd.exists' : ∀ {α : Sort u_1} {β : Sort u_2} {p : α → β → Prop}, (∃ x, p x.fst x.snd) ↔ ∃ a b, p a b
Result.autoException ::
Auto failed to find proof

Testing || div_le_div_left : ∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b c : α}, 0 < a → 0 < b → 0 < c → (a / b ≤ a / c ↔ c ≤ b)
Result.success

Testing || Set.Finite.induction_to_univ : ∀ {α : Type u} [inst : Finite α] {C : Set α → Prop} (S0 : Set α),
  C S0 → (∀ (S : Set α), S ≠ Set.univ → C S → ∃ a ∉ S, C (insert a S)) → C Set.univ
Result.autoException ::
Auto failed to find proof

Testing || VectorBundleCore.continuous_proj : ∀ {R : Type u_1} {B : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField R] [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace R F] [inst_3 : TopologicalSpace B] {ι : Type u_5} (Z : VectorBundleCore R B F ι),
  Continuous Z.proj
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Bundle.TotalSpace cifvar_3
  (cifvar_4 x_0)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.equivYoneda'_inv_val : ∀ (S : CategoryTheory.Sheaf CategoryTheory.typesGrothendieckTopology (Type u)),
  (CategoryTheory.equivYoneda' S).inv.val = (CategoryTheory.equivYoneda S.val ⋯).inv
Result.autoException ::
application type mismatch
  αᵒᵖ = { val := αᵒᵖ }.val
argument
  { val := αᵒᵖ }.val
has type
  (CategoryTheory.yoneda'.obj (S.val.obj (Opposite.op PUnit.{u + 1}))).val ⟶ S.val : Type (u + 1)
but is expected to have type
  Type (u + 1) : Type (u + 2)

Testing || Fintype.decidableEqAddEquivFintype.proof_1 : ∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Add β] (a b : α ≃+ β), ⇑a = ⇑b ↔ a = b
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_8 a✝ = cifvar_8 b`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || intervalIntegral.intervalIntegrable_log : ∀ {a b : ℝ} {μ : MeasureTheory.Measure ℝ} [inst : MeasureTheory.IsLocallyFiniteMeasure μ],
  0 ∉ Set.uIcc a b → IntervalIntegrable Real.log μ a b
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x.decidableEq cifvar_7`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || StrictConcaveOn.concaveOn : ∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_5} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]
  [inst_2 : OrderedAddCommMonoid β] [inst_3 : _root_.Module 𝕜 E] [inst_4 : _root_.Module 𝕜 β] {s : Set E} {f : E → β},
  StrictConcaveOn 𝕜 s f → ConcaveOn 𝕜 s f
Result.success

Testing || ProbabilityTheory.Kernel.ae_compProd_iff : ∀ {α : Type u_1} {β : Type u_2} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} {γ : Type u_3}
  {mγ : MeasurableSpace γ} {κ : ProbabilityTheory.Kernel α β} [inst : ProbabilityTheory.IsSFiniteKernel κ]
  {η : ProbabilityTheory.Kernel (α × β) γ} [inst : ProbabilityTheory.IsSFiniteKernel η] {a : α} {p : β × γ → Prop},
  MeasurableSet {x | p x} →
    ((∀ᵐ (bc : β × γ) ∂(κ.compProd η) a, p bc) ↔ ∀ᵐ (b : β) ∂κ a, ∀ᵐ (c : γ) ∂η (a, b), p (b, c))
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `∀ᶠ (c : γ) in
  cifvar_20 (cifvar_21 x_2 (cifvar_22 x_4 b)), cifvar_18 (cifvar_19 b c)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || SMulPosReflectLT.toSMulPosMono : ∀ {α : Type u_1} {β : Type u_2} [inst : SMul α β] [inst_1 : Preorder α] [inst_2 : LinearOrder β]
  [inst_3 : _root_.Zero β] [inst_4 : SMulPosReflectLT α β], SMulPosMono α β
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Zero.toOfNat0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MeasureTheory.withDensity_indicator_one : ∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α},
  MeasurableSet s → μ.withDensity (s.indicator 1) = μ.restrict s
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || add_halves' : ∀ {R : Type u_1} [inst : DivisionSemiring R] [inst_1 : NeZero 2] (a : R), a / 2 + a / 2 = a
Result.success

Testing || CategoryTheory.Limits.preservesBiproductsOfShape_of_preservesProductsOfShape : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C] {D : Type u'}
  [inst_2 : CategoryTheory.Category.{v', u'} D] [inst_3 : CategoryTheory.Preadditive D] (F : CategoryTheory.Functor C D)
  [inst_4 : F.PreservesZeroMorphisms] {J : Type} [inst_5 : Fintype J]
  [inst_6 : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) F],
  CategoryTheory.Limits.PreservesBiproductsOfShape J F
Result.autoException ::
Auto failed to find proof

Testing || WithTop.image_coe_Ioi : ∀ {α : Type u_1} [inst : Preorder α] {a : α}, WithTop.some '' Set.Ioi a = Set.Ioo ↑a ⊤
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #3, (∀ x1 : #3, ((!3 x0 x1) = (!11 (!17 x0) (λx2 : #3, (!17 x2 x1)))))) is not type correct

Testing || CategoryTheory.forgetEnrichment_id : ∀ {C : Type u₁} (W : Type v) [inst : CategoryTheory.Category.{w, v} W] [inst_1 : CategoryTheory.MonoidalCategory W]
  [inst_2 : CategoryTheory.EnrichedCategory W C] (X : CategoryTheory.ForgetEnrichment W C),
  CategoryTheory.ForgetEnrichment.homTo W (CategoryTheory.CategoryStruct.id X) =
    CategoryTheory.eId W (CategoryTheory.ForgetEnrichment.to W X)
Result.autoException ::
application type mismatch
  CategoryTheory.ForgetEnrichment W C = Opposite.unop (Opposite.op C)
argument
  Opposite.unop (Opposite.op C)
has type
  W : Type v
but is expected to have type
  Type u₁ : Type (u₁ + 1)

Testing || CategoryTheory.Comma.mapLeftComp_inv_app_left : ∀ {A : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} A] {B : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} B]
  {T : Type u₃} [inst_2 : CategoryTheory.Category.{v₃, u₃} T] (R : CategoryTheory.Functor B T)
  {L₁ L₂ L₃ : CategoryTheory.Functor A T} (l : L₁ ⟶ L₂) (l' : L₂ ⟶ L₃) (X : CategoryTheory.Comma L₃ R),
  ((CategoryTheory.Comma.mapLeftComp R l l').inv.app X).left = CategoryTheory.CategoryStruct.id X.left
Result.success

Testing || Order.pred_lt : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : PredOrder α] [inst_2 : NoMinOrder α] (a : α), Order.pred a < a
Result.success

Testing || isOfFinAddOrder_zero : ∀ {G : Type u_1} [inst : AddMonoid G], IsOfFinAddOrder 0
Result.success

Testing || gradient_eq : ∀ {𝕜 : Type u_1} {F : Type u_2} [inst : RCLike 𝕜] [inst_1 : NormedAddCommGroup F] [inst_2 : InnerProductSpace 𝕜 F]
  [inst_3 : CompleteSpace F] {f : F → 𝕜} {f' : F → F}, (∀ (x : F), HasGradientAt f (f' x) x) → gradient f = f'
Result.autoException ::
Auto failed to find proof

Testing || padicNorm.int_lt_one_iff : ∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (m : ℤ), padicNorm p ↑m < 1 ↔ ↑p ∣ m
Result.success

Testing || FiberBundle.mem_baseSet_trivializationAt : ∀ {B : Type u_2} (F : Type u_3) [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F] (E : B → Type u_5)
  [inst_2 : TopologicalSpace (Bundle.TotalSpace F E)] [inst_3 : (b : B) → TopologicalSpace (E b)]
  [inst_4 : FiberBundle F E] (b : B), b ∈ (trivializationAt F E b).baseSet
Result.success

Testing || Multiset.map_add_left_Ioc : ∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] [inst_1 : ExistsAddOfLE α] [inst_2 : LocallyFiniteOrder α]
  (a b c : α), Multiset.map (fun x => c + x) (Multiset.Ioc a b) = Multiset.Ioc (c + a) (c + b)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.image
  (fun x => cifvar_7 x_3 x) (cifvar_10 x_1 x_2)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || IsOpen.div_right : ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] {s t : Set G},
  IsOpen s → IsOpen (s / t)
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a ∈ x_1 of λ binder contains bound variables

Testing || ZModModule.add_add_add_cancel : ∀ {G : Type u_2} [inst : AddCommGroup G] [inst_1 : _root_.Module (ZMod 2) G] (x y z : G), x + y + (y + z) = x + z
Result.success

Testing || ProbabilityTheory.centralMoment_one' : ∀ {Ω : Type u_1} {m : MeasurableSpace Ω} {X : Ω → ℝ} {μ : MeasureTheory.Measure Ω}
  [inst : MeasureTheory.IsFiniteMeasure μ],
  MeasureTheory.Integrable X μ → ProbabilityTheory.centralMoment X 1 μ = (1 - (μ Set.univ).toReal) * ∫ (x : Ω), X x ∂μ
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Functor.relativelyRepresentable.symmetry_fst_assoc : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {F : CategoryTheory.Functor C D} {Y : D} {b : C} {f' : F.obj b ⟶ Y} (hf' : F.relativelyRepresentable f') {a : C}
  {g : F.obj a ⟶ Y} (hg : F.relativelyRepresentable g) [inst_2 : F.Full] [inst_3 : F.Faithful] {Z : C} (h : a ⟶ Z),
  CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (CategoryTheory.CategoryStruct.comp (hg.fst' f') h) =
    CategoryTheory.CategoryStruct.comp (hf'.snd g) h
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.MorphismProperty D is not a `∀`

Testing || Duper.rule15bTheorem : ∀ (b : Bool), (!!b) = b
Result.success

Testing || Real.summable_cexp_multipliable : ∀ {α : Type u_1} {ι : Type u_2} (f : ι → α → ℝ),
  (∀ (x : α) (n : ι), 0 < f n x) →
    (∀ (x : α), Summable fun n => Real.log (f n x)) → ∀ (a : α), Multipliable fun b => f b a
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Summable fun n =>
  cifvar_7 (cifvar_2 n x_0)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Elapsed time: 528951 ms
