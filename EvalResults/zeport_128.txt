Config = {maxHeartbeats := 65536, timeout := 10, solverConfig = tptp zeport-lams /home/indprinciples/Programs/zipperposition/portfolio, logFile := evalOut.txt}

Testing || AlgebraicGeometry.LocallyRingedSpace.restrictStalkIso_hom_eq_germ_apply : ‚àÄ {U : TopCat} (X : AlgebraicGeometry.LocallyRingedSpace) {f : U ‚ü∂ X.toTopCat} (h : IsOpenEmbedding ‚áëf)
  (V : TopologicalSpace.Opens ‚ÜëU) (x : ‚ÜëU) (hx : x ‚àà V) (y : ‚Üë((X.restrict h).presheaf.obj (Opposite.op V))),
  (X.restrictStalkIso h x).hom (((X.restrict h).presheaf.germ V x hx) y) = (X.presheaf.germ (‚ãØ.functor.obj V) (f x) ‚ãØ) y
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Module.Quotient.mk_smul_mk : ‚àÄ {R : Type u_1} (M : Type u_2) [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (I : Ideal R)
  (r : R) (m : M), (Ideal.Quotient.mk I) r ‚Ä¢ Submodule.Quotient.mk m = Submodule.Quotient.mk (r ‚Ä¢ m)
Result.autoException ::
Auto failed to find proof

Testing || BoundedLatticeHom.asBoolRing_id : ‚àÄ {Œ± : Type u_1} [inst : BooleanAlgebra Œ±], (BoundedLatticeHom.id Œ±).asBoolRing = RingHom.id (AsBoolRing Œ±)
Result.autoException ::
Auto failed to find proof

Testing || ofAdd_list_prod : ‚àÄ {Œ± : Type u_3} [inst : AddMonoid Œ±] (s : List Œ±),
  Multiplicative.ofAdd s.sum = (List.map (‚áëMultiplicative.ofAdd) s).prod
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.HasSheafify.isLeftExact : ‚àÄ {C : Type u‚ÇÅ} {inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C} {J : CategoryTheory.GrothendieckTopology C} {A : Type u‚ÇÇ}
  {inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A} [self : CategoryTheory.HasSheafify J A],
  Nonempty (CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.sheafToPresheaf J A).leftAdjoint)
Result.autoException ::
Auto failed to find proof

Testing || MvPolynomial.cardinal_mk_eq_max_lift : ‚àÄ {œÉ : Type u} {R : Type v} [inst : CommSemiring R] [inst_1 : Nonempty œÉ] [inst_2 : Nontrivial R],
  Cardinal.mk (MvPolynomial œÉ R) =
    max (max (Cardinal.lift.{u, v} (Cardinal.mk R)) (Cardinal.lift.{v, u} (Cardinal.mk œÉ))) Cardinal.aleph0
Result.autoException ::
Auto failed to find proof

Testing || ContinuousMap.Homotopy.apply_one : ‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f‚ÇÄ f‚ÇÅ : C(X, Y)}
  (F : f‚ÇÄ.Homotopy f‚ÇÅ) (x : X), F (1, x) = f‚ÇÅ x
Result.autoException ::
Auto failed to find proof

Testing || Asymptotics.IsBigOWith.const_mul_right : ‚àÄ {Œ± : Type u_1} {E : Type u_3} {ùïú : Type u_15} [inst : Norm E] [inst_1 : NormedDivisionRing ùïú] {f : Œ± ‚Üí E}
  {l : Filter Œ±} {g : Œ± ‚Üí ùïú} {c : ùïú},
  c ‚â† 0 ‚Üí
    ‚àÄ {c' : ‚Ñù}, 0 ‚â§ c' ‚Üí Asymptotics.IsBigOWith c' l f g ‚Üí Asymptotics.IsBigOWith (c' * ‚Äñc‚Äñ‚Åª¬π) l f fun x => c * g x
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.GradedObject.TriangleIndexData.hp‚ÇÅ‚ÇÇ : ‚àÄ {I‚ÇÅ : Type u_1} {I‚ÇÇ : Type u_2} {I‚ÇÉ : Type u_3} {J : Type u_4} [inst : Zero I‚ÇÇ] {r : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ ‚Üí J}
  {œÄ : I‚ÇÅ √ó I‚ÇÉ ‚Üí J} (self : CategoryTheory.GradedObject.TriangleIndexData r œÄ) (i : I‚ÇÅ √ó I‚ÇÇ √ó I‚ÇÉ),
  œÄ (self.p‚ÇÅ‚ÇÇ (i.1, i.2.1), i.2.2) = r i
Result.autoException ::
Auto failed to find proof

Testing || Matrix.toEuclideanLin_piLp_equiv_symm : ‚àÄ {ùïú : Type u_3} [inst : RCLike ùïú] {m : Type u_8} {n : Type u_9} [inst_1 : Fintype n] [inst_2 : DecidableEq n]
  (A : Matrix m n ùïú) (x : n ‚Üí ùïú),
  (Matrix.toEuclideanLin A) ((WithLp.equiv 2 ((i : n) ‚Üí (fun x => ùïú) i)).symm x) =
    (WithLp.equiv 2 (m ‚Üí ùïú)).symm ((Matrix.toLin' A) x)
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (¬¨ ((!0 (!1 !2 !3) (!4 (!5 !6) !7)) = (!8 (!9 !10) (!0 (!1 !11 !3) !7)))) is not type correct

Testing || CoalgebraCat.of_isAddCommGroup : ‚àÄ (R : Type u) [inst : CommRing R] (X : Type v) [inst_1 : AddCommGroup X] [inst_2 : Module R X]
  [inst_3 : Coalgebra R X], (CoalgebraCat.of R X).isAddCommGroup = inst_1
Result.autoException ::
Auto.Reif.resolveTy :: Unable to resolve AddCommGroup ‚Üë(CoalgebraCat.of R X).toModuleCat

Testing || ContinuousMultilinearMap.iteratedFDerivComponent_apply : ‚àÄ {ùïú : Type u} {Œπ : Type v} {E‚ÇÅ : Œπ ‚Üí Type wE‚ÇÅ} {G : Type wG} [inst : NontriviallyNormedField ùïú]
  [inst_1 : (i : Œπ) ‚Üí SeminormedAddCommGroup (E‚ÇÅ i)] [inst_2 : (i : Œπ) ‚Üí NormedSpace ùïú (E‚ÇÅ i)]
  [inst_3 : SeminormedAddCommGroup G] [inst_4 : NormedSpace ùïú G] [inst_5 : Fintype Œπ] {Œ± : Type u_1}
  [inst_6 : Fintype Œ±] (f : ContinuousMultilinearMap ùïú E‚ÇÅ G) {s : Set Œπ} (e : Œ± ‚âÉ ‚Üës)
  [inst_7 : DecidablePred fun x => x ‚àà s] (v : (i : { a // a ‚àâ s }) ‚Üí E‚ÇÅ ‚Üëi) (w : Œ± ‚Üí (i : Œπ) ‚Üí E‚ÇÅ i),
  ((f.iteratedFDerivComponent e) v) w = f fun j => if h : j ‚àà s then w (e.symm ‚ü®j, h‚ü©) j else v ‚ü®j, h‚ü©
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || nontrivial_iff_lt : ‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±], Nontrivial Œ± ‚Üî ‚àÉ x y, x < y
Result.autoException ::
Auto failed to find proof

Testing || isUniformInducing_iff_uniformSpace : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : UniformSpace Œ±] [inst_1 : UniformSpace Œ≤] {f : Œ± ‚Üí Œ≤},
  IsUniformInducing f ‚Üî UniformSpace.comap f inst_1 = inst
Result.autoException ::
Auto failed to find proof

Testing || Ordinal.lt_omega0_opow_succ : ‚àÄ {a b : Ordinal.{u_1}}, a < Ordinal.omega0 ^ Order.succ b ‚Üî ‚àÉ n, a < Ordinal.omega0 ^ b * ‚Üën
Result.autoException ::
Auto failed to find proof

Testing || Affine.Simplex.centroid_eq_affineCombination_of_pointsWithCircumcenter : ‚àÄ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : MetricSpace P]
  [inst_3 : NormedAddTorsor V P] {n : ‚Ñï} (s : Affine.Simplex ‚Ñù P n) (fs : Finset (Fin (n + 1))),
  Finset.centroid ‚Ñù fs s.points =
    (Finset.affineCombination ‚Ñù Finset.univ s.pointsWithCircumcenter)
      (Affine.Simplex.centroidWeightsWithCircumcenter fs)
Result.autoException ::
Auto failed to find proof

Testing || List.prod_inv : ‚àÄ {G : Type u_7} [inst : CommGroup G] (L : List G), L.prod‚Åª¬π = (List.map (fun x => x‚Åª¬π) L).prod
Result.autoException ::
Auto failed to find proof

Testing || Filter.BoundedAtFilter.mul : ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : SeminormedRing Œ≤] {l : Filter Œ±} {f g : Œ± ‚Üí Œ≤},
  l.BoundedAtFilter f ‚Üí l.BoundedAtFilter g ‚Üí l.BoundedAtFilter (f * g)
Result.autoException ::
Auto failed to find proof

Testing || connectedComponentIn_mem_nhds : ‚àÄ {Œ± : Type u} [inst : TopologicalSpace Œ±] [inst_1 : LocallyConnectedSpace Œ±] {F : Set Œ±} {x : Œ±},
  F ‚àà nhds x ‚Üí connectedComponentIn F x ‚àà nhds x
Result.autoException ::
Auto failed to find proof

Testing || WithTop.coe_bot : ‚àÄ {Œ± : Type u_1} [inst : Bot Œ±], ‚Üë‚ä• = ‚ä•
Result.autoException ::
Auto failed to find proof

Testing || Sat.Clause.reify_zero : ‚àÄ {v : Sat.Valuation}, Sat.Clause.reify v Sat.Clause.nil True
Result.autoException ::
Auto failed to find proof

Testing || Ordinal.nadd_one : ‚àÄ (a : Ordinal.{u}), a.nadd 1 = Order.succ a
Result.autoException ::
Auto failed to find proof

Testing || QuotientMap.restrictPreimage_isOpen : ‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X ‚Üí Y},
  IsQuotientMap f ‚Üí ‚àÄ {s : Set Y}, IsOpen s ‚Üí IsQuotientMap (s.restrictPreimage f)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `instTopologicalSpaceSubtype`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || Equiv.piCongrLeft_apply : ‚àÄ {Œ± : Sort u_1} {Œ≤ : Sort u_4} (P : Œ≤ ‚Üí Sort w) (e : Œ± ‚âÉ Œ≤) (f : (a : Œ±) ‚Üí P (e a)) (b : Œ≤),
  (Equiv.piCongrLeft P e) f b = ‚ãØ ‚ñ∏ f (e.symm b)
Result.autoException ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || RingHom.locally_iff_exists : ‚àÄ {P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí (R ‚Üí+* S) ‚Üí Prop} {R S : Type u}
  [inst : CommRing R] [inst_1 : CommRing S],
  (RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P) ‚Üí
    ‚àÄ (f : R ‚Üí+* S),
      RingHom.Locally (fun {R S} [CommRing R] [CommRing S] => P) f ‚Üî
        ‚àÉ Œπ s,
          ‚àÉ (_ : Ideal.span (Set.range s) = ‚ä§),
            ‚àÉ S‚Çú x x_1, ‚àÉ (_ : ‚àÄ (i : Œπ), IsLocalization.Away (s i) (S‚Çú i)), ‚àÄ (i : Œπ), P ((algebraMap S (S‚Çú i)).comp f)
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type CommRing R‚úù of Œª binder contains bound variables

Testing || OrderIso.refl_toEquiv : ‚àÄ {Œ± : Type u_2} [inst : LE Œ±], (OrderIso.refl Œ±).toEquiv = Equiv.refl Œ±
Result.autoException ::
Auto failed to find proof

Testing || OrderIso.smulRightDual_symm_apply : ‚àÄ {Œ± : Type u_1} (Œ≤ : Type u_2) [inst : LinearOrderedField Œ±] [inst_1 : OrderedAddCommGroup Œ≤] [inst_2 : Module Œ± Œ≤]
  {a : Œ±} [inst_3 : PosSMulMono Œ± Œ≤] (ha : a < 0) (a_1 : Œ≤·µí·µà),
  (RelIso.symm (OrderIso.smulRightDual Œ≤ ha)) a_1 = a‚Åª¬π ‚Ä¢ OrderDual.ofDual a_1
Result.autoException ::
Auto failed to find proof

Testing || NormedAddGroupHom.completion_id : ‚àÄ {G : Type u_1} [inst : SeminormedAddCommGroup G],
  (NormedAddGroupHom.id G).completion = NormedAddGroupHom.id (UniformSpace.Completion G)
Result.success

Testing || AlgebraicGeometry.LocallyRingedSpace.HasCoequalizer.imageBasicOpen_image_preimage : ‚àÄ {X Y : AlgebraicGeometry.LocallyRingedSpace} (f g : X ‚ü∂ Y)
  (U :
    TopologicalSpace.Opens
      ‚Üë‚Üë(CategoryTheory.Limits.coequalizer (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom f)
              (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom g)).toPresheafedSpace)
  (s :
    ‚Üë((CategoryTheory.Limits.coequalizer (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom f)
              (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom g)).presheaf.obj
        (Opposite.op U))),
  ‚áë(CategoryTheory.Limits.coequalizer.œÄ (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom f)
            (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom g)).base ‚Åª¬π'
      (‚áë(CategoryTheory.Limits.coequalizer.œÄ (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom f)
              (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom g)).base ''
        (AlgebraicGeometry.LocallyRingedSpace.HasCoequalizer.imageBasicOpen f g U s).carrier) =
    (AlgebraicGeometry.LocallyRingedSpace.HasCoequalizer.imageBasicOpen f g U s).carrier
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Finset.max_of_mem : ‚àÄ {Œ± : Type u_2} [inst : LinearOrder Œ±] {s : Finset Œ±} {a : Œ±}, a ‚àà s ‚Üí ‚àÉ b, s.max = ‚Üëb
Result.autoException ::
Auto failed to find proof

Testing || tendsto_integral_exp_smul_cocompact : ‚àÄ {E : Type u_1} {V : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚ÑÇ E] (f : V ‚Üí E)
  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]
  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module ‚Ñù V] [inst_9 : ContinuousSMul ‚Ñù V]
  [inst_10 : FiniteDimensional ‚Ñù V] (Œº : MeasureTheory.Measure V) [inst_11 : Œº.IsAddHaarMeasure],
  Filter.Tendsto (fun w => ‚à´ (v : V), Real.fourierChar (-w v) ‚Ä¢ f v ‚àÇŒº) (Filter.cocompact (V ‚ÜíL[‚Ñù] ‚Ñù)) (nhds 0)
Result.autoException ::
Auto failed to find proof

Testing || Odd.zpow_neg_iff : ‚àÄ {Œ± : Type u_1} [inst : LinearOrderedField Œ±] {a : Œ±} {n : ‚Ñ§}, Odd n ‚Üí (a ^ n < 0 ‚Üî a < 0)
Result.autoException ::
Auto failed to find proof

Testing || Matrix.mul_kronecker_mul : ‚àÄ {Œ± : Type u_2} {l : Type u_8} {m : Type u_9} {n : Type u_10} {l' : Type u_14} {m' : Type u_15} {n' : Type u_16}
  [inst : Fintype m] [inst_1 : Fintype m'] [inst_2 : CommSemiring Œ±] (A : Matrix l m Œ±) (B : Matrix m n Œ±)
  (A' : Matrix l' m' Œ±) (B' : Matrix m' n' Œ±),
  Matrix.kroneckerMap (fun x1 x2 => x1 * x2) (A * B) (A' * B') =
    Matrix.kroneckerMap (fun x1 x2 => x1 * x2) A A' * Matrix.kroneckerMap (fun x1 x2 => x1 * x2) B B'
Result.autoException ::
Auto failed to find proof

Testing || Finset.sum_card_inter_le : ‚àÄ {Œ± : Type u_2} [inst : DecidableEq Œ±] {s : Finset Œ±} {B : Finset (Finset Œ±)} {n : ‚Ñï},
  (‚àÄ a ‚àà s, (Finset.filter (fun b => a ‚àà b) B).card ‚â§ n) ‚Üí ‚àë t ‚àà B, (s ‚à© t).card ‚â§ s.card * n
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.decidableMem x_0 a`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || Finset.div_def : ‚àÄ {Œ± : Type u_2} [inst : DecidableEq Œ±] [inst_1 : Div Œ±] {s t : Finset Œ±},
  s / t = Finset.image (fun p => p.1 / p.2) (s √óÀ¢ t)
Result.autoException ::
Auto failed to find proof

Testing || Set.inter_sub_union_subset_union : ‚àÄ {Œ± : Type u_2} [inst : Sub Œ±] {s‚ÇÅ s‚ÇÇ t‚ÇÅ t‚ÇÇ : Set Œ±}, s‚ÇÅ ‚à© s‚ÇÇ - (t‚ÇÅ ‚à™ t‚ÇÇ) ‚äÜ s‚ÇÅ - t‚ÇÅ ‚à™ (s‚ÇÇ - t‚ÇÇ)
Result.autoException ::
Auto failed to find proof

Testing || Orientation.oangle_sub_right_eq_arccos_of_oangle_eq_pi_div_two : ‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [hd2 : Fact (Module.finrank ‚Ñù V = 2)]
  (o : Orientation ‚Ñù V (Fin 2)) {x y : V},
  o.oangle x y = ‚Üë(Real.pi / 2) ‚Üí o.oangle y (y - x) = ‚Üë(Real.arccos (‚Äñy‚Äñ / ‚Äñy - x‚Äñ))
Result.success

Testing || MulAction.isInvariantBlock_iff_isFixedBlock : ‚àÄ {G : Type u_1} [inst : Group G] {X : Type u_2} [inst_1 : MulAction G X] {B : Set X},
  MulAction.IsInvariantBlock G B ‚Üî MulAction.IsFixedBlock G B
Result.autoException ::
Auto failed to find proof

Testing || WithTop.ofNat_eq_coe : ‚àÄ {Œ± : Type u} [inst : AddMonoidWithOne Œ±] (n : ‚Ñï) [inst_1 : n.AtLeastTwo] (m : Œ±),
  OfNat.ofNat n = ‚Üëm ‚Üî OfNat.ofNat n = m
Result.autoException ::
Auto failed to find proof

Testing || IsDedekindDomain.HeightOneSpectrum.intValuation_singleton : ‚àÄ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) {r : R},
  r ‚â† 0 ‚Üí v.asIdeal = Ideal.span {r} ‚Üí v.intValuation r = ‚Üë(Multiplicative.ofAdd (-1))
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (¬¨ ((!7 (!8 !4) !1) = (!9 (!10 !11 (- (iofNat (1 : Nat))))))) is not type correct

Testing || Action.Hom.comm_assoc : ‚àÄ {V : Type (u + 1)} [inst : CategoryTheory.LargeCategory V] {G : MonCat} {M N : Action V G} (self : M.Hom N) (g : ‚ÜëG)
  {Z : V} (h : N.V ‚ü∂ Z),
  CategoryTheory.CategoryStruct.comp (M.œÅ g) (CategoryTheory.CategoryStruct.comp self.hom h) =
    CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp (N.œÅ g) h)
Result.autoException ::
Auto failed to find proof

Testing || CauchySeq.tendsto_uniformity : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [uniformSpace : UniformSpace Œ±] [inst : Preorder Œ≤] {u : Œ≤ ‚Üí Œ±},
  CauchySeq u ‚Üí Filter.Tendsto (Prod.map u u) Filter.atTop (uniformity Œ±)
Result.autoException ::
Auto failed to find proof

Testing || TrivSqZeroExt.inlAlgHom_apply : ‚àÄ (S : Type u_1) (R : Type u) (M : Type v) [inst : CommSemiring S] [inst_1 : Semiring R] [inst_2 : AddCommMonoid M]
  [inst_3 : Algebra S R] [inst_4 : Module S M] [inst_5 : Module R M] [inst_6 : Module R·µê·µí·µñ M]
  [inst_7 : SMulCommClass R R·µê·µí·µñ M] [inst_8 : IsScalarTower S R M] [inst_9 : IsScalarTower S R·µê·µí·µñ M] (r : R),
  (TrivSqZeroExt.inlAlgHom S R M) r = TrivSqZeroExt.inl r
Result.autoException ::
Auto failed to find proof

Testing || Matroid.StrictRestriction.ssubset : ‚àÄ {Œ± : Type u_1} {M N : Matroid Œ±}, N.StrictRestriction M ‚Üí N.E ‚äÇ M.E
Result.autoException ::
Auto failed to find proof

Testing || RelEmbedding.sumLexInr_apply : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (r : Œ± ‚Üí Œ± ‚Üí Prop) (s : Œ≤ ‚Üí Œ≤ ‚Üí Prop) (val : Œ≤),
  (RelEmbedding.sumLexInr r s) val = Sum.inr val
Result.autoException ::
Auto failed to find proof

Testing || Algebra.embeddingsMatrix_apply : ‚àÄ {Œ∫ : Type w} (A : Type u) {B : Type v} (C : Type z) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]
  [inst_3 : CommRing C] [inst_4 : Algebra A C] (b : Œ∫ ‚Üí B) (i : Œ∫) (œÉ : B ‚Üí‚Çê[A] C),
  Algebra.embeddingsMatrix A C b i œÉ = œÉ (b i)
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix Œ∫ (B ‚Üí‚Çê[A] C) C is not a `‚àÄ`

Testing || Quaternion.coe_injective : ‚àÄ {R : Type u_3} [inst : CommRing R], Function.Injective Quaternion.coe
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `QuaternionAlgebra.coe`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || CategoryTheory.Limits.Cocone.mapCoconeToOver_inv_hom : ‚àÄ {J : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J] {C : Type u‚ÇÉ} [inst_1 : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C]
  {F : CategoryTheory.Functor J C} (c : CategoryTheory.Limits.Cocone F),
  c.mapCoconeToOver.inv.hom = CategoryTheory.CategoryStruct.id c.pt
Result.autoException ::
Auto failed to find proof

Testing || Antivary.inv_right : ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : OrderedCommGroup Œ±] [inst_1 : OrderedCommGroup Œ≤] {f : Œπ ‚Üí Œ±}
  {g : Œπ ‚Üí Œ≤}, Antivary f g ‚Üí Monovary f g‚Åª¬π
Result.autoException ::
Auto failed to find proof

Testing || Submonoid.coe_centralizer : ‚àÄ {M : Type u_1} (S : Set M) [inst : Monoid M], ‚Üë(Submonoid.centralizer S) = S.centralizer
Result.autoException ::
Auto failed to find proof

Testing || AddAction.quotient.proof_3 : ‚àÄ {Œ± : Type u_1} (Œ≤ : Type u_2) [inst : AddGroup Œ±] [inst_1 : AddMonoid Œ≤] [inst_2 : AddAction Œ≤ Œ±] (H : AddSubgroup Œ±)
  [inst_3 : AddAction.QuotientAction Œ≤ H] (b b' : Œ≤) (q : Œ± ‚ß∏ H), b + b' +·µ• q = b +·µ• (b' +·µ• q)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `QuotientAddGroup.leftRel x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || Cardinal.mk_pi : ‚àÄ {Œπ : Type u} (Œ± : Œπ ‚Üí Type v), Cardinal.mk ((i : Œπ) ‚Üí Œ± i) = Cardinal.prod fun i => Cardinal.mk (Œ± i)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Functor.surjective_toEventualRanges : ‚àÄ {J : Type u} [inst : CategoryTheory.Category.{u_1, u} J] (F : CategoryTheory.Functor J (Type v))
  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J],
  F.IsMittagLeffler ‚Üí ‚àÄ ‚¶Éi j : J‚¶Ñ (f : i ‚ü∂ j), Function.Surjective (F.toEventualRanges.map f)
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (¬¨ (!3 (!4 !5))) is not type correct

Testing || Class.coe_union : ‚àÄ (x y : ZFSet), ‚Üë(x ‚à™ y) = ‚Üëx ‚à™ ‚Üëy
Result.autoException ::
Auto failed to find proof

Testing || Matrix.GeneralLinearGroup.coe_mul : ‚àÄ {n : Type u} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (A B : GL n R),
  ‚Üë(A * B) = ‚ÜëA * ‚ÜëB
Result.autoException ::
Auto failed to find proof

Testing || WCovBy.ge_of_gt : ‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {a b c : Œ±}, a ‚©ø b ‚Üí a < c ‚Üí b ‚â§ c
Result.autoException ::
Auto failed to find proof

Testing || IsCyclic.exists_monoid_generator : ‚àÄ {Œ± : Type u} [inst : Group Œ±] [inst_1 : Finite Œ±] [inst_2 : IsCyclic Œ±], ‚àÉ x, ‚àÄ (y : Œ±), y ‚àà Submonoid.powers x
Result.success

Testing || Polynomial.rootOfSplits'_eq_rootOfSplits : ‚àÄ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K ‚Üí+* L) {f : Polynomial K}
  (hf : Polynomial.Splits i f) (hfd : (Polynomial.map i f).degree ‚â† 0),
  Polynomial.rootOfSplits' i hf hfd = Polynomial.rootOfSplits i hf ‚ãØ
Result.autoException ::
Auto failed to find proof

Testing || Booleanisation.comp_sdiff_comp : ‚àÄ {Œ± : Type u_1} [inst : GeneralizedBooleanAlgebra Œ±] (a b : Œ±),
  Booleanisation.comp a \ Booleanisation.comp b = Booleanisation.lift (b \ a)
Result.autoException ::
Auto failed to find proof

Testing || aemeasurable_lineDeriv : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] [inst_1 : LocallyCompactSpace ùïú] {E : Type u_2}
  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace ùïú E] [inst_4 : MeasurableSpace E]
  [inst_5 : OpensMeasurableSpace E] {F : Type u_3} [inst_6 : NormedAddCommGroup F] [inst_7 : NormedSpace ùïú F]
  [inst_8 : CompleteSpace F] {f : E ‚Üí F} {v : E} [inst_9 : MeasurableSpace F] [inst_10 : BorelSpace F],
  Continuous f ‚Üí ‚àÄ (Œº : MeasureTheory.Measure E), AEMeasurable (fun x => lineDeriv ùïú f x v) Œº
Result.success

Testing || ite_false : ‚àÄ {Œ± : Sort u_1} (a b : Œ±), (if False then a else b) = b
Result.success

Testing || linearEquivIsoModuleIso_hom : ‚àÄ {R : Type u} [inst : Ring R] {X Y : Type u} [inst_1 : AddCommGroup X] [inst_2 : AddCommGroup Y] [inst_3 : Module R X]
  [inst_4 : Module R Y] (e : X ‚âÉ‚Çó[R] Y), linearEquivIsoModuleIso.hom e = e.toModuleIso
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: (X ‚âÉ‚Çó[R] Y) ‚ü∂ ModuleCat.of R X ‚âÖ ModuleCat.of R Y is not a `‚àÄ`

Testing || Function.fixedPoints_subset_range : ‚àÄ {Œ± : Type u} {f : Œ± ‚Üí Œ±}, Function.fixedPoints f ‚äÜ Set.range f
Result.autoException ::
Auto failed to find proof

Testing || Prod.normedAddGroup.proof_2 : ‚àÄ {E : Type u_1} {F : Type u_2} [inst : NormedAddGroup E] [inst_1 : NormedAddGroup F] (x y : E √ó F), dist x y = ‚Äñx - y‚Äñ
Result.success

Testing || Prod.pow_swap : ‚àÄ {E : Type u_4} {Œ± : Type u_5} {Œ≤ : Type u_6} [inst : Pow Œ± E] [inst_1 : Pow Œ≤ E] (p : Œ± √ó Œ≤) (c : E),
  (p ^ c).swap = p.swap ^ c
Result.autoException ::
Auto failed to find proof

Testing || hasDerivAt_jacobiTheta‚ÇÇ_fst : ‚àÄ (z : ‚ÑÇ) {œÑ : ‚ÑÇ}, 0 < œÑ.im ‚Üí HasDerivAt (fun x => jacobiTheta‚ÇÇ x œÑ) (jacobiTheta‚ÇÇ' z œÑ) z
Result.autoException ::
Auto failed to find proof

Testing || _private.Mathlib.Algebra.Lie.BaseChange.0.LieAlgebra.ExtendScalars.bracket'_tmul : ‚àÄ (R : Type u_1) (A : Type u_2) (L : Type u_3) (M : Type u_4) [inst : CommRing R] [inst_1 : CommRing A]
  [inst_2 : Algebra R A] [inst_3 : LieRing L] [inst_4 : LieAlgebra R L] [inst_5 : AddCommGroup M] [inst_6 : Module R M]
  [inst_7 : LieRingModule L M] [inst_8 : LieModule R L M] (s t : A) (x : L) (m : M),
  ((LieAlgebra.ExtendScalars.bracket' R A L M) (s ‚äó‚Çú[R] x)) (t ‚äó‚Çú[R] m) = (s * t) ‚äó‚Çú[R] ‚ÅÖx, m‚ÅÜ
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.MorphismProperty.Comma.Hom.hom_left : ‚àÄ {A : Type u_1} [inst : CategoryTheory.Category.{u_4, u_1} A] {B : Type u_2}
  [inst_1 : CategoryTheory.Category.{u_5, u_2} B] {T : Type u_3} [inst_2 : CategoryTheory.Category.{u_6, u_3} T]
  {L : CategoryTheory.Functor A T} {R : CategoryTheory.Functor B T} {P : CategoryTheory.MorphismProperty T}
  {Q : CategoryTheory.MorphismProperty A} {W : CategoryTheory.MorphismProperty B}
  {X Y : CategoryTheory.MorphismProperty.Comma L R P Q W} (f : X.Hom Y), f.hom.left = f.left
Result.success

Testing || Nat.log_zero_right : ‚àÄ (b : ‚Ñï), Nat.log b 0 = 0
Result.autoException ::
Auto failed to find proof

Testing || ConvexOn.slope_le_deriv : ‚àÄ {S : Set ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù} {x y : ‚Ñù},
  ConvexOn ‚Ñù S f ‚Üí x ‚àà S ‚Üí y ‚àà S ‚Üí x < y ‚Üí DifferentiableAt ‚Ñù f y ‚Üí slope f x y ‚â§ deriv f y
Result.success

Testing || NonemptyFinLinOrd.dualEquiv_functor : NonemptyFinLinOrd.dualEquiv.functor = NonemptyFinLinOrd.dual
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.PreGaloisCategory.toAut_hom_app_apply : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C] (F : CategoryTheory.Functor C FintypeCat) {G : Type u_1}
  [inst_1 : Group G] [inst_2 : (X : C) ‚Üí MulAction G ‚Üë(F.obj X)]
  [inst_3 : CategoryTheory.PreGaloisCategory.IsNaturalSMul F G] (g : G) {X : C} (x : ‚Üë(F.obj X)),
  ((CategoryTheory.PreGaloisCategory.toAut F G) g).hom.app X x = g ‚Ä¢ x
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: F.obj X ‚ü∂ F.obj X is not a `‚àÄ`

Testing || Std.DHashMap.Internal.List.insertEntry_of_containsKey_eq_false : ‚àÄ {Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} [inst : BEq Œ±] {l : List ((a : Œ±) √ó Œ≤ a)} {k : Œ±} {v : Œ≤ k},
  Std.DHashMap.Internal.List.containsKey k l = false ‚Üí Std.DHashMap.Internal.List.insertEntry k v l = ‚ü®k, v‚ü© :: l
Result.autoException ::
Auto failed to find proof

Testing || AddSubmonoid.toOrderedAddCommMonoid.proof_2 : ‚àÄ {M : Type u_1} [inst : OrderedAddCommMonoid M] (S : AddSubmonoid M), Function.Injective fun a => ‚Üëa
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Subtype x_0 of Œª binder contains bound variables

Testing || HasFDerivWithinAt.multiset_prod : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] {s : Set E} {Œπ : Type u_5} {ùî∏' : Type u_7} [inst_3 : NormedCommRing ùî∏']
  [inst_4 : NormedAlgebra ùïú ùî∏'] {g : Œπ ‚Üí E ‚Üí ùî∏'} {g' : Œπ ‚Üí E ‚ÜíL[ùïú] ùî∏'} [inst_5 : DecidableEq Œπ] {u : Multiset Œπ}
  {x : E},
  (‚àÄ i ‚àà u, HasFDerivWithinAt (fun x => g i x) (g' i) s x) ‚Üí
    HasFDerivWithinAt (fun x => (Multiset.map (fun x_1 => g x_1 x) u).prod)
      (Multiset.map (fun i => (Multiset.map (fun x_1 => g x_1 x) (u.erase i)).prod ‚Ä¢ g' i) u).sum s x
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.attach`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || Complex.map_isometryOfOrthonormal : ‚àÄ {F : Type u_6} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ‚Ñù F] {F' : Type u_7}
  [inst_2 : NormedAddCommGroup F'] [inst_3 : InnerProductSpace ‚Ñù F'] (v : OrthonormalBasis (Fin 2) ‚Ñù F)
  (f : F ‚âÉ‚Çó·µ¢[‚Ñù] F'), Complex.isometryOfOrthonormal (v.map f) = (Complex.isometryOfOrthonormal v).trans f
Result.autoException ::
Auto failed to find proof

Testing || Finset.image_preimage : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : DecidableEq Œ≤] (f : Œ± ‚Üí Œ≤) (s : Finset Œ≤)
  [inst_1 : (x : Œ≤) ‚Üí Decidable (x ‚àà Set.range f)] (hf : Set.InjOn f (f ‚Åª¬π' ‚Üës)),
  Finset.image f (s.preimage f hf) = Finset.filter (fun x => x ‚àà Set.range f) s
Result.autoException ::
Auto failed to find proof

Testing || UInt32.toNat_ofNat_of_lt : ‚àÄ {n : ‚Ñï}, n < UInt32.size ‚Üí (UInt32.ofNat n).toNat = n
Result.success

Testing || SimpleGraph.comap_comap : ‚àÄ {V : Type u_1} {W : Type u_2} {X : Type u_3} {G : SimpleGraph X} (f : V ‚Üí W) (g : W ‚Üí X),
  SimpleGraph.comap f (SimpleGraph.comap g G) = SimpleGraph.comap (g ‚àò f) G
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Subobject.ofMkLE_comp_ofLEMk : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {B A‚ÇÅ A‚ÇÇ : C} (f : A‚ÇÅ ‚ü∂ B) [inst_1 : CategoryTheory.Mono f]
  (X : CategoryTheory.Subobject B) (g : A‚ÇÇ ‚ü∂ B) [inst_2 : CategoryTheory.Mono g]
  (h‚ÇÅ : CategoryTheory.Subobject.mk f ‚â§ X) (h‚ÇÇ : X ‚â§ CategoryTheory.Subobject.mk g),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X h‚ÇÅ) (X.ofLEMk g h‚ÇÇ) =
    CategoryTheory.Subobject.ofMkLEMk f g ‚ãØ
Result.autoException ::
Auto failed to find proof

Testing || Primrec.option_bind‚ÇÅ : ‚àÄ {Œ± : Type u_1} {œÉ : Type u_3} [inst : Primcodable Œ±] [inst_1 : Primcodable œÉ] {f : Œ± ‚Üí Option œÉ},
  Primrec f ‚Üí Primrec fun o => o.bind f
Result.autoException ::
Auto failed to find proof

Testing || HasStrictFDerivAt.congr_of_eventuallyEq : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {f f‚ÇÅ : E ‚Üí F}
  {f' : E ‚ÜíL[ùïú] F} {x : E}, HasStrictFDerivAt f f' x ‚Üí f =·∂†[nhds x] f‚ÇÅ ‚Üí HasStrictFDerivAt f‚ÇÅ f' x
Result.success

Testing || MeasureTheory.AEStronglyMeasurable.nullMeasurableSet_le : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±} [inst : TopologicalSpace Œ≤]
  [inst_1 : Preorder Œ≤] [inst_2 : OrderClosedTopology Œ≤] [inst_3 : TopologicalSpace.PseudoMetrizableSpace Œ≤]
  {f g : Œ± ‚Üí Œ≤},
  MeasureTheory.AEStronglyMeasurable f Œº ‚Üí
    MeasureTheory.AEStronglyMeasurable g Œº ‚Üí MeasureTheory.NullMeasurableSet {a | f a ‚â§ g a} Œº
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (‚àÄ x0 : #2, (‚àÄ x1 : #3, (‚àÄ x2 : #3, ((!6 x1 x0) ‚Üí ((!9 (!10 x0) x1 x2) ‚Üí (!6 x2 x0)))))) is not type correct

Testing || List.sorted_mergeSort : ‚àÄ {Œ± : Type u_1} {le : Œ± ‚Üí Œ± ‚Üí Bool},
  (‚àÄ (a b c : Œ±), le a b = true ‚Üí le b c = true ‚Üí le a c = true) ‚Üí
    (‚àÄ (a b : Œ±), (le a b || le b a) = true) ‚Üí ‚àÄ (l : List Œ±), List.Pairwise (fun a b => le a b = true) (l.mergeSort le)
Result.autoException ::
Auto.Lemma.rewriteUMonoRigid? :: Motive fun _a =>
  ‚àÄ {Œ± : Type u_1} {n : ‚Ñï} (l : { l // l.length = n }),
    (List.splitInTwo l).1 = ‚ü®List.take ((n + 1) / 2) ‚Üël, ‚ãØ‚ü© is not type correct

Testing || List.forall_mem_inter_of_forall_right : ‚àÄ {Œ± : Type u_1} {l‚ÇÇ : List Œ±} {p : Œ± ‚Üí Prop} [inst : DecidableEq Œ±] (l‚ÇÅ : List Œ±), (‚àÄ x ‚àà l‚ÇÇ, p x) ‚Üí ‚àÄ x ‚àà l‚ÇÅ ‚à© l‚ÇÇ, p x
Result.success

Testing || ULift.addCancelMonoid.proof_4 : ‚àÄ {Œ± : Type u_2} [inst : AddCancelMonoid Œ±] (x : ULift.{u_1, u_2} Œ±) (x_1 : ‚Ñï),
  Equiv.ulift (x_1 ‚Ä¢ x) = Equiv.ulift (x_1 ‚Ä¢ x)
Result.success

Testing || List.nextOr_nil : ‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (x d : Œ±), [].nextOr x d = d
Result.autoException ::
Auto failed to find proof

Testing || Std.HashSet.get?_erase_self : ‚àÄ {Œ± : Type u} {x : BEq Œ±} {x_1 : Hashable Œ±} {m : Std.HashSet Œ±} [inst : EquivBEq Œ±] [inst : LawfulHashable Œ±] {k : Œ±},
  (m.erase k).get? k = none
Result.autoException ::
Auto failed to find proof

Testing || Rat.mk'_zero : ‚àÄ (d : ‚Ñï) (h : d ‚â† 0) (w : (Int.natAbs 0).Coprime d), { num := 0, den := d, den_nz := h, reduced := w } = 0
Result.autoException ::
Auto failed to find proof

Testing || Set.prod_univ : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Set Œ±}, s √óÀ¢ Set.univ = Prod.fst ‚Åª¬π' s
Result.autoException ::
Auto failed to find proof

Testing || tangentMapWithin_id : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ùïú E H} {M : Type u_4}
  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] {s : Set M} {p : TangentBundle I M},
  UniqueMDiffWithinAt I s p.proj ‚Üí tangentMapWithin I I id s p = p
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `instTopologicalSpaceTangentSpace
  x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || affineSegment_eq_segment : ‚àÄ (R : Type u_1) {V : Type u_2} [inst : OrderedRing R] [inst_1 : AddCommGroup V] [inst_2 : Module R V] (x y : V),
  affineSegment R x y = segment R x y
Result.success

Testing || RingHom.OfLocalizationSpanTarget.ofIsLocalization : ‚àÄ {P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí (R ‚Üí+* S) ‚Üí Prop},
  (RingHom.OfLocalizationSpanTarget fun {R S} [CommRing R] [CommRing S] => P) ‚Üí
    (RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P) ‚Üí
      ‚àÄ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (f : R ‚Üí+* S) (s : Set S),
        Ideal.span s = ‚ä§ ‚Üí
          (‚àÄ (r : ‚Üës), ‚àÉ T x x_1, ‚àÉ (_ : IsLocalization.Away (‚Üër) T), P ((algebraMap S T).comp f)) ‚Üí P f
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type CommRing R‚úù of Œª binder contains bound variables

Testing || CompHausLike.LocallyConstant.functor_obj_val : ‚àÄ (P : TopCat ‚Üí Prop) [inst : CompHausLike.HasExplicitFiniteCoproducts P] [inst_1 : CompHausLike.HasExplicitPullbacks P]
  (hs : ‚àÄ ‚¶ÉX Y : CompHausLike P‚¶Ñ (f : X ‚ü∂ Y), CategoryTheory.EffectiveEpi f ‚Üí Function.Surjective ‚áëf)
  (X : Type (max u w)),
  ((CompHausLike.LocallyConstant.functor P hs).obj X).val = CompHausLike.LocallyConstant.functorToPresheaves.obj X
Result.autoException ::
Auto failed to find proof

Testing || MeasureTheory.Measure.measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet : ‚àÄ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G]
  [inst_3 : MeasurableSpace G] [inst_4 : BorelSpace G] [inst_5 : LocallyCompactSpace G] (Œº' Œº : MeasureTheory.Measure G)
  [inst_6 : Œº.IsHaarMeasure] [inst_7 : MeasureTheory.IsFiniteMeasureOnCompacts Œº'] [inst_8 : Œº'.IsMulLeftInvariant]
  {s : Set G}, MeasurableSet s ‚Üí IsCompact (closure s) ‚Üí Œº' s = Œº'.haarScalarFactor Œº ‚Ä¢ Œº s
Result.autoException ::
Auto failed to find proof

Testing || Mod_.comap_obj_X : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C] {A B : Mon_ C}
  (f : A ‚ü∂ B) (M : Mod_ B), ((Mod_.comap f).obj M).X = M.X
Result.autoException ::
Auto failed to find proof

Testing || ContinuousLinearMap.coe_zero : ‚àÄ {R‚ÇÅ : Type u_1} {R‚ÇÇ : Type u_2} [inst : Semiring R‚ÇÅ] [inst_1 : Semiring R‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R‚ÇÅ ‚Üí+* R‚ÇÇ} {M‚ÇÅ : Type u_4}
  [inst_2 : TopologicalSpace M‚ÇÅ] [inst_3 : AddCommMonoid M‚ÇÅ] {M‚ÇÇ : Type u_6} [inst_4 : TopologicalSpace M‚ÇÇ]
  [inst_5 : AddCommMonoid M‚ÇÇ] [inst_6 : Module R‚ÇÅ M‚ÇÅ] [inst_7 : Module R‚ÇÇ M‚ÇÇ], ‚Üë0 = 0
Result.autoException ::
Auto failed to find proof

Testing || Function.Injective2.uncurry : ‚àÄ {Œ± : Type u_4} {Œ≤ : Type u_5} {Œ≥ : Type u_6} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥},
  Function.Injective2 f ‚Üí Function.Injective (Function.uncurry f)
Result.autoException ::
Auto failed to find proof

Testing || FirstOrder.Language.ElementaryEmbedding.refl_apply : ‚àÄ {L : FirstOrder.Language} {M : Type u_1} [inst : L.Structure M] (x : M),
  (FirstOrder.Language.ElementaryEmbedding.refl L M) x = x
Result.autoException ::
Auto failed to find proof

Testing || Cycle.isCycle_formPerm : ‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] (s : Cycle Œ±) (h : s.Nodup), s.Nontrivial ‚Üí (s.formPerm h).IsCycle
Result.autoException ::
Auto failed to find proof

Testing || Matrix.inv_subsingleton : ‚àÄ {m : Type u} {Œ± : Type v} [inst : CommRing Œ±] [inst_1 : Subsingleton m] [inst_2 : Fintype m] [inst_3 : DecidableEq m]
  (A : Matrix m m Œ±), A‚Åª¬π = Matrix.diagonal fun i => Ring.inverse (A i i)
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix m m Œ± is not a `‚àÄ`

Testing || Submodule.dualAnnihilator_sup_eq : ‚àÄ {R : Type u} {M : Type v} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]
  (U V : Submodule R M), (U ‚äî V).dualAnnihilator = U.dualAnnihilator ‚äì V.dualAnnihilator
Result.autoException ::
Auto failed to find proof

Testing || not_isMin : ‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] [inst_1 : NoMinOrder Œ±] (a : Œ±), ¬¨IsMin a
Result.success

Testing || Combinatorics.Line.vertical_apply : ‚àÄ {Œ± : Type u_5} {Œπ : Type u_6} {Œπ' : Type u_7} (v : Œπ ‚Üí Œ±) (l : Combinatorics.Line Œ± Œπ') (x : Œ±),
  (fun x i => ((Combinatorics.Line.vertical v l).idxFun i).getD x) x = Sum.elim v ((fun x i => (l.idxFun i).getD x) x)
Result.autoException ::
Auto failed to find proof

Testing || QuasiIsoAt.quasiIso : ‚àÄ {Œπ : Type u_1} {C : Type u} {inst : CategoryTheory.Category.{v, u} C}
  {inst_1 : CategoryTheory.Limits.HasZeroMorphisms C} {c : ComplexShape Œπ} {K L : HomologicalComplex C c} {f : K ‚ü∂ L}
  {i : Œπ} {inst_2 : K.HasHomology i} {inst_3 : L.HasHomology i} [self : QuasiIsoAt f i],
  CategoryTheory.ShortComplex.QuasiIso ((HomologicalComplex.shortComplexFunctor C c i).map f)
Result.autoException ::
Auto failed to find proof

Testing || Continuous.locallyIntegrable : ‚àÄ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]
  {f : X ‚Üí E} {Œº : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]
  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure Œº] [inst_5 : SecondCountableTopologyEither X E],
  Continuous f ‚Üí MeasureTheory.LocallyIntegrable f Œº
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.simplicialToCosimplicialAugmented_map_right : ‚àÄ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] {X Y : (CategoryTheory.SimplicialObject.Augmented C)·µí·µñ}
  (f : X ‚ü∂ Y),
  ((CategoryTheory.simplicialToCosimplicialAugmented C).map f).right = CategoryTheory.NatTrans.rightOp f.unop.left
Result.autoException ::
Auto failed to find proof

Testing || contDiffOn_succ_iff_fderiv_apply : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {D : Type uD} [inst_1 : NormedAddCommGroup D]
  [inst_2 : NormedSpace ùïú D] {E : Type uE} [inst_3 : NormedAddCommGroup E] [inst_4 : NormedSpace ùïú E]
  [inst_5 : CompleteSpace ùïú] [inst_6 : FiniteDimensional ùïú D] {n : ‚Ñï} {f : D ‚Üí E} {s : Set D},
  UniqueDiffOn ùïú s ‚Üí
    (ContDiffOn ùïú (‚Üë(n + 1)) f s ‚Üî
      DifferentiableOn ùïú f s ‚àß ‚àÄ (y : D), ContDiffOn ùïú (‚Üën) (fun x => (fderivWithin ùïú f s x) y) s)
Result.success

Testing || Finset.insert_erase : ‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} {a : Œ±}, a ‚àà s ‚Üí insert a (s.erase a) = s
Result.autoException ::
Auto failed to find proof

Testing || PartENat.lt_add_one_iff_lt : ‚àÄ {x y : PartENat}, x ‚â† ‚ä§ ‚Üí (x < y + 1 ‚Üî x ‚â§ y)
Result.success

Testing || CategoryTheory.ShortComplex.Homotopy.refl_h‚ÇÄ : ‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  {S‚ÇÅ S‚ÇÇ : CategoryTheory.ShortComplex C} (œÜ : S‚ÇÅ ‚ü∂ S‚ÇÇ), (CategoryTheory.ShortComplex.Homotopy.refl œÜ).h‚ÇÄ = 0
Result.autoException ::
Auto failed to find proof

Testing || NonUnitalContinuousFunctionalCalculus.predicate_zero : ‚àÄ (R : Type u_1) {A : Type u_2} {p : outParam (A ‚Üí Prop)} {inst : CommSemiring R} {inst_1 : Nontrivial R}
  {inst_2 : StarRing R} {inst_3 : MetricSpace R} {inst_4 : TopologicalSemiring R} {inst_5 : ContinuousStar R}
  {inst_6 : NonUnitalRing A} {inst_7 : StarRing A} {inst_8 : TopologicalSpace A} {inst_9 : Module R A}
  {inst_10 : IsScalarTower R A A} {inst_11 : SMulCommClass R A A} [self : NonUnitalContinuousFunctionalCalculus R p],
  p 0
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: outParam (A ‚Üí Prop) is not a `‚àÄ`

Testing || Filter.Germ.instAddMonoid.proof_3 : ‚àÄ {Œ± : Type u_2} {l : Filter Œ±} {M : Type u_1} [inst : AddMonoid M] (x x_1 : Œ± ‚Üí M), ‚Üë(x + x_1) = ‚Üë(x + x_1)
Result.success

Testing || TensorProduct.SMul.aux_of : ‚àÄ {R : Type u_1} [inst : CommSemiring R] {M : Type u_4} {N : Type u_5} [inst_1 : AddCommMonoid M]
  [inst_2 : AddCommMonoid N] [inst_3 : Module R M] [inst_4 : Module R N] {R' : Type u_10} [inst_5 : SMul R' M] (r : R')
  (m : M) (n : N), (TensorProduct.SMul.aux r) (FreeAddMonoid.of (m, n)) = (r ‚Ä¢ m) ‚äó‚Çú[R] n
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.ComposableArrows.ext‚ÇÅ : ‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {F G : CategoryTheory.ComposableArrows C 1}
  (left : F.left = G.left) (right : F.right = G.right),
  F.hom =
      CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom left)
        (CategoryTheory.CategoryStruct.comp G.hom (CategoryTheory.eqToHom ‚ãØ)) ‚Üí
    F = G
Result.autoException ::
Auto failed to find proof

Testing || Fin.Ioo_eq_finset_subtype : ‚àÄ {n : ‚Ñï} (a b : Fin n), Finset.Ioo a b = Finset.fin n (Finset.Ioo ‚Üëa ‚Üëb)
Result.autoException ::
Auto failed to find proof

Testing || Pi.ringHom_injective : ‚àÄ {I : Type u} {f : I ‚Üí Type v} {Œ≥ : Type w} [inst : Nonempty I] [inst : (i : I) ‚Üí NonAssocSemiring (f i)]
  [inst_1 : NonAssocSemiring Œ≥] (g : (i : I) ‚Üí Œ≥ ‚Üí+* f i),
  (‚àÄ (i : I), Function.Injective ‚áë(g i)) ‚Üí Function.Injective ‚áë(Pi.ringHom g)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `inst‚úù¬π x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
¬∑ Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
¬∑ Œª binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
¬∑ (TODO)

Testing || MeasureTheory.mul_meas_ge_le_pow_eLpNorm : ‚àÄ {Œ± : Type u_1} {E : Type u_2} {m0 : MeasurableSpace Œ±} [inst : NormedAddCommGroup E] {p : ENNReal}
  (Œº : MeasureTheory.Measure Œ±) {f : Œ± ‚Üí E},
  p ‚â† 0 ‚Üí
    p ‚â† ‚ä§ ‚Üí
      MeasureTheory.AEStronglyMeasurable f Œº ‚Üí
        ‚àÄ (Œµ : ENNReal), Œµ * Œº {x | Œµ ‚â§ ‚Üë‚Äñf x‚Äñ‚Çä ^ p.toReal} ‚â§ MeasureTheory.eLpNorm f p Œº ^ p.toReal
Result.autoException ::
Auto failed to find proof

Testing || Orientation.map_symm : ‚àÄ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]
  {N : Type u_3} [inst_3 : AddCommMonoid N] [inst_4 : Module R N] (Œπ : Type u_4) (e : M ‚âÉ‚Çó[R] N),
  (Orientation.map Œπ e).symm = Orientation.map Œπ e.symm
Result.autoException ::
Auto failed to find proof

Testing || TopologicalSpace.Opens.map_eq : ‚àÄ {X Y : TopCat} (f g : X ‚ü∂ Y), f = g ‚Üí TopologicalSpace.Opens.map f = TopologicalSpace.Opens.map g
Result.success

Testing || IsometryEquiv.surjective : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] (h : Œ± ‚âÉ·µ¢ Œ≤),
  Function.Surjective ‚áëh
Result.autoException ::
Auto failed to find proof

Testing || hasMFDerivWithinAt_extChartAt : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners ùïú E H} {M : Type u_4}
  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M}
  {x y : M},
  y ‚àà (chartAt H x).source ‚Üí
    HasMFDerivWithinAt I (modelWithCornersSelf ùïú E) (‚Üë(extChartAt I x)) s y (mfderiv I I (‚Üë(chartAt H x)) y)
Result.success

Testing || AddHom.op.proof_4 : ‚àÄ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (x : AddHom M·µÉ·µí·µñ N·µÉ·µí·µñ),
  (fun f => { toFun := AddOpposite.op ‚àò ‚áëf ‚àò AddOpposite.unop, map_add' := ‚ãØ })
      ((fun f => { toFun := AddOpposite.unop ‚àò ‚áëf ‚àò AddOpposite.op, map_add' := ‚ãØ }) x) =
    (fun f => { toFun := AddOpposite.op ‚àò ‚áëf ‚àò AddOpposite.unop, map_add' := ‚ãØ })
      ((fun f => { toFun := AddOpposite.unop ‚àò ‚áëf ‚àò AddOpposite.op, map_add' := ‚ãØ }) x)
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Function.Injective AddOpposite.unop is not a `‚àÄ`

Testing || CategoryTheory.Comonad.cofree_obj_A : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] (G : CategoryTheory.Comonad C) (X : C),
  (G.cofree.obj X).A = G.obj X
Result.autoException ::
Auto failed to find proof

Testing || Matroid.ground_finite : ‚àÄ {Œ± : Type u_1} (M : Matroid Œ±) [inst : M.Finite], M.E.Finite
Result.autoException ::
Auto failed to find proof

Testing || Nat.testBit_and : ‚àÄ (x y i : ‚Ñï), (x &&& y).testBit i = (x.testBit i && y.testBit i)
Result.autoException ::
Auto failed to find proof

Testing || Function.support_comp_eq_preimage : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {M : Type u_5} [inst : Zero M] (g : Œ≤ ‚Üí M) (f : Œ± ‚Üí Œ≤),
  Function.support (g ‚àò f) = f ‚Åª¬π' Function.support g
Result.autoException ::
Auto failed to find proof

Testing || DFinsupp.lapply_comp_lsingle_of_ne : ‚àÄ {Œπ : Type u_1} {R : Type u_2} {M : Œπ ‚Üí Type u_4} [inst : Semiring R] [inst_1 : (i : Œπ) ‚Üí AddCommMonoid (M i)]
  [inst_2 : (i : Œπ) ‚Üí Module R (M i)] [inst_3 : DecidableEq Œπ] (i i' : Œπ),
  i ‚â† i' ‚Üí DFinsupp.lapply i ‚àò‚Çó DFinsupp.lsingle i' = 0
Result.autoException ::
Auto failed to find proof

Elapsed time: 986305 ms
