Config = {maxHeartbeats := 65536, timeout := 10, solverConfig = smt z3, logFile := evalOut.txt}

Testing || Int.natAbs_one : Int.natAbs 1 = 1
Result.autoException ::
Auto failed to find proof

Testing || HNNExtension.NormalWord.group_smul_def : ‚àÄ {G : Type u_1} [inst : Group G] {A B : Subgroup G} {d : HNNExtension.NormalWord.TransversalPair G A B} (g : G)
  (w : HNNExtension.NormalWord d), g ‚Ä¢ w = { head := g * w.head, toList := w.toList, chain := ‚ãØ, mem_set := ‚ãØ }
Result.autoException ::
Auto failed to find proof

Testing || Batteries.RBNode.balance2_eq : ‚àÄ {Œ± : Type u_1} {c : Batteries.RBColor} {n : ‚Ñï} {l : Batteries.RBNode Œ±} {v : Œ±} {r : Batteries.RBNode Œ±},
  r.Balanced c n ‚Üí l.balance2 v r = Batteries.RBNode.node Batteries.RBColor.black l v r
Result.autoException ::
Auto failed to find proof

Testing || PMF.toOuterMeasure_bind_apply : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} (p : PMF Œ±) (f : Œ± ‚Üí PMF Œ≤) (s : Set Œ≤),
  (p.bind f).toOuterMeasure s = ‚àë' (a : Œ±), p a * (f a).toOuterMeasure s
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_1.indicator (cifvar_10 x_0) x`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || PEquiv.single_trans_single_of_ne : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type w} [inst : DecidableEq Œ±] [inst_1 : DecidableEq Œ≤] [inst_2 : DecidableEq Œ≥]
  {b‚ÇÅ b‚ÇÇ : Œ≤}, b‚ÇÅ ‚â† b‚ÇÇ ‚Üí ‚àÄ (a : Œ±) (c : Œ≥), (PEquiv.single a b‚ÇÅ).trans (PEquiv.single b‚ÇÇ c) = ‚ä•
Result.success

Testing || Equiv.bijOn_swap : ‚àÄ {Œ± : Type u_1} {s : Set Œ±} [inst : DecidableEq Œ±] {a b : Œ±}, a ‚àà s ‚Üí b ‚àà s ‚Üí Set.BijOn (‚áë(Equiv.swap a b)) s s
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Set.BijOn (cifvar_7 x_0) x_1 x_2`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || Matrix.kroneckerMap_zero_right : ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_4} {Œ≥ : Type u_6} {l : Type u_8} {m : Type u_9} {n : Type u_10} {p : Type u_11}
  [inst : Zero Œ≤] [inst_1 : Zero Œ≥] (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥),
  (‚àÄ (a : Œ±), f a 0 = 0) ‚Üí ‚àÄ (A : Matrix l m Œ±), Matrix.kroneckerMap f A 0 = 0
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Matrix_l_m_Œ±:
  ;;   |_Matrix_l_m_Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Matrix_l_m_Œ±!val!0| () _Matrix_l_m_Œ±)
  ;; cardinality constraint:
  (forall ((x _Matrix_l_m_Œ±)) (= x |_Matrix_l_m_Œ±!val!0|))
  ;; -----------
  ;; universe for _Matrix_n_p_Œ≤:
  ;;   |_Matrix_n_p_Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Matrix_n_p_Œ≤!val!0| () _Matrix_n_p_Œ≤)
  ;; cardinality constraint:
  (forall ((x _Matrix_n_p_Œ≤)) (= x |_Matrix_n_p_Œ≤!val!0|))
  ;; -----------
  ;; universe for _Matrix_l___n_m___p_Œ≥:
  ;;   |_Matrix_l___n_m___p_Œ≥!val!1| |_Matrix_l___n_m___p_Œ≥!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Matrix_l___n_m___p_Œ≥!val!1| () _Matrix_l___n_m___p_Œ≥)
  (declare-fun |_Matrix_l___n_m___p_Œ≥!val!0| () _Matrix_l___n_m___p_Œ≥)
  ;; cardinality constraint:
  (forall ((x _Matrix_l___n_m___p_Œ≥))
          (or (= x |_Matrix_l___n_m___p_Œ≥!val!1|)
              (= x |_Matrix_l___n_m___p_Œ≥!val!0|)))
  ;; -----------
  ;; universe for _Œ≥:
  ;;   |_Œ≥!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ≥!val!0| () _Œ≥)
  ;; cardinality constraint:
  (forall ((x _Œ≥)) (= x |_Œ≥!val!0|))
  ;; -----------
  ;; universe for _Œ≤:
  ;;   |_Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ≤!val!0| () _Œ≤)
  ;; cardinality constraint:
  (forall ((x _Œ≤)) (= x |_Œ≤!val!0|))
  ;; -----------
  (define-fun _0__1 () _Matrix_n_p_Œ≤
    |_Matrix_n_p_Œ≤!val!0|)
  (define-fun _A () _Matrix_l_m_Œ±
    |_Matrix_l_m_Œ±!val!0|)
  (define-fun valid_fact_0 () Bool
    (forall ((|_Œ±| _Œ±_0)) (= (_f |_Œ±| _0_) _0__0)))
  (define-fun valid_fact_1 () Bool
    (not (= (_Matrix.kroneckerMap_f _A _0__1) _0__2)))
  (define-fun _0__0 () _Œ≥
    |_Œ≥!val!0|)
  (define-fun _0__2 () _Matrix_l___n_m___p_Œ≥
    |_Matrix_l___n_m___p_Œ≥!val!1|)
  (define-fun _0_ () _Œ≤
    |_Œ≤!val!0|)
  (define-fun _Matrix.kroneckerMap_f ((x!0 _Matrix_l_m_Œ±) (x!1 _Matrix_n_p_Œ≤)) _Matrix_l___n_m___p_Œ≥
    |_Matrix_l___n_m___p_Œ≥!val!0|)
  (define-fun _f ((x!0 _Œ±_0) (x!1 _Œ≤)) _Œ≥
    |_Œ≥!val!0|)
)


Testing || HomogeneousIdeal.toIdeal_add : ‚àÄ {Œπ : Type u_1} {œÉ : Type u_2} {A : Type u_3} [inst : Semiring A] [inst_1 : DecidableEq Œπ] [inst_2 : AddMonoid Œπ]
  [inst_3 : SetLike œÉ A] [inst_4 : AddSubmonoidClass œÉ A] {ùíú : Œπ ‚Üí œÉ} [inst_5 : GradedRing ùíú]
  (I J : HomogeneousIdeal ùíú), (I + J).toIdeal = I.toIdeal + J.toIdeal
Result.autoException ::
Auto failed to find proof

Testing || List.nodup_rotate : ‚àÄ {Œ± : Type u} {l : List Œ±} {n : ‚Ñï}, (l.rotate n).Nodup ‚Üî l.Nodup
Result.success

Testing || Submodule.le_comap_pow_of_le_comap : ‚àÄ {R : Type u_1} {M : Type u_5} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M] (p : Submodule R M)
  {f : M ‚Üí‚Çó[R] M}, p ‚â§ Submodule.comap f p ‚Üí ‚àÄ (k : ‚Ñï), p ‚â§ Submodule.comap (f ^ k) p
Result.autoException ::
Auto failed to find proof

Testing || FiniteField.isSquare_neg_two_iff : ‚àÄ {F : Type u_1} [inst : Field F] [inst_1 : Fintype F], IsSquare (-2) ‚Üî Fintype.card F % 8 ‚â† 5 ‚àß Fintype.card F % 8 ‚â† 7
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `quadraticChar cifvar_54`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || HasSum.hasSum_at_zero : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] (a : ‚Ñï ‚Üí E), HasSum (fun n => 0 ^ n ‚Ä¢ a n) (a 0)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `SMulWithZero.toSMulZeroClass`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || AddOreLocalization.oreSub_add_oreSub : ‚àÄ {R : Type u_1} [inst : AddMonoid R] {S : AddSubmonoid R} [inst_1 : AddOreLocalization.AddOreSet S] {r‚ÇÅ r‚ÇÇ : R}
  {s‚ÇÅ s‚ÇÇ : ‚Ü•S},
  r‚ÇÅ -‚Çí s‚ÇÅ + (r‚ÇÇ -‚Çí s‚ÇÇ) = AddOreLocalization.oreMin r‚ÇÅ s‚ÇÇ + r‚ÇÇ -‚Çí (AddOreLocalization.oreSubtra r‚ÇÅ s‚ÇÇ + s‚ÇÅ)
Result.autoException ::
Auto failed to find proof

Testing || sectionOfRetractionKerToTensor_algebraMap : ‚àÄ {R P S : Type u} [inst : CommRing R] [inst_1 : CommRing P] [inst_2 : CommRing S] [inst_3 : Algebra R P]
  [inst_4 : Algebra P S] (l : TensorProduct P S (Œ©[P‚ÅÑR]) ‚Üí‚Çó[P] ‚Ü•(RingHom.ker (algebraMap P S)))
  (hl : l ‚àò‚Çó KaehlerDifferential.kerToTensor R P S = LinearMap.id) [inst_5 : Algebra R S] [inst_6 : IsScalarTower R P S]
  (hf' : RingHom.ker (algebraMap P S) ^ 2 = ‚ä•) (hf : Function.Surjective ‚áë(algebraMap P S)) (x : P),
  (sectionOfRetractionKerToTensor l hl hf' hf) ((algebraMap P S) x) = x - ‚Üë(l (1 ‚äó‚Çú[P] (KaehlerDifferential.D R P) x))
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _l____KaehlerDifferential.kerToTensor_R_P_S_=_LinearMap.id:
  ;;   _l____KaehlerDifferential.kerToTensor_R_P_S_=_LinearMap.id!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _l____KaehlerDifferential.kerToTensor_R_P_S_=_LinearMap.id!val!0 () _l____KaehlerDifferential.kerToTensor_R_P_S_=_LinearMap.id)
  ;; cardinality constraint:
  (forall ((x _l____KaehlerDifferential.kerToTensor_R_P_S_=_LinearMap.id))
          (= x _l____KaehlerDifferential.kerToTensor_R_P_S_=_LinearMap.id!val!0))
  ;; -----------
  ;; universe for _RingHom.ker_algebraMap_P_S_^_2_=__:
  ;;   _RingHom.ker_algebraMap_P_S_^_2_=__!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _RingHom.ker_algebraMap_P_S_^_2_=__!val!0 () _RingHom.ker_algebraMap_P_S_^_2_=__)
  ;; cardinality constraint:
  (forall ((x _RingHom.ker_algebraMap_P_S_^_2_=__))
          (= x _RingHom.ker_algebraMap_P_S_^_2_=__!val!0))
  ;; -----------
  ;; universe for _Function.Surjective__algebraMap_P_S_0:
  ;;   _Function.Surjective__algebraMap_P_S_0!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _Function.Surjective__algebraMap_P_S_0!val!0 () _Function.Surjective__algebraMap_P_S_0)
  ;; cardinality constraint:
  (forall ((x _Function.Surjective__algebraMap_P_S_0))
          (= x _Function.Surjective__algebraMap_P_S_0!val!0))
  ;; -----------
  ;; universe for _S____R__P:
  ;;   _S____R__P!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _S____R__P!val!0 () _S____R__P)
  ;; cardinality constraint:
  (forall ((x _S____R__P)) (= x _S____R__P!val!0))
  ;; -----------
  ;; universe for _P__+*_S:
  ;;   _P__+*_S!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _P__+*_S!val!0 () _P__+*_S)
  ;; cardinality constraint:
  (forall ((x _P__+*_S)) (= x _P__+*_S!val!0))
  ;; -----------
  ;; universe for _P:
  ;;   _P!val!0 _P!val!1 _P!val!2 _P!val!3 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _P!val!0 () _P)
  (declare-fun _P!val!1 () _P)
  (declare-fun _P!val!2 () _P)
  (declare-fun _P!val!3 () _P)
  ;; cardinality constraint:
  (forall ((x _P))
          (or (= x _P!val!0) (= x _P!val!1) (= x _P!val!2) (= x _P!val!3)))
  ;; -----------
  ;; universe for _S:
  ;;   _S!val!1 _S!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _S!val!1 () _S)
  (declare-fun _S!val!0 () _S)
  ;; cardinality constraint:
  (forall ((x _S)) (or (= x _S!val!1) (= x _S!val!0)))
  ;; -----------
  ;; universe for _TensorProduct_P_S_Œ©_P_R_____P___RingHom.ker_algebraMap_P_S:
  ;;   |_TensorProduct_P_S_Œ©_P_R_____P___RingHom.ker_algebraMap_P_S!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_TensorProduct_P_S_Œ©_P_R_____P___RingHom.ker_algebraMap_P_S!val!0| () _TensorProduct_P_S_Œ©_P_R_____P___RingHom.ker_algebraMap_P_S)
  ;; cardinality constraint:
  (forall ((x _TensorProduct_P_S_Œ©_P_R_____P___RingHom.ker_algebraMap_P_S))
          (= x
             |_TensorProduct_P_S_Œ©_P_R_____P___RingHom.ker_algebraMap_P_S!val!0|))
  ;; -----------
  ;; universe for _Derivation_R_P_Œ©_P_R_:
  ;;   |_Derivation_R_P_Œ©_P_R_!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Derivation_R_P_Œ©_P_R_!val!0| () _Derivation_R_P_Œ©_P_R_)
  ;; cardinality constraint:
  (forall ((x _Derivation_R_P_Œ©_P_R_)) (= x |_Derivation_R_P_Œ©_P_R_!val!0|))
  ;; -----------
  ;; universe for _Œ©_P_R_:
  ;;   |_Œ©_P_R_!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ©_P_R_!val!0| () _Œ©_P_R_)
  ;; cardinality constraint:
  (forall ((x _Œ©_P_R_)) (= x |_Œ©_P_R_!val!0|))
  ;; -----------
  ;; universe for _TensorProduct_P_S_Œ©_P_R_:
  ;;   |_TensorProduct_P_S_Œ©_P_R_!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_TensorProduct_P_S_Œ©_P_R_!val!0| () _TensorProduct_P_S_Œ©_P_R_)
  ;; cardinality constraint:
  (forall ((x _TensorProduct_P_S_Œ©_P_R_))
          (= x |_TensorProduct_P_S_Œ©_P_R_!val!0|))
  ;; -----------
  ;; universe for __RingHom.ker_algebraMap_P_S:
  ;;   __RingHom.ker_algebraMap_P_S!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun __RingHom.ker_algebraMap_P_S!val!0 () __RingHom.ker_algebraMap_P_S)
  ;; cardinality constraint:
  (forall ((x __RingHom.ker_algebraMap_P_S))
          (= x __RingHom.ker_algebraMap_P_S!val!0))
  ;; -----------
  (define-fun _IsScalarTower_R_P_S () Bool
    true)
  (define-fun _l () _TensorProduct_P_S_Œ©_P_R_____P___RingHom.ker_algebraMap_P_S
    |_TensorProduct_P_S_Œ©_P_R_____P___RingHom.ker_algebraMap_P_S!val!0|)
  (define-fun _hf_ () _RingHom.ker_algebraMap_P_S_^_2_=__
    _RingHom.ker_algebraMap_P_S_^_2_=__!val!0)
  (define-fun _1_ () _S
    _S!val!1)
  (define-fun _algebraMap_P_S () _P__+*_S
    _P__+*_S!val!0)
  (define-fun _x () _P
    _P!val!0)
  (define-fun _hf () _Function.Surjective__algebraMap_P_S_0
    _Function.Surjective__algebraMap_P_S_0!val!0)
  (define-fun valid_fact_1 () Bool
    _Function.Surjective__algebraMap_P_S)
  (define-fun valid_fact_2 () Bool
    (let ((a!1 (_Subtype.val (_DFunLike.coe_2 _l
                                          (_TensorProduct.tmul_P
                                            _1_
                                            (_DFunLike.coe_1 _KaehlerDifferential.D_R_P
                                                             _x))))))
  (not (= (_DFunLike.coe_0 (_fun_hl_=>_sectionOfRetractionKerToTensor_l_hl
                             _hl
                             _hf_
                             _hf)
                           (_DFunLike.coe _algebraMap_P_S _x))
          (_HSub.hSub _x a!1)))))
  (define-fun _KaehlerDifferential.D_R_P () _Derivation_R_P_Œ©_P_R_
    |_Derivation_R_P_Œ©_P_R_!val!0|)
  (define-fun valid_fact_0 () Bool
    _IsScalarTower_R_P_S)
  (define-fun _hl () _l____KaehlerDifferential.kerToTensor_R_P_S_=_LinearMap.id
    _l____KaehlerDifferential.kerToTensor_R_P_S_=_LinearMap.id!val!0)
  (define-fun _Function.Surjective__algebraMap_P_S () Bool
    true)
  (define-fun _DFunLike.coe_1 ((x!0 _Derivation_R_P_Œ©_P_R_) (x!1 _P)) _Œ©_P_R_
    |_Œ©_P_R_!val!0|)
  (define-fun _fun_hl_=>_sectionOfRetractionKerToTensor_l_hl ((x!0
    _l____KaehlerDifferential.kerToTensor_R_P_S_=_LinearMap.id)
   (x!1 _RingHom.ker_algebraMap_P_S_^_2_=__)
   (x!2 _Function.Surjective__algebraMap_P_S_0)) _S____R__P
    _S____R__P!val!0)
  (define-fun _DFunLike.coe_0 ((x!0 _S____R__P) (x!1 _S)) _P
    _P!val!1)
  (define-fun _TensorProduct.tmul_P ((x!0 _S) (x!1 _Œ©_P_R_)) _TensorProduct_P_S_Œ©_P_R_
    |_TensorProduct_P_S_Œ©_P_R_!val!0|)
  (define-fun _DFunLike.coe ((x!0 _P__+*_S) (x!1 _P)) _S
    _S!val!0)
  (define-fun _DFunLike.coe_2 ((x!0
    _TensorProduct_P_S_Œ©_P_R_____P___RingHom.ker_algebraMap_P_S)
   (x!1 _TensorProduct_P_S_Œ©_P_R_)) __RingHom.ker_algebraMap_P_S
    __RingHom.ker_algebraMap_P_S!val!0)
  (define-fun _Subtype.val ((x!0 __RingHom.ker_algebraMap_P_S)) _P
    _P!val!2)
  (define-fun _HSub.hSub ((x!0 _P) (x!1 _P)) _P
    _P!val!3)
)


Testing || Set.up_image : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MulOneClass Œ±] [inst_1 : MulOneClass Œ≤] (f : Œ± ‚Üí* Œ≤) (s : Set Œ±),
  Set.up (‚áëf '' s) = (SetSemiring.imageHom f) (Set.up s)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Set_Œ≤___SetSemiring_Œ≤:
  ;;   |_Set_Œ≤___SetSemiring_Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_Œ≤___SetSemiring_Œ≤!val!0| () _Set_Œ≤___SetSemiring_Œ≤)
  ;; cardinality constraint:
  (forall ((x _Set_Œ≤___SetSemiring_Œ≤)) (= x |_Set_Œ≤___SetSemiring_Œ≤!val!0|))
  ;; -----------
  ;; universe for _Set_Œ±:
  ;;   |_Set_Œ±!val!1| |_Set_Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_Œ±!val!1| () _Set_Œ±)
  (declare-fun |_Set_Œ±!val!0| () _Set_Œ±)
  ;; cardinality constraint:
  (forall ((x _Set_Œ±)) (or (= x |_Set_Œ±!val!1|) (= x |_Set_Œ±!val!0|)))
  ;; -----------
  ;; universe for _SetSemiring_Œ≤:
  ;;   |_SetSemiring_Œ≤!val!2| |_SetSemiring_Œ≤!val!1| |_SetSemiring_Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_SetSemiring_Œ≤!val!2| () _SetSemiring_Œ≤)
  (declare-fun |_SetSemiring_Œ≤!val!1| () _SetSemiring_Œ≤)
  (declare-fun |_SetSemiring_Œ≤!val!0| () _SetSemiring_Œ≤)
  ;; cardinality constraint:
  (forall ((x _SetSemiring_Œ≤))
          (or (= x |_SetSemiring_Œ≤!val!2|)
              (= x |_SetSemiring_Œ≤!val!1|)
              (= x |_SetSemiring_Œ≤!val!0|)))
  ;; -----------
  ;; universe for _Œ±__*_Œ≤:
  ;;   |_Œ±__*_Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ±__*_Œ≤!val!0| () _Œ±__*_Œ≤)
  ;; cardinality constraint:
  (forall ((x _Œ±__*_Œ≤)) (= x |_Œ±__*_Œ≤!val!0|))
  ;; -----------
  ;; universe for _SetSemiring_Œ±__+*_SetSemiring_Œ≤:
  ;;   |_SetSemiring_Œ±__+*_SetSemiring_Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_SetSemiring_Œ±__+*_SetSemiring_Œ≤!val!0| () _SetSemiring_Œ±__+*_SetSemiring_Œ≤)
  ;; cardinality constraint:
  (forall ((x _SetSemiring_Œ±__+*_SetSemiring_Œ≤))
          (= x |_SetSemiring_Œ±__+*_SetSemiring_Œ≤!val!0|))
  ;; -----------
  ;; universe for _Set_Œ±___SetSemiring_Œ±:
  ;;   |_Set_Œ±___SetSemiring_Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_Œ±___SetSemiring_Œ±!val!0| () _Set_Œ±___SetSemiring_Œ±)
  ;; cardinality constraint:
  (forall ((x _Set_Œ±___SetSemiring_Œ±)) (= x |_Set_Œ±___SetSemiring_Œ±!val!0|))
  ;; -----------
  (define-fun _s () _Set_Œ±
    |_Set_Œ±!val!0|)
  (define-fun valid_fact_0 () Bool
    (not (= (_DFunLike.coe _Set.up (_Set.image__f _s))
        (_DFunLike.coe_1 (_SetSemiring.imageHom _f)
                         (_DFunLike.coe_0 _Set.up_0 _s)))))
  (define-fun _f () _Œ±__*_Œ≤
    |_Œ±__*_Œ≤!val!0|)
  (define-fun _Set.up_0 () _Set_Œ±___SetSemiring_Œ±
    |_Set_Œ±___SetSemiring_Œ±!val!0|)
  (define-fun _Set.up () _Set_Œ≤___SetSemiring_Œ≤
    |_Set_Œ≤___SetSemiring_Œ≤!val!0|)
  (define-fun _DFunLike.coe_0 ((x!0 _Set_Œ±___SetSemiring_Œ±) (x!1 _Set_Œ±)) _Set_Œ±
    |_Set_Œ±!val!1|)
  (define-fun _DFunLike.coe_1 ((x!0 _SetSemiring_Œ±__+*_SetSemiring_Œ≤)
   (x!1 _Set_Œ±)) _SetSemiring_Œ≤
    |_SetSemiring_Œ≤!val!2|)
  (define-fun _Set.image__f ((x!0 _Set_Œ±)) _SetSemiring_Œ≤
    |_SetSemiring_Œ≤!val!0|)
  (define-fun _DFunLike.coe ((x!0 _Set_Œ≤___SetSemiring_Œ≤) (x!1 _SetSemiring_Œ≤)) _SetSemiring_Œ≤
    |_SetSemiring_Œ≤!val!1|)
  (define-fun _SetSemiring.imageHom ((x!0 _Œ±__*_Œ≤)) _SetSemiring_Œ±__+*_SetSemiring_Œ≤
    |_SetSemiring_Œ±__+*_SetSemiring_Œ≤!val!0|)
)


Testing || CategoryTheory.Limits.pullbackConeOfRightIso_œÄ_app_right : ‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)
  [inst_1 : CategoryTheory.IsIso g],
  (CategoryTheory.Limits.pullbackConeOfRightIso f g).œÄ.app CategoryTheory.Limits.WalkingCospan.right =
    CategoryTheory.CategoryStruct.comp f (CategoryTheory.inv g)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.PreGaloisCategory.fiberEqualizerEquiv_symm_Œπ_apply : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{u‚ÇÇ, u‚ÇÅ} C] (F : CategoryTheory.Functor C FintypeCat)
  [inst_1 : CategoryTheory.PreGaloisCategory C] [inst_2 : CategoryTheory.PreGaloisCategory.FiberFunctor F] {X Y : C}
  {f g : X ‚ü∂ Y} (x : ‚Üë(F.obj X)) (h : F.map f x = F.map g x),
  F.map (CategoryTheory.Limits.equalizer.Œπ f g)
      ((CategoryTheory.PreGaloisCategory.fiberEqualizerEquiv F f g).symm ‚ü®x, h‚ü©) =
    x
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: F.obj X ‚ü∂ F.obj Y is not a `‚àÄ`

Testing || CategoryTheory.Limits.prod.lift_fst_snd : ‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {X Y : C}
  [inst_1 : CategoryTheory.Limits.HasBinaryProduct X Y],
  CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd =
    CategoryTheory.CategoryStruct.id (X ‚®Ø Y)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.Limits.limit.lift
  (cifvar_1 cifvar_2 cifvar_3) x_0`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || Matrix.SpecialLinearGroup.mem_center_iff : ‚àÄ {n : Type u} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R]
  {A : Matrix.SpecialLinearGroup n R},
  A ‚àà Subgroup.center (Matrix.SpecialLinearGroup n R) ‚Üî ‚àÉ r, r ^ Fintype.card n = 1 ‚àß (Matrix.scalar n) r = ‚ÜëA
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix n n R is not a `‚àÄ`

Testing || LinearPMap.zero_domain : ‚àÄ {R : Type u_1} [inst : Ring R] {E : Type u_2} [inst_1 : AddCommGroup E] [inst_2 : Module R E] {F : Type u_3}
  [inst_3 : AddCommGroup F] [inst_4 : Module R F], LinearPMap.domain 0 = ‚ä§
Result.autoException ::
Auto failed to find proof

Testing || char_dvd_card_solutions_of_sum_lt : ‚àÄ {K : Type u_1} {œÉ : Type u_2} {Œπ : Type u_3} [inst : Fintype K] [inst_1 : Field K] [inst_2 : Fintype œÉ]
  [inst_3 : DecidableEq œÉ] [inst_4 : DecidableEq K] (p : ‚Ñï) [inst_5 : CharP K p] {s : Finset Œπ}
  {f : Œπ ‚Üí MvPolynomial œÉ K},
  ‚àë i ‚àà s, (f i).totalDegree < Fintype.card œÉ ‚Üí p ‚à£ Fintype.card { x // ‚àÄ i ‚àà s, (MvPolynomial.eval x) (f i) = 0 }
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `GroupWithZero.toMonoidWithZero`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || NNRat.num_coe : ‚àÄ (q : ‚Ñö‚â•0), (‚Üëq).num = ‚Üëq.num
Result.autoException ::
Auto failed to find proof

Testing || Int.bmod_one_is_zero : ‚àÄ (x : ‚Ñ§), x.bmod 1 = 0
Result.autoException ::
Auto failed to find proof

Testing || Nat.rel_of_forall_rel_succ_of_lt : ‚àÄ {Œ≤ : Type v} (r : Œ≤ ‚Üí Œ≤ ‚Üí Prop) [inst : IsTrans Œ≤ r] {f : ‚Ñï ‚Üí Œ≤},
  (‚àÄ (n : ‚Ñï), r (f n) (f (n + 1))) ‚Üí ‚àÄ ‚¶Éa b : ‚Ñï‚¶Ñ, a < b ‚Üí r (f a) (f b)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Œ≤:
  ;;   |_Œ≤!val!8| |_Œ≤!val!7| |_Œ≤!val!14| |_Œ≤!val!4| |_Œ≤!val!16| |_Œ≤!val!12| |_Œ≤!val!10| |_Œ≤!val!17| |_Œ≤!val!15| |_Œ≤!val!13| |_Œ≤!val!21| |_Œ≤!val!22| |_Œ≤!val!18| |_Œ≤!val!23| |_Œ≤!val!11| |_Œ≤!val!3| |_Œ≤!val!1| |_Œ≤!val!2| |_Œ≤!val!5| |_Œ≤!val!6| |_Œ≤!val!19| |_Œ≤!val!9| |_Œ≤!val!20| |_Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ≤!val!8| () _Œ≤)
  (declare-fun |_Œ≤!val!7| () _Œ≤)
  (declare-fun |_Œ≤!val!14| () _Œ≤)
  (declare-fun |_Œ≤!val!4| () _Œ≤)
  (declare-fun |_Œ≤!val!16| () _Œ≤)
  (declare-fun |_Œ≤!val!12| () _Œ≤)
  (declare-fun |_Œ≤!val!10| () _Œ≤)
  (declare-fun |_Œ≤!val!17| () _Œ≤)
  (declare-fun |_Œ≤!val!15| () _Œ≤)
  (declare-fun |_Œ≤!val!13| () _Œ≤)
  (declare-fun |_Œ≤!val!21| () _Œ≤)
  (declare-fun |_Œ≤!val!22| () _Œ≤)
  (declare-fun |_Œ≤!val!18| () _Œ≤)
  (declare-fun |_Œ≤!val!23| () _Œ≤)
  (declare-fun |_Œ≤!val!11| () _Œ≤)
  (declare-fun |_Œ≤!val!3| () _Œ≤)
  (declare-fun |_Œ≤!val!1| () _Œ≤)
  (declare-fun |_Œ≤!val!2| () _Œ≤)
  (declare-fun |_Œ≤!val!5| () _Œ≤)
  (declare-fun |_Œ≤!val!6| () _Œ≤)
  (declare-fun |_Œ≤!val!19| () _Œ≤)
  (declare-fun |_Œ≤!val!9| () _Œ≤)
  (declare-fun |_Œ≤!val!20| () _Œ≤)
  (declare-fun |_Œ≤!val!0| () _Œ≤)
  ;; cardinality constraint:
  (forall ((x _Œ≤))
          (or (= x |_Œ≤!val!8|)
              (= x |_Œ≤!val!7|)
              (= x |_Œ≤!val!14|)
              (= x |_Œ≤!val!4|)
              (= x |_Œ≤!val!16|)
              (= x |_Œ≤!val!12|)
              (= x |_Œ≤!val!10|)
              (= x |_Œ≤!val!17|)
              (= x |_Œ≤!val!15|)
              (= x |_Œ≤!val!13|)
              (= x |_Œ≤!val!21|)
              (= x |_Œ≤!val!22|)
              (= x |_Œ≤!val!18|)
              (= x |_Œ≤!val!23|)
              (= x |_Œ≤!val!11|)
              (= x |_Œ≤!val!3|)
              (= x |_Œ≤!val!1|)
              (= x |_Œ≤!val!2|)
              (= x |_Œ≤!val!5|)
              (= x |_Œ≤!val!6|)
              (= x |_Œ≤!val!19|)
              (= x |_Œ≤!val!9|)
              (= x |_Œ≤!val!20|)
              (= x |_Œ≤!val!0|)))
  ;; -----------
  (define-fun _a () Int
    28995)
  (define-fun valid_fact_3 () Bool
    (not (_r (_f _a) (_f _b))))
  (define-fun valid_fact_2 () Bool
    (not (<= _b _a)))
  (define-fun valid_fact_4 () Bool
    true)
  (define-fun valid_fact_1 () Bool
    (forall ((_n Int)) (or (not (>= _n 0)) (_r (_f _n) (_f (+ 1 _n))))))
  (define-fun valid_fact_0 () Bool
    |_IsTrans_Œ≤_r|)
  (define-fun |_IsTrans_Œ≤_r| () Bool
    true)
  (define-fun _b () Int
    28997)
  (define-fun _f ((x!0 Int)) _Œ≤
    (let ((a!1 (ite (and (<= 28994 x!0) (<= 28995 x!0) (not (<= 28996 x!0)))
                    |_Œ≤!val!0|
                    |_Œ≤!val!23|)))
    (let ((a!2 (ite (and (<= 28994 x!0)
                         (<= 28995 x!0)
                         (<= 28996 x!0)
                         (not (<= 28997 x!0)))
                    |_Œ≤!val!1|
                    a!1)))
    (let ((a!3 (ite (and (<= 28994 x!0)
                         (<= 28995 x!0)
                         (<= 28996 x!0)
                         (<= 28997 x!0)
                         (not (<= 28998 x!0)))
                    |_Œ≤!val!2|
                    a!2)))
    (let ((a!4 (ite (and (<= 28994 x!0)
                         (<= 28995 x!0)
                         (<= 28996 x!0)
                         (<= 28997 x!0)
                         (<= 28998 x!0)
                         (not (<= 28999 x!0)))
                    |_Œ≤!val!3|
                    a!3)))
    (let ((a!5 (ite (and (<= 28994 x!0)
                         (<= 28995 x!0)
                         (<= 28996 x!0)
                         (<= 28997 x!0)
                         (<= 28998 x!0)
                         (<= 28999 x!0)
                         (not (<= 29000 x!0)))
                    |_Œ≤!val!4|
                    a!4)))
    (let ((a!6 (ite (and (<= 28994 x!0)
                         (<= 28995 x!0)
                         (<= 28996 x!0)
                         (<= 28997 x!0)
                         (<= 28998 x!0)
                         (<= 28999 x!0)
                         (<= 29000 x!0)
                         (not (<= 29001 x!0)))
                    |_Œ≤!val!5|
                    a!5)))
    (let ((a!7 (ite (and (<= 28994 x!0)
                         (<= 28995 x!0)
                         (<= 28996 x!0)
                         (<= 28997 x!0)
                         (<= 28998 x!0)
                         (<= 28999 x!0)
                         (<= 29000 x!0)
                         (<= 29001 x!0)
                         (not (<= 29002 x!0)))
                    |_Œ≤!val!6|
                    a!6)))
    (let ((a!8 (ite (and (<= 28994 x!0)
                         (<= 28995 x!0)
                         (<= 28996 x!0)
                         (<= 28997 x!0)
                         (<= 28998 x!0)
                         (<= 28999 x!0)
                         (<= 29000 x!0)
                         (<= 29001 x!0)
                         (<= 29002 x!0)
                         (not (<= 29003 x!0)))
                    |_Œ≤!val!7|
                    a!7)))
    (let ((a!9 (ite (and (<= 28994 x!0)
                         (<= 28995 x!0)
                         (<= 28996 x!0)
                         (<= 28997 x!0)
                         (<= 28998 x!0)
                         (<= 28999 x!0)
                         (<= 29000 x!0)
                         (<= 29001 x!0)
                         (<= 29002 x!0)
                         (<= 29003 x!0)
                         (not (<= 29004 x!0)))
                    |_Œ≤!val!8|
                    a!8)))
    (let ((a!10 (ite (and (<= 28994 x!0)
                          (<= 28995 x!0)
                          (<= 28996 x!0)
                          (<= 28997 x!0)
                          (<= 28998 x!0)
                          (<= 28999 x!0)
                          (<= 29000 x!0)
                          (<= 29001 x!0)
                          (<= 29002 x!0)
                          (<= 29003 x!0)
                          (<= 29004 x!0)
                          (not (<= 29005 x!0)))
                     |_Œ≤!val!9|
                     a!9)))
    (let ((a!11 (ite (and (<= 28994 x!0)
                          (<= 28995 x!0)
                          (<= 28996 x!0)
                          (<= 28997 x!0)
                          (<= 28998 x!0)
                          (<= 28999 x!0)
                          (<= 29000 x!0)
                          (<= 29001 x!0)
                          (<= 29002 x!0)
                          (<= 29003 x!0)
                          (<= 29004 x!0)
                          (<= 29005 x!0)
                          (not (<= 29006 x!0)))
                     |_Œ≤!val!10|
                     a!10)))
    (let ((a!12 (ite (and (<= 28994 x!0)
                          (<= 28995 x!0)
                          (<= 28996 x!0)
                          (<= 28997 x!0)
                          (<= 28998 x!0)
                          (<= 28999 x!0)
                          (<= 29000 x!0)
                          (<= 29001 x!0)
                          (<= 29002 x!0)
                          (<= 29003 x!0)
                          (<= 29004 x!0)
                          (<= 29005 x!0)
                          (<= 29006 x!0)
                          (not (<= 29007 x!0)))
                     |_Œ≤!val!11|
                     a!11)))
    (let ((a!13 (ite (and (<= 28994 x!0)
                          (<= 28995 x!0)
                          (<= 28996 x!0)
                          (<= 28997 x!0)
                          (<= 28998 x!0)
                          (<= 28999 x!0)
                          (<= 29000 x!0)
                          (<= 29001 x!0)
                          (<= 29002 x!0)
                          (<= 29003 x!0)
                          (<= 29004 x!0)
                          (<= 29005 x!0)
                          (<= 29006 x!0)
                          (<= 29007 x!0)
                          (not (<= 29008 x!0)))
                     |_Œ≤!val!12|
                     a!12)))
    (let ((a!14 (ite (and (<= 28994 x!0)
                          (<= 28995 x!0)
                          (<= 28996 x!0)
                          (<= 28997 x!0)
                          (<= 28998 x!0)
                          (<= 28999 x!0)
                          (<= 29000 x!0)
                          (<= 29001 x!0)
                          (<= 29002 x!0)
                          (<= 29003 x!0)
                          (<= 29004 x!0)
                          (<= 29005 x!0)
                          (<= 29006 x!0)
                          (<= 29007 x!0)
                          (<= 29008 x!0)
                          (not (<= 29009 x!0)))
                     |_Œ≤!val!13|
                     a!13)))
    (let ((a!15 (ite (and (<= 28994 x!0)
                          (<= 28995 x!0)
                          (<= 28996 x!0)
                          (<= 28997 x!0)
                          (<= 28998 x!0)
                          (<= 28999 x!0)
                          (<= 29000 x!0)
                          (<= 29001 x!0)
                          (<= 29002 x!0)
                          (<= 29003 x!0)
                          (<= 29004 x!0)
                          (<= 29005 x!0)
                          (<= 29006 x!0)
                          (<= 29007 x!0)
                          (<= 29008 x!0)
                          (<= 29009 x!0)
                          (not (<= 29010 x!0)))
                     |_Œ≤!val!14|
                     a!14)))
    (let ((a!16 (ite (and (<= 28994 x!0)
                          (<= 28995 x!0)
                          (<= 28996 x!0)
                          (<= 28997 x!0)
                          (<= 28998 x!0)
                          (<= 28999 x!0)
                          (<= 29000 x!0)
                          (<= 29001 x!0)
                          (<= 29002 x!0)
                          (<= 29003 x!0)
                          (<= 29004 x!0)
                          (<= 29005 x!0)
                          (<= 29006 x!0)
                          (<= 29007 x!0)
                          (<= 29008 x!0)
                          (<= 29009 x!0)
                          (<= 29010 x!0)
                          (not (<= 29011 x!0)))
                     |_Œ≤!val!15|
                     a!15)))
    (let ((a!17 (ite (and (<= 28994 x!0)
                          (<= 28995 x!0)
                          (<= 28996 x!0)
                          (<= 28997 x!0)
                          (<= 28998 x!0)
                          (<= 28999 x!0)
                          (<= 29000 x!0)
                          (<= 29001 x!0)
                          (<= 29002 x!0)
                          (<= 29003 x!0)
                          (<= 29004 x!0)
                          (<= 29005 x!0)
                          (<= 29006 x!0)
                          (<= 29007 x!0)
                          (<= 29008 x!0)
                          (<= 29009 x!0)
                          (<= 29010 x!0)
                          (<= 29011 x!0)
                          (not (<= 29012 x!0)))
                     |_Œ≤!val!16|
                     a!16)))
    (let ((a!18 (ite (and (<= 28994 x!0)
                          (<= 28995 x!0)
                          (<= 28996 x!0)
                          (<= 28997 x!0)
                          (<= 28998 x!0)
                          (<= 28999 x!0)
                          (<= 29000 x!0)
                          (<= 29001 x!0)
                          (<= 29002 x!0)
                          (<= 29003 x!0)
                          (<= 29004 x!0)
                          (<= 29005 x!0)
                          (<= 29006 x!0)
                          (<= 29007 x!0)
                          (<= 29008 x!0)
                          (<= 29009 x!0)
                          (<= 29010 x!0)
                          (<= 29011 x!0)
                          (<= 29012 x!0)
                          (not (<= 29013 x!0)))
                     |_Œ≤!val!17|
                     a!17)))
    (let ((a!19 (ite (and (<= 28994 x!0)
                          (<= 28995 x!0)
                          (<= 28996 x!0)
                          (<= 28997 x!0)
                          (<= 28998 x!0)
                          (<= 28999 x!0)
                          (<= 29000 x!0)
                          (<= 29001 x!0)
                          (<= 29002 x!0)
                          (<= 29003 x!0)
                          (<= 29004 x!0)
                          (<= 29005 x!0)
                          (<= 29006 x!0)
                          (<= 29007 x!0)
                          (<= 29008 x!0)
                          (<= 29009 x!0)
                          (<= 29010 x!0)
                          (<= 29011 x!0)
                          (<= 29012 x!0)
                          (<= 29013 x!0)
                          (not (<= 29014 x!0)))
                     |_Œ≤!val!18|
                     a!18)))
    (let ((a!20 (ite (and (<= 28994 x!0)
                          (<= 28995 x!0)
                          (<= 28996 x!0)
                          (<= 28997 x!0)
                          (<= 28998 x!0)
                          (<= 28999 x!0)
                          (<= 29000 x!0)
                          (<= 29001 x!0)
                          (<= 29002 x!0)
                          (<= 29003 x!0)
                          (<= 29004 x!0)
                          (<= 29005 x!0)
                          (<= 29006 x!0)
                          (<= 29007 x!0)
                          (<= 29008 x!0)
                          (<= 29009 x!0)
                          (<= 29010 x!0)
                          (<= 29011 x!0)
                          (<= 29012 x!0)
                          (<= 29013 x!0)
                          (<= 29014 x!0)
                          (not (<= 29015 x!0)))
                     |_Œ≤!val!19|
                     a!19)))
    (let ((a!21 (ite (and (<= 28994 x!0)
                          (<= 28995 x!0)
                          (<= 28996 x!0)
                          (<= 28997 x!0)
                          (<= 28998 x!0)
                          (<= 28999 x!0)
                          (<= 29000 x!0)
                          (<= 29001 x!0)
                          (<= 29002 x!0)
                          (<= 29003 x!0)
                          (<= 29004 x!0)
                          (<= 29005 x!0)
                          (<= 29006 x!0)
                          (<= 29007 x!0)
                          (<= 29008 x!0)
                          (<= 29009 x!0)
                          (<= 29010 x!0)
                          (<= 29011 x!0)
                          (<= 29012 x!0)
                          (<= 29013 x!0)
                          (<= 29014 x!0)
                          (<= 29015 x!0)
                          (<= 29016 x!0)
                          (not (<= 29017 x!0)))
                     |_Œ≤!val!20|
                     a!20)))
    (let ((a!22 (ite (and (<= 28994 x!0)
                          (<= 28995 x!0)
                          (<= 28996 x!0)
                          (<= 28997 x!0)
                          (<= 28998 x!0)
                          (<= 28999 x!0)
                          (<= 29000 x!0)
                          (<= 29001 x!0)
                          (<= 29002 x!0)
                          (<= 29003 x!0)
                          (<= 29004 x!0)
                          (<= 29005 x!0)
                          (<= 29006 x!0)
                          (<= 29007 x!0)
                          (<= 29008 x!0)
                          (<= 29009 x!0)
                          (<= 29010 x!0)
                          (<= 29011 x!0)
                          (<= 29012 x!0)
                          (<= 29013 x!0)
                          (<= 29014 x!0)
                          (<= 29015 x!0)
                          (not (<= 29016 x!0)))
                     |_Œ≤!val!21|
                     a!21)))
      (ite (and (<= 28994 x!0)
                (<= 28995 x!0)
                (<= 28996 x!0)
                (<= 28997 x!0)
                (<= 28998 x!0)
                (<= 28999 x!0)
                (<= 29000 x!0)
                (<= 29001 x!0)
                (<= 29002 x!0)
                (<= 29003 x!0)
                (<= 29004 x!0)
                (<= 29005 x!0)
                (<= 29006 x!0)
                (<= 29007 x!0)
                (<= 29008 x!0)
                (<= 29009 x!0)
                (<= 29010 x!0)
                (<= 29011 x!0)
                (<= 29012 x!0)
                (<= 29013 x!0)
                (<= 29014 x!0)
                (<= 29015 x!0)
                (<= 29016 x!0)
                (<= 29017 x!0))
           |_Œ≤!val!22|
           a!22))))))))))))))))))))))))
  (define-fun _r ((x!0 _Œ≤) (x!1 _Œ≤)) Bool
    (ite (and (= x!0 |_Œ≤!val!0|) (= x!1 |_Œ≤!val!2|)) false
      true))
)


Testing || le_of_forall_pos_sub_le : ‚àÄ {Œ± : Type u_1} [inst : AddGroup Œ±] [inst_1 : LinearOrder Œ±] [inst_2 : AddLeftMono Œ±] [inst_3 : DenselyOrdered Œ±]
  {a b : Œ±}, (‚àÄ (Œµ : Œ±), 0 < Œµ ‚Üí a - Œµ ‚â§ b) ‚Üí a ‚â§ b
Result.success

Testing || HomologicalComplexUpToQuasiIso.Q_map_eq_of_homotopy : ‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_3, u_1} C] {Œπ : Type u_2} {c : ComplexShape Œπ}
  [inst_1 : CategoryTheory.Preadditive C] [inst_2 : CategoryTheory.CategoryWithHomology C]
  [inst_3 : (HomologicalComplex.quasiIso C c).HasLocalization] [inst_4 : c.QFactorsThroughHomotopy C]
  {K L : HomologicalComplex C c} {f g : K ‚ü∂ L},
  Homotopy f g ‚Üí HomologicalComplexUpToQuasiIso.Q.map f = HomologicalComplexUpToQuasiIso.Q.map g
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _ComplexShape_Œπ:
  ;;   |_ComplexShape_Œπ!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_ComplexShape_Œπ!val!0| () _ComplexShape_Œπ)
  ;; cardinality constraint:
  (forall ((x _ComplexShape_Œπ)) (= x |_ComplexShape_Œπ!val!0|))
  ;; -----------
  ;; universe for _K___L:
  ;;   _K___L!val!0 _K___L!val!1 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _K___L!val!0 () _K___L)
  (declare-fun _K___L!val!1 () _K___L)
  ;; cardinality constraint:
  (forall ((x _K___L)) (or (= x _K___L!val!0) (= x _K___L!val!1)))
  ;; -----------
  ;; universe for _HomologicalComplex.quasiIso_C_c.Q_.obj_K___HomologicalComplex.quasiIso_C_c.Q_.obj_L:
  ;;   _HomologicalComplex.quasiIso_C_c.Q_.obj_K___HomologicalComplex.quasiIso_C_c.Q_.obj_L!val!0 _HomologicalComplex.quasiIso_C_c.Q_.obj_K___HomologicalComplex.quasiIso_C_c.Q_.obj_L!val!1 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _HomologicalComplex.quasiIso_C_c.Q_.obj_K___HomologicalComplex.quasiIso_C_c.Q_.obj_L!val!0 () _HomologicalComplex.quasiIso_C_c.Q_.obj_K___HomologicalComplex.quasiIso_C_c.Q_.obj_L)
  (declare-fun _HomologicalComplex.quasiIso_C_c.Q_.obj_K___HomologicalComplex.quasiIso_C_c.Q_.obj_L!val!1 () _HomologicalComplex.quasiIso_C_c.Q_.obj_K___HomologicalComplex.quasiIso_C_c.Q_.obj_L)
  ;; cardinality constraint:
  (forall ((x _HomologicalComplex.quasiIso_C_c.Q_.obj_K___HomologicalComplex.quasiIso_C_c.Q_.obj_L))
          (or (= x
                 _HomologicalComplex.quasiIso_C_c.Q_.obj_K___HomologicalComplex.quasiIso_C_c.Q_.obj_L!val!0)
              (= x
                 _HomologicalComplex.quasiIso_C_c.Q_.obj_K___HomologicalComplex.quasiIso_C_c.Q_.obj_L!val!1)))
  ;; -----------
  (define-fun _CategoryTheory.CategoryWithHomology_C () Bool
    true)
  (define-fun valid_fact_2 () Bool
    (not (= (_HomologicalComplex.quasiIso_C_c.Q_.map _f)
        (_HomologicalComplex.quasiIso_C_c.Q_.map _g))))
  (define-fun valid_fact_1 () Bool
    (_fun_c_=>_c.QFactorsThroughHomotopy_C _c))
  (define-fun _c () _ComplexShape_Œπ
    |_ComplexShape_Œπ!val!0|)
  (define-fun _f () _K___L
    _K___L!val!0)
  (define-fun valid_fact_0 () Bool
    _CategoryTheory.CategoryWithHomology_C)
  (define-fun _g () _K___L
    _K___L!val!1)
  (define-fun _fun_c_=>_c.QFactorsThroughHomotopy_C ((x!0 _ComplexShape_Œπ)) Bool
    true)
  (define-fun _HomologicalComplex.quasiIso_C_c.Q_.map ((x!0 _K___L)) _HomologicalComplex.quasiIso_C_c.Q_.obj_K___HomologicalComplex.quasiIso_C_c.Q_.obj_L
    (ite (= x!0 _K___L!val!1)
      _HomologicalComplex.quasiIso_C_c.Q_.obj_K___HomologicalComplex.quasiIso_C_c.Q_.obj_L!val!1
      _HomologicalComplex.quasiIso_C_c.Q_.obj_K___HomologicalComplex.quasiIso_C_c.Q_.obj_L!val!0))
)


Testing || Finset.nonempty_Ico : ‚àÄ {Œ± : Type u_2} {a b : Œ±} [inst : Preorder Œ±] [inst_1 : LocallyFiniteOrder Œ±], (Finset.Ico a b).Nonempty ‚Üî a < b
Result.success

Testing || Sum.LiftRel.exists_of_isLeft_right : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} {Œ≥ : Type u_1} {Œ¥ : Type u_2} {r : Œ± ‚Üí Œ≥ ‚Üí Prop} {s : Œ≤ ‚Üí Œ¥ ‚Üí Prop} {x : Œ± ‚äï Œ≤} {y : Œ≥ ‚äï Œ¥},
  Sum.LiftRel r s x y ‚Üí y.isLeft = true ‚Üí ‚àÉ a c, r a c ‚àß x = Sum.inl a ‚àß y = Sum.inl c
Result.success

Testing || FirstOrder.Language.Hom.id_comp : ‚àÄ {L : FirstOrder.Language} {M : Type w} {N : Type w'} [inst : L.Structure M] [inst_1 : L.Structure N] (f : L.Hom M N),
  (FirstOrder.Language.Hom.id L N).comp f = f
Result.autoException ::
_private.Auto.Translation.LamFOL2SMT.0.Auto.SMT.lamSort2SSortAux :: Unexpected error. Higher order input?

Testing || Pi.single_inj : ‚àÄ {I : Type u} (f : I ‚Üí Type v‚ÇÅ) [inst : DecidableEq I] [inst_1 : (i : I) ‚Üí Zero (f i)] (i : I) {x y : f i},
  Pi.single i x = Pi.single i y ‚Üî x = y
Result.autoException ::
Auto failed to find proof

Testing || WeierstrassCurve.preŒ®'_one : ‚àÄ {R : Type r} [inst : CommRing R] (W : WeierstrassCurve R), W.preŒ®' 1 = 1
Result.autoException ::
Auto failed to find proof

Testing || Matrix.updateColumn_conjTranspose : ‚àÄ {m : Type u_2} {n : Type u_3} {Œ± : Type v} {M : Matrix m n Œ±} {i : m} {b : n ‚Üí Œ±} [inst : DecidableEq m]
  [inst_1 : Star Œ±], M.conjTranspose.updateColumn i (star b) = (M.updateRow i b).conjTranspose
Result.success

Testing || conformalAt_iff : ‚àÄ {E : Type u_1} {F : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedAddCommGroup F]
  [inst_2 : InnerProductSpace ‚Ñù E] [inst_3 : InnerProductSpace ‚Ñù F] {f : E ‚Üí F} {x : E} {f' : E ‚ÜíL[‚Ñù] F},
  HasFDerivAt f f' x ‚Üí (ConformalAt f x ‚Üî ‚àÉ c, 0 < c ‚àß ‚àÄ (u v : E), inner (f' u) (f' v) = c * inner u v)
Result.success

Testing || List.prod_hom‚ÇÇ_nonempty : ‚àÄ {Œπ : Type u_1} {M : Type u_4} {N : Type u_5} {P : Type u_6} [inst : Monoid M] [inst_1 : Monoid N] [inst_2 : Monoid P]
  {l : List Œπ} (f : M ‚Üí N ‚Üí P),
  (‚àÄ (a b : M) (c d : N), f (a * b) (c * d) = f a c * f b d) ‚Üí
    ‚àÄ (f‚ÇÅ : Œπ ‚Üí M) (f‚ÇÇ : Œπ ‚Üí N),
      l ‚â† [] ‚Üí (List.map (fun i => f (f‚ÇÅ i) (f‚ÇÇ i)) l).prod = f (List.map f‚ÇÅ l).prod (List.map f‚ÇÇ l).prod
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _P:
  ;;   _P!val!2 _P!val!0 _P!val!1 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _P!val!2 () _P)
  (declare-fun _P!val!0 () _P)
  (declare-fun _P!val!1 () _P)
  ;; cardinality constraint:
  (forall ((x _P)) (or (= x _P!val!2) (= x _P!val!0) (= x _P!val!1)))
  ;; -----------
  ;; universe for _M:
  ;;   _M!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _M!val!0 () _M)
  ;; cardinality constraint:
  (forall ((x _M)) (= x _M!val!0))
  ;; -----------
  ;; universe for _N:
  ;;   _N!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _N!val!0 () _N)
  ;; cardinality constraint:
  (forall ((x _N)) (= x _N!val!0))
  ;; -----------
  ;; universe for _Œπ:
  ;;   |_Œπ!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œπ!val!0| () _Œπ)
  ;; cardinality constraint:
  (forall ((x _Œπ)) (= x |_Œπ!val!0|))
  ;; -----------
  (define-fun _1__1 () _P
    _P!val!2)
  (define-fun valid_fact_1 () Bool
    (not (= _l _pl___)))
  (define-fun valid_fact_3 () Bool
    (forall ((_m_1 _M)) (= (_HMul.hMul _m_1 _1_) _m_1)))
  (define-fun valid_fact_4 () Bool
    (forall ((_n_1 _N)) (= (_HMul.hMul_0 _n_1 _1__0) _n_1)))
  (define-fun valid_fact_2 () Bool
    (let ((a!1 (= (_List.prod (|_List.map_fun_i_=>_f_f‚ÇÅ_i_f‚ÇÇ_i| _l))
              (_f (_List.prod_0 (|_List.map_f‚ÇÅ| _l))
                  (_List.prod_1 (|_List.map_f‚ÇÇ| _l))))))
  (not a!1)))
  (define-fun valid_fact_5 () Bool
    (forall ((_p _P)) (= (_HMul.hMul_1 _p _1__1) _p)))
  (define-fun _l () _List_Œπ
    (_List.cons |_Œπ!val!0| _pl___))
  (define-fun valid_fact_0 () Bool
    (forall ((_m _M) (_m_0 _M) (_n _N) (_n_0 _N))
  (= (_f (_HMul.hMul _m _m_0) (_HMul.hMul_0 _n _n_0))
     (_HMul.hMul_1 (_f _m _n) (_f _m_0 _n_0)))))
  (define-fun _1__0 () _N
    _N!val!0)
  (define-fun _1_ () _M
    _M!val!0)
  (define-fun |_List.map_fun_i_=>_f_f‚ÇÅ_i_f‚ÇÇ_i| ((x!0 _List_Œπ)) _List_P
    _pl____0)
  (define-fun |_List.map_f‚ÇÇ| ((x!0 _List_Œπ)) _List_N
    _pl____2)
  (define-fun _List.prod_1 ((x!0 _List_N)) _N
    _N!val!0)
  (define-fun _HMul.hMul ((x!0 _M) (x!1 _M)) _M
    x!0)
  (define-fun _List.prod_0 ((x!0 _List_M)) _M
    _M!val!0)
  (define-fun _HMul.hMul_1 ((x!0 _P) (x!1 _P)) _P
    x!0)
  (define-fun _f ((x!0 _M) (x!1 _N)) _P
    _P!val!1)
  (define-fun _List.prod ((x!0 _List_P)) _P
    _P!val!0)
  (define-fun _HMul.hMul_0 ((x!0 _N) (x!1 _N)) _N
    x!0)
  (define-fun |_List.map_f‚ÇÅ| ((x!0 _List_Œπ)) _List_M
    _pl____1)
)


Testing || Filter.mem_of_superset : ‚àÄ {Œ± : Type u_1} {f : Filter Œ±} {x y : Set Œ±}, x ‚àà f ‚Üí x ‚äÜ y ‚Üí y ‚àà f
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Filter_Œ±:
  ;;   |_Filter_Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Filter_Œ±!val!0| () _Filter_Œ±)
  ;; cardinality constraint:
  (forall ((x _Filter_Œ±)) (= x |_Filter_Œ±!val!0|))
  ;; -----------
  ;; universe for _Set_Œ±:
  ;;   |_Set_Œ±!val!1| |_Set_Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_Œ±!val!1| () _Set_Œ±)
  (declare-fun |_Set_Œ±!val!0| () _Set_Œ±)
  ;; cardinality constraint:
  (forall ((x _Set_Œ±)) (or (= x |_Set_Œ±!val!1|) (= x |_Set_Œ±!val!0|)))
  ;; -----------
  ;; universe for _Set_Set_Œ±:
  ;;   |_Set_Set_Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_Set_Œ±!val!0| () _Set_Set_Œ±)
  ;; cardinality constraint:
  (forall ((x _Set_Set_Œ±)) (= x |_Set_Set_Œ±!val!0|))
  ;; -----------
  (define-fun _f () _Filter_Œ±
    |_Filter_Œ±!val!0|)
  (define-fun valid_fact_2 () Bool
    (not (_Membership.mem _f _y)))
  (define-fun valid_fact_1 () Bool
    (_Subset _x _y))
  (define-fun valid_fact_3 () Bool
    (forall ((_f_0 _Filter_Œ±) (_s _Set_Œ±) (_s_0 _Set_Œ±))
  (or (_Membership.mem_0 (_Filter.sets _f_0) _s_0)
      (not (_Subset _s _s_0))
      (not (_Membership.mem_0 (_Filter.sets _f_0) _s)))))
  (define-fun _x () _Set_Œ±
    |_Set_Œ±!val!0|)
  (define-fun _y () _Set_Œ±
    |_Set_Œ±!val!1|)
  (define-fun valid_fact_0 () Bool
    (_Membership.mem _f _x))
  (define-fun _Membership.mem_0 ((x!0 _Set_Set_Œ±) (x!1 _Set_Œ±)) Bool
    false)
  (define-fun _Subset ((x!0 _Set_Œ±) (x!1 _Set_Œ±)) Bool
    (and (= x!0 |_Set_Œ±!val!0|) (not (= x!1 |_Set_Œ±!val!0|))))
  (define-fun _Membership.mem ((x!0 _Filter_Œ±) (x!1 _Set_Œ±)) Bool
    (ite (and (= x!0 |_Filter_Œ±!val!0|) (= x!1 |_Set_Œ±!val!1|)) false
      true))
  (define-fun _Filter.sets ((x!0 _Filter_Œ±)) _Set_Set_Œ±
    |_Set_Set_Œ±!val!0|)
)


Testing || ContinuousLinearEquiv.contDiffWithinAt_comp_iff : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {G : Type uG}
  [inst_5 : NormedAddCommGroup G] [inst_6 : NormedSpace ùïú G] {s : Set E} {f : E ‚Üí F} {x : E} {n : ‚Ñï‚àû} (e : G ‚âÉL[ùïú] E),
  ContDiffWithinAt ùïú n (f ‚àò ‚áëe) (‚áëe ‚Åª¬π' s) (e.symm x) ‚Üî ContDiffWithinAt ùïú n f s x
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_23 ‚àò cifvar_24 x_3`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || eq_sub_of_add_eq' : ‚àÄ {G : Type u_3} [inst : AddCommGroup G] {a b c : G}, c + a = b ‚Üí a = b - c
Result.success

Testing || Primrec.pred : Primrec Nat.pred
Result.success

Testing || MeasurableSet.cylinder : ‚àÄ {Œπ : Type u_2} {Œ± : Œπ ‚Üí Type u_1} [inst : (i : Œπ) ‚Üí MeasurableSpace (Œ± i)] (s : Finset Œπ)
  {S : Set ((i : { x // x ‚àà s }) ‚Üí Œ± ‚Üëi)}, MeasurableSet S ‚Üí MeasurableSet (MeasureTheory.cylinder s S)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Set__i_____x_//_x___s______Œ±__i:
  ;;   |_Set__i_____x_//_x___s______Œ±__i!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set__i_____x_//_x___s______Œ±__i!val!0| () _Set__i_____x_//_x___s______Œ±__i)
  ;; cardinality constraint:
  (forall ((x _Set__i_____x_//_x___s______Œ±__i))
          (= x |_Set__i_____x_//_x___s______Œ±__i!val!0|))
  ;; -----------
  ;; universe for _Set__i___Œπ____Œ±_i:
  ;;   |_Set__i___Œπ____Œ±_i!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set__i___Œπ____Œ±_i!val!0| () _Set__i___Œπ____Œ±_i)
  ;; cardinality constraint:
  (forall ((x _Set__i___Œπ____Œ±_i)) (= x |_Set__i___Œπ____Œ±_i!val!0|))
  ;; -----------
  (define-fun _S () _Set__i_____x_//_x___s______Œ±__i
    |_Set__i_____x_//_x___s______Œ±__i!val!0|)
  (define-fun valid_fact_0 () Bool
    (_MeasurableSet _S))
  (define-fun valid_fact_1 () Bool
    (not (_MeasurableSet_0 (_MeasureTheory.cylinder_s _S))))
  (define-fun _MeasurableSet ((x!0 _Set__i_____x_//_x___s______Œ±__i)) Bool
    true)
  (define-fun _MeasureTheory.cylinder_s ((x!0 _Set__i_____x_//_x___s______Œ±__i)) _Set__i___Œπ____Œ±_i
    |_Set__i___Œπ____Œ±_i!val!0|)
  (define-fun _MeasurableSet_0 ((x!0 _Set__i___Œπ____Œ±_i)) Bool
    false)
)


Testing || ZMod.intCast_eq_intCast_iff : ‚àÄ (a b : ‚Ñ§) (c : ‚Ñï), ‚Üëa = ‚Üëb ‚Üî a ‚â° b [ZMOD ‚Üëc]
Result.autoException ::
Auto failed to find proof

Testing || List.getI_eq_default : ‚àÄ {Œ± : Type u} (l : List Œ±) [inst : Inhabited Œ±] {n : ‚Ñï}, l.length ‚â§ n ‚Üí l.getI n = default
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Œ±:
  ;;   |_Œ±!val!0| |_Œ±!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ±!val!0| () _Œ±)
  (declare-fun |_Œ±!val!1| () _Œ±)
  ;; cardinality constraint:
  (forall ((x _Œ±)) (or (= x |_Œ±!val!0|) (= x |_Œ±!val!1|)))
  ;; -----------
  (define-fun _l () _List_Œ±
    _pl___)
  (define-fun valid_fact_2 () Bool
    (forall ((_l_1 _List_Œ±) (|_Œ±_0| _Œ±) (_n_0 Int))
  (or (= (_List.getD _l_1 _n_0 |_Œ±_0|) |_Œ±_0|)
      (not (>= _n_0 0))
      (not (<= (_List.length _l_1) _n_0)))))
  (define-fun valid_fact_0 () Bool
    (<= (_List.length _l) _n))
  (define-fun valid_fact_1 () Bool
    (not (= (_List.getI _l _n) _default)))
  (define-fun _n () Int
    0)
  (define-fun _default () _Œ±
    |_Œ±!val!1|)
  (define-fun _List.getD ((x!0 _List_Œ±) (x!1 Int) (x!2 _Œ±)) _Œ±
    x!2)
  (define-fun _List.length ((x!0 _List_Œ±)) Int
    0)
  (define-fun _List.getI ((x!0 _List_Œ±) (x!1 Int)) _Œ±
    |_Œ±!val!0|)
)


Testing || NonUnitalSubsemiring.comap_top : ‚àÄ {R : Type u} {S : Type v} [inst : NonUnitalNonAssocSemiring R] [inst_1 : NonUnitalNonAssocSemiring S] {F : Type u_1}
  [inst_2 : FunLike F R S] [inst_3 : NonUnitalRingHomClass F R S] (f : F), NonUnitalSubsemiring.comap f ‚ä§ = ‚ä§
Result.autoException ::
Auto failed to find proof

Testing || Monotone.rightLim_le : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : LinearOrder Œ±] [inst_1 : ConditionallyCompleteLinearOrder Œ≤]
  [inst_2 : TopologicalSpace Œ≤] [inst_3 : OrderTopology Œ≤] {f : Œ± ‚Üí Œ≤},
  Monotone f ‚Üí ‚àÄ {x y : Œ±}, x < y ‚Üí Function.rightLim f x ‚â§ f y
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Œ±:
  ;;   |_Œ±!val!0| |_Œ±!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ±!val!0| () _Œ±)
  (declare-fun |_Œ±!val!1| () _Œ±)
  ;; cardinality constraint:
  (forall ((x _Œ±)) (or (= x |_Œ±!val!0|) (= x |_Œ±!val!1|)))
  ;; -----------
  ;; universe for _Œ≤:
  ;;   |_Œ≤!val!3| |_Œ≤!val!4| |_Œ≤!val!6| |_Œ≤!val!2| |_Œ≤!val!1| |_Œ≤!val!5| |_Œ≤!val!7| |_Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ≤!val!3| () _Œ≤)
  (declare-fun |_Œ≤!val!4| () _Œ≤)
  (declare-fun |_Œ≤!val!6| () _Œ≤)
  (declare-fun |_Œ≤!val!2| () _Œ≤)
  (declare-fun |_Œ≤!val!1| () _Œ≤)
  (declare-fun |_Œ≤!val!5| () _Œ≤)
  (declare-fun |_Œ≤!val!7| () _Œ≤)
  (declare-fun |_Œ≤!val!0| () _Œ≤)
  ;; cardinality constraint:
  (forall ((x _Œ≤))
          (or (= x |_Œ≤!val!3|)
              (= x |_Œ≤!val!4|)
              (= x |_Œ≤!val!6|)
              (= x |_Œ≤!val!2|)
              (= x |_Œ≤!val!1|)
              (= x |_Œ≤!val!5|)
              (= x |_Œ≤!val!7|)
              (= x |_Œ≤!val!0|)))
  ;; -----------
  (define-fun _Monotone_f () Bool
    true)
  (define-fun valid_fact_10 () Bool
    (or _Monotone_f (not _Monotone__OrderDual.toDual___f____OrderDual.ofDual)))
  (define-fun |_OrderTopology_Œ≤| () Bool
    true)
  (define-fun valid_fact_3 () Bool
    (not (_LE.le (_Function.rightLim_f _x) (_f _y))))
  (define-fun valid_fact_8 () Bool
    (or (not _Monotone_f) _Monotone__OrderDual.toDual___f____OrderDual.ofDual))
  (define-fun valid_fact_0 () Bool
    |_OrderTopology_Œ≤|)
  (define-fun valid_fact_9 () Bool
    (or (not _Monotone_f) _Monotone__OrderDual.toDual___f____OrderDual.ofDual))
  (define-fun valid_fact_7 () Bool
    (let ((a!1 (forall ((|_Œ±_6| _Œ±) (|_Œ±_7| _Œ±))
             (or (not (_LT.lt_0 |_Œ±_6| |_Œ±_7|))
                 (_LE.le_0 (__OrderDual.toDual___f____OrderDual.ofDual |_Œ±_6|)
                           (_Function.leftLim__OrderDual.toDual___f____OrderDual.ofDual
                             |_Œ±_7|))))))
  (or (not _Monotone__OrderDual.toDual___f____OrderDual.ofDual) a!1)))
  (define-fun valid_fact_5 () Bool
    (let ((a!1 (forall ((|_Œ±_2| _Œ±) (|_Œ±_3| _Œ±))
             (or (not (_LT.lt |_Œ±_2| |_Œ±_3|))
                 (_LE.le (_f |_Œ±_2|) (_Function.leftLim_f |_Œ±_3|))))))
  (or (not _Monotone_f) a!1)))
  (define-fun _Monotone__OrderDual.toDual___f____OrderDual.ofDual () Bool
    true)
  (define-fun _x () _Œ±
    |_Œ±!val!0|)
  (define-fun _y () _Œ±
    |_Œ±!val!1|)
  (define-fun valid_fact_4 () Bool
    (let ((a!1 (forall ((|_Œ±_0| _Œ±) (|_Œ±_1| _Œ±))
             (or (not (_LT.lt |_Œ±_0| |_Œ±_1|))
                 (_LE.le (_f |_Œ±_0|) (_Function.leftLim_f |_Œ±_1|))))))
  (or (not _Monotone_f) a!1)))
  (define-fun valid_fact_6 () Bool
    (let ((a!1 (forall ((|_Œ±_4| _Œ±) (|_Œ±_5| _Œ±))
             (or (not (_LT.lt |_Œ±_4| |_Œ±_5|))
                 (_LE.le (_f |_Œ±_4|) (_Function.leftLim_f |_Œ±_5|))))))
  (or (not _Monotone_f) a!1)))
  (define-fun valid_fact_2 () Bool
    (_LT.lt _x _y))
  (define-fun valid_fact_1 () Bool
    _Monotone_f)
  (define-fun _Function.rightLim_f ((x!0 _Œ±)) _Œ≤
    |_Œ≤!val!0|)
  (define-fun _Function.leftLim__OrderDual.toDual___f____OrderDual.ofDual ((x!0
    _Œ±)) _Œ≤
    |_Œ≤!val!6|)
  (define-fun __OrderDual.toDual___f____OrderDual.ofDual ((x!0 _Œ±)) _Œ≤
    |_Œ≤!val!5|)
  (define-fun _LT.lt ((x!0 _Œ±) (x!1 _Œ±)) Bool
    (= x!0 |_Œ±!val!0|))
  (define-fun _f ((x!0 _Œ±)) _Œ≤
    (ite (= x!0 |_Œ±!val!0|) |_Œ≤!val!2|
      |_Œ≤!val!1|))
  (define-fun _LE.le_0 ((x!0 _Œ≤) (x!1 _Œ≤)) Bool
    false)
  (define-fun _Function.leftLim_f ((x!0 _Œ±)) _Œ≤
    |_Œ≤!val!3|)
  (define-fun _LT.lt_0 ((x!0 _Œ±) (x!1 _Œ±)) Bool
    false)
  (define-fun _LE.le ((x!0 _Œ≤) (x!1 _Œ≤)) Bool
    (and (= x!0 |_Œ≤!val!2|) (= x!1 |_Œ≤!val!3|)))
)


Testing || AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom_toStalk : ‚àÄ (R : Type u) [inst : CommRing R] (x : ‚Üë(AlgebraicGeometry.PrimeSpectrum.Top R)) (f : R),
  (AlgebraicGeometry.StructureSheaf.stalkToFiberRingHom R x) ((AlgebraicGeometry.StructureSheaf.toStalk R x) f) =
    (algebraMap R (Localization.AtPrime x.asIdeal)) f
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.isPrime`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || ringExpChar.eq_iff : ‚àÄ {R : Type u_1} [inst : Ring R] [inst_1 : IsDomain R] {q : ‚Ñï}, ringExpChar R = q ‚Üî ExpChar R q
Result.success

Testing || TopologicalSpace.NoetherianSpace.finite : ‚àÄ {Œ± : Type u_1} [inst : TopologicalSpace Œ±] [inst_1 : TopologicalSpace.NoetherianSpace Œ±] [inst : T2Space Œ±], Finite Œ±
Result.success

Testing || Subalgebra.mem_op : ‚àÄ {R : Type u_2} {A : Type u_3} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] {x : A·µê·µí·µñ}
  {S : Subalgebra R A}, x ‚àà S.op ‚Üî MulOpposite.unop x ‚àà S
Result.autoException ::
Auto failed to find proof

Testing || MvQPF.Cofix.bisim‚ÇÇ : ‚àÄ {n : ‚Ñï} {F : TypeVec.{u} (n + 1) ‚Üí Type u} [q : MvQPF F] {Œ± : TypeVec.{u} n}
  (r : MvQPF.Cofix F Œ± ‚Üí MvQPF.Cofix F Œ± ‚Üí Prop),
  (‚àÄ (x y : MvQPF.Cofix F Œ±), r x y ‚Üí MvFunctor.LiftR' (Œ±.RelLast' r) x.dest y.dest) ‚Üí
    ‚àÄ (x y : MvQPF.Cofix F Œ±), r x y ‚Üí x = y
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: TypeVec.{u} (n + 1) is not a `‚àÄ`

Testing || CategoryTheory.BicategoricalCoherence.whiskerLeft_iso : ‚àÄ {B : Type u} [inst : CategoryTheory.Bicategory B] {a b c : B} (f : a ‚ü∂ b) (g h : b ‚ü∂ c)
  [inst_1 : CategoryTheory.BicategoricalCoherence g h],
  CategoryTheory.BicategoricalCoherence.iso =
    CategoryTheory.Bicategory.whiskerLeftIso f CategoryTheory.BicategoricalCoherence.iso
Result.autoException ::
Auto failed to find proof

Testing || Nat.sq_add_sq_mul : ‚àÄ {a b x y u v : ‚Ñï}, a = x ^ 2 + y ^ 2 ‚Üí b = u ^ 2 + v ^ 2 ‚Üí ‚àÉ r s, a * b = r ^ 2 + s ^ 2
Result.autoException ::
Auto failed to find proof

Testing || Set.iUnion_smul_left_image : ‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : SMul Œ± Œ≤] {s : Set Œ±} {t : Set Œ≤}, ‚ãÉ a ‚àà s, a ‚Ä¢ t = s ‚Ä¢ t
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a ‚àà x_0 of Œª binder contains bound variables

Testing || IsGroupHom.comp : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : Group Œ±] [inst_1 : Group Œ≤] {f : Œ± ‚Üí Œ≤},
  IsGroupHom f ‚Üí ‚àÄ {Œ≥ : Type u_1} [inst_2 : Group Œ≥] {g : Œ≤ ‚Üí Œ≥}, IsGroupHom g ‚Üí IsGroupHom (g ‚àò f)
Result.autoException ::
Auto failed to find proof

Testing || LieSubmodule.sup_lie : ‚àÄ {R : Type u} {L : Type v} {M : Type w} [inst : CommRing R] [inst_1 : LieRing L] [inst_2 : AddCommGroup M]
  [inst_3 : Module R M] [inst_4 : LieRingModule L M] (N : LieSubmodule R L M) [inst_5 : LieAlgebra R L]
  (I J : LieIdeal R L), ‚ÅÖI ‚äî J, N‚ÅÜ = ‚ÅÖI, N‚ÅÜ ‚äî ‚ÅÖJ, N‚ÅÜ
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{ x // cifvar_17 x_1 x }`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || mem_ball_zero_iff : ‚àÄ {E : Type u_6} [inst : SeminormedAddGroup E] {a : E} {r : ‚Ñù}, a ‚àà Metric.ball 0 r ‚Üî ‚Äña‚Äñ < r
Result.success

Testing || ContinuousConstSMul.continuous_const_smul : ‚àÄ {Œì : Type u_1} {T : Type u_2} {inst : TopologicalSpace T} {inst_1 : SMul Œì T} [self : ContinuousConstSMul Œì T]
  (Œ≥ : Œì), Continuous fun x => Œ≥ ‚Ä¢ x
Result.autoException ::
Auto failed to find proof

Testing || Cardinal.lift_mk_shrink' : ‚àÄ (Œ± : Type u) [inst : Small.{v, u} Œ±],
  Cardinal.lift.{u, v} (Cardinal.mk (Shrink.{v, u} Œ±)) = Cardinal.lift.{v, u} (Cardinal.mk Œ±)
Result.autoException ::
Auto failed to find proof

Testing || SetTheory.PGame.Domineering.snd_pred_mem_erase_of_mem_left : ‚àÄ {b : SetTheory.PGame.Domineering.Board} {m : ‚Ñ§ √ó ‚Ñ§},
  m ‚àà SetTheory.PGame.Domineering.left b ‚Üí (m.1, m.2 - 1) ‚àà Finset.erase b m
Result.success

Testing || Ordnode.Valid'.node4L : ‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {l : Ordnode Œ±} {x : Œ±} {m : Ordnode Œ±} {y : Œ±} {r : Ordnode Œ±} {o‚ÇÅ : WithBot Œ±}
  {o‚ÇÇ : WithTop Œ±},
  Ordnode.Valid' o‚ÇÅ l ‚Üëx ‚Üí
    Ordnode.Valid' (‚Üëx) m ‚Üëy ‚Üí
      Ordnode.Valid' (‚Üëy) r o‚ÇÇ ‚Üí
        0 < m.size ‚Üí
          l.size = 0 ‚àß m.size = 1 ‚àß r.size ‚â§ 1 ‚à®
              0 < l.size ‚àß
                Ordnode.ratio * r.size ‚â§ m.size ‚àß
                  Ordnode.delta * l.size ‚â§ m.size + r.size ‚àß
                    3 * (m.size + r.size) ‚â§ 16 * l.size + 9 ‚àß m.size ‚â§ Ordnode.delta * r.size ‚Üí
            Ordnode.Valid' o‚ÇÅ (l.node4L x m y r) o‚ÇÇ
Result.autoException ::
Auto failed to find proof

Testing || MeasureTheory.setToFun_sub : ‚àÄ {Œ± : Type u_1} {E : Type u_2} {F : Type u_3} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E]
  [inst_2 : NormedAddCommGroup F] [inst_3 : NormedSpace ‚Ñù F] {m : MeasurableSpace Œ±} {Œº : MeasureTheory.Measure Œ±}
  [inst_4 : CompleteSpace F] {T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F} {C : ‚Ñù} {f g : Œ± ‚Üí E}
  (hT : MeasureTheory.DominatedFinMeasAdditive Œº T C),
  MeasureTheory.Integrable f Œº ‚Üí
    MeasureTheory.Integrable g Œº ‚Üí
      MeasureTheory.setToFun Œº T hT (f - g) = MeasureTheory.setToFun Œº T hT f - MeasureTheory.setToFun Œº T hT g
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || CategoryTheory.Pretriangulated.mem_distTriang_op_iff : ‚àÄ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.HasShift C ‚Ñ§]
  [inst_2 : CategoryTheory.Limits.HasZeroObject C] [inst_3 : CategoryTheory.Preadditive C]
  [inst_4 : ‚àÄ (n : ‚Ñ§), (CategoryTheory.shiftFunctor C n).Additive] [inst_5 : CategoryTheory.Pretriangulated C]
  (T : CategoryTheory.Pretriangulated.Triangle C·µí·µñ),
  T ‚àà CategoryTheory.Pretriangulated.distinguishedTriangles ‚Üî
    Opposite.unop ((CategoryTheory.Pretriangulated.triangleOpEquivalence C).inverse.obj T) ‚àà
      CategoryTheory.Pretriangulated.distinguishedTriangles
Result.autoException ::
Auto failed to find proof

Testing || LinearMap.lTensor_neg : ‚àÄ {R : Type u_1} [inst : CommSemiring R] {M : Type u_2} {N : Type u_3} {P : Type u_4} [inst_1 : AddCommGroup M]
  [inst_2 : AddCommGroup N] [inst_3 : AddCommGroup P] [inst_4 : Module R M] [inst_5 : Module R N] [inst_6 : Module R P]
  (f : N ‚Üí‚Çó[R] P), LinearMap.lTensor M (-f) = -LinearMap.lTensor M f
Result.autoException ::
Auto failed to find proof

Testing || AddLocalization.rec.proof_3 : ‚àÄ {M : Type u_1} [inst : AddCommMonoid M] {S : AddSubmonoid M} {p : AddLocalization S ‚Üí Sort u_2}
  (f : (a : M) ‚Üí (b : ‚Ü•S) ‚Üí p (AddLocalization.mk a b)),
  (‚àÄ {a c : M} {b d : ‚Ü•S} (h : (AddLocalization.r S) (a, b) (c, d)), ‚ãØ ‚ñ∏ f a b = f c d) ‚Üí
    ‚àÄ (y z : M √ó ‚Ü•S) (h : (AddOreLocalization.oreEqv S M) y z), ‚ãØ ‚ñ∏ ‚ãØ ‚ñ∏ f y.1 y.2 = ‚ãØ ‚ñ∏ f z.1 z.2
Result.autoException ::
Auto failed to find proof

Testing || Unitization.lift_symm_apply : ‚àÄ {R : Type u_2} {A : Type u_3} [inst : CommSemiring R] [inst_1 : NonUnitalSemiring A] [inst_2 : Module R A]
  [inst_3 : SMulCommClass R A A] [inst_4 : IsScalarTower R A A] {C : Type u_5} [inst_5 : Semiring C]
  [inst_6 : Algebra R C] (œÜ : Unitization R A ‚Üí‚Çê[R] C),
  Unitization.lift.symm œÜ = (NonUnitalAlgHomClass.toNonUnitalAlgHom œÜ).comp (Unitization.inrNonUnitalAlgHom R A)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Limits.Types.binaryCoproductColimit_desc : ‚àÄ (X Y : Type u) (s : CategoryTheory.Limits.BinaryCofan X Y) (a : X ‚äï Y),
  (CategoryTheory.Limits.Types.binaryCoproductColimit X Y).desc s a = Sum.elim s.inl s.inr a
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: (CategoryTheory.Limits.Types.binaryCoproductCocone X Y).pt ‚ü∂
  s.pt is not a `‚àÄ`

Testing || LinearIsometry.map_ne : ‚àÄ {R : Type u_1} {R‚ÇÇ : Type u_2} {E‚ÇÇ : Type u_6} {F : Type u_9} [inst : Semiring R] [inst_1 : Semiring R‚ÇÇ]
  {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} [inst_2 : SeminormedAddCommGroup E‚ÇÇ] [inst_3 : Module R‚ÇÇ E‚ÇÇ] [inst_4 : NormedAddCommGroup F]
  [inst_5 : Module R F] (f‚ÇÅ : F ‚Üí‚Çõ‚Çó·µ¢[œÉ‚ÇÅ‚ÇÇ] E‚ÇÇ) {x y : F}, x ‚â† y ‚Üí f‚ÇÅ x ‚â† f‚ÇÅ y
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Function.Injective (cifvar_5 x_0)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || Relation.comp_assoc : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} {Œ¥ : Type u_4} {r : Œ± ‚Üí Œ≤ ‚Üí Prop} {p : Œ≤ ‚Üí Œ≥ ‚Üí Prop} {q : Œ≥ ‚Üí Œ¥ ‚Üí Prop},
  Relation.Comp (Relation.Comp r p) q = Relation.Comp r (Relation.Comp p q)
Result.autoException ::
Auto failed to find proof

Testing || Int.succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul : ‚àÄ {p : ‚Ñï},
  Nat.Prime p ‚Üí
    ‚àÄ {m n : ‚Ñ§} {k l : ‚Ñï},
      ‚Üë(p ^ k) ‚à£ m ‚Üí ‚Üë(p ^ l) ‚à£ n ‚Üí ‚Üë(p ^ (k + l + 1)) ‚à£ m * n ‚Üí ‚Üë(p ^ (k + 1)) ‚à£ m ‚à® ‚Üë(p ^ (l + 1)) ‚à£ n
Result.autoException ::
Auto failed to find proof

Testing || Subring.coe_center : ‚àÄ (R : Type u) [inst : Ring R], ‚Üë(Subring.center R) = Set.center R
Result.autoException ::
Auto failed to find proof

Testing || AntivaryOn.sum_mul_le_sum_mul_comp_perm : ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : LinearOrderedSemiring Œ±] [inst_1 : ExistsAddOfLE Œ±] {s : Finset Œπ}
  {œÉ : Equiv.Perm Œπ} {f g : Œπ ‚Üí Œ±}, AntivaryOn f g ‚Üës ‚Üí {x | œÉ x ‚â† x} ‚äÜ ‚Üës ‚Üí ‚àë i ‚àà s, f i * g i ‚â§ ‚àë i ‚àà s, f i * g (œÉ i)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `‚àë i ‚àà x_0,
  cifvar_12 (cifvar_13 i) (cifvar_14 (cifvar_15 x_1 i))`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || RightOrdContinuous.lt_iff : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : SemilatticeInf Œ±] [inst_1 : SemilatticeInf Œ≤] {f : Œ± ‚Üí Œ≤},
  RightOrdContinuous f ‚Üí Function.Injective f ‚Üí ‚àÄ {x y : Œ±}, f x < f y ‚Üî x < y
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `SemilatticeSup.toPartialOrder`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || Batteries.Vector.push_pop_back : ‚àÄ {Œ± : Type u_1} {n : ‚Ñï} (v : Batteries.Vector Œ± (n + 1)), Batteries.Vector.push v.back v.pop = v
Result.autoException ::
Auto.Lemma.rewriteUMonoRigid? :: Motive fun _a =>
  ‚àÄ {Œ± : Type u_1} {n : ‚Ñï} {v : Batteries.Vector Œ± n} {x : Œ±} {i : ‚Ñï} (h : i < n),
    (Batteries.Vector.push x v)[i] = v[i] is not type correct

Testing || CategoryTheory.Adjunction.toEquivalence_inverse : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] {D : Type u‚ÇÇ} [inst_1 : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D]
  {F : CategoryTheory.Functor C D} {G : CategoryTheory.Functor D C} (adj : F ‚ä£ G)
  [inst_2 : ‚àÄ (X : C), CategoryTheory.IsIso (adj.unit.app X)]
  [inst_3 : ‚àÄ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)], adj.toEquivalence.inverse = G
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_7 cifvar_8).app x_0`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || FractionalIdeal.fg_of_isUnit : ‚àÄ {R : Type u_1} [inst : CommRing R] {S : Submonoid R} {P : Type u_2} [inst_1 : CommRing P] [inst_2 : Algebra R P]
  (I : FractionalIdeal S P), IsUnit I ‚Üí (‚ÜëI).FG
Result.autoException ::
Auto failed to find proof

Testing || minpoly.natSepDegree_eq_one_iff_eq_X_sub_C_pow : ‚àÄ {F : Type u} {E : Type v} [inst : Field F] [inst_1 : Ring E] [inst_2 : IsDomain E] [inst_3 : Algebra F E] (q : ‚Ñï)
  [hF : ExpChar F q] {x : E},
  (minpoly F x).natSepDegree = 1 ‚Üî
    ‚àÉ n, Polynomial.map (algebraMap F E) (minpoly F x) = (Polynomial.X - Polynomial.C x) ^ q ^ n
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `HasDistribNeg.toInvolutiveNeg`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || IsAddRightRegular.add : ‚àÄ {R : Type u_1} [inst : AddSemigroup R] {a b : R},
  IsAddRightRegular a ‚Üí IsAddRightRegular b ‚Üí IsAddRightRegular (a + b)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(fun x => cifvar_4 x x_0) ‚àò
  fun x => cifvar_4 x x_1`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || StarConvex.preimage_add_left : ‚àÄ {ùïú : Type u_1} {E : Type u_2} [inst : OrderedSemiring ùïú] [inst_1 : AddCommMonoid E] [inst_2 : Module ùïú E] {x z : E}
  {s : Set E}, StarConvex ùïú (x + z) s ‚Üí StarConvex ùïú x ((fun x => x + z) ‚Åª¬π' s)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(fun x => cifvar_1 x_1 x) ‚Åª¬π' x_2`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || fixedPoints_submonoid_sup : ‚àÄ (M : Type u_1) (Œ± : Type u_2) [inst : Monoid M] [inst_1 : MulAction M Œ±] {P Q : Submonoid M},
  MulAction.fixedPoints (‚Ü•(P ‚äî Q)) Œ± = MulAction.fixedPoints (‚Ü•P) Œ± ‚à© MulAction.fixedPoints (‚Ü•Q) Œ±
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Set_Œ±:
  ;;   |_Set_Œ±!val!1| |_Set_Œ±!val!2| |_Set_Œ±!val!3| |_Set_Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_Œ±!val!1| () _Set_Œ±)
  (declare-fun |_Set_Œ±!val!2| () _Set_Œ±)
  (declare-fun |_Set_Œ±!val!3| () _Set_Œ±)
  (declare-fun |_Set_Œ±!val!0| () _Set_Œ±)
  ;; cardinality constraint:
  (forall ((x _Set_Œ±))
          (or (= x |_Set_Œ±!val!1|)
              (= x |_Set_Œ±!val!2|)
              (= x |_Set_Œ±!val!3|)
              (= x |_Set_Œ±!val!0|)))
  ;; -----------
  (define-fun |_MulAction.fixedPoints__P___Q_Œ±| () _Set_Œ±
    |_Set_Œ±!val!0|)
  (define-fun |_MulAction.fixedPoints__P_Œ±| () _Set_Œ±
    |_Set_Œ±!val!1|)
  (define-fun valid_fact_0 () Bool
    (not (= |_MulAction.fixedPoints__P___Q_Œ±|
        (_Inter.inter |_MulAction.fixedPoints__P_Œ±|
                      |_MulAction.fixedPoints__Q_Œ±|))))
  (define-fun |_MulAction.fixedPoints__Q_Œ±| () _Set_Œ±
    |_Set_Œ±!val!2|)
  (define-fun _Inter.inter ((x!0 _Set_Œ±) (x!1 _Set_Œ±)) _Set_Œ±
    |_Set_Œ±!val!3|)
)


Testing || add_neg_cancel_comm : ‚àÄ {G : Type u_1} [inst : AddCommGroup G] (a b : G), a + b + -a = b
Result.success

Testing || StructureGroupoid.LocalInvariantProp.liftPropAt_symm_of_mem_maximalAtlas : ‚àÄ {H : Type u_1} {M : Type u_2} [inst : TopologicalSpace H] [inst_1 : TopologicalSpace M] [inst_2 : ChartedSpace H M]
  {G : StructureGroupoid H} {e : PartialHomeomorph M H} {Q : (H ‚Üí H) ‚Üí Set H ‚Üí H ‚Üí Prop} [inst_3 : HasGroupoid M G]
  {x : H},
  G.LocalInvariantProp G Q ‚Üí
    (‚àÄ (y : H), Q id Set.univ y) ‚Üí
      e ‚àà StructureGroupoid.maximalAtlas M G ‚Üí x ‚àà e.target ‚Üí ChartedSpace.LiftPropAt Q (‚Üëe.symm) x
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `‚àÄ·∂† (y : H) in cifvar_20 x_1,
  cifvar_16 (cifvar_17 x_0 (cifvar_18 (cifvar_19 x_0) y)) y`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || MeasureTheory.tendsto_of_uncrossing_lt_top : ‚àÄ {Œ© : Type u_1} {f : ‚Ñï ‚Üí Œ© ‚Üí ‚Ñù} {œâ : Œ©},
  Filter.liminf (fun n => ‚Üë‚Äñf n œâ‚Äñ‚Çä) Filter.atTop < ‚ä§ ‚Üí
    (‚àÄ (a b : ‚Ñö), a < b ‚Üí MeasureTheory.upcrossings (‚Üëa) (‚Üëb) f œâ < ‚ä§) ‚Üí
      ‚àÉ c, Filter.Tendsto (fun n => f n œâ) Filter.atTop (nhds c)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `‚àÉ·∂† (n : ‚Ñï) in x_0,
  cifvar_17 (cifvar_18 n cifvar_6) a`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || BitVec.shiftLeft_add_distrib : ‚àÄ {w : ‚Ñï} {x y : BitVec w} {n : ‚Ñï}, (x + y) <<< n = x <<< n + y <<< n
Result.autoException ::
Auto failed to find proof

Testing || Std.DHashMap.Internal.AssocList.get_eq : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : BEq Œ±] {l : Std.DHashMap.Internal.AssocList Œ± fun x => Œ≤} {a : Œ±}
  {h : Std.DHashMap.Internal.AssocList.contains a l = true},
  Std.DHashMap.Internal.AssocList.get a l h = Std.DHashMap.Internal.List.getValue a l.toList ‚ãØ
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Œ±:
  ;;   |_Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ±!val!0| () _Œ±)
  ;; cardinality constraint:
  (forall ((x _Œ±)) (= x |_Œ±!val!0|))
  ;; -----------
  ;; universe for _Std.DHashMap.Internal.AssocList_Œ±_fun_x_=>_Œ≤:
  ;;   |_Std.DHashMap.Internal.AssocList_Œ±_fun_x_=>_Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Std.DHashMap.Internal.AssocList_Œ±_fun_x_=>_Œ≤!val!0| () _Std.DHashMap.Internal.AssocList_Œ±_fun_x_=>_Œ≤)
  ;; cardinality constraint:
  (forall ((x _Std.DHashMap.Internal.AssocList_Œ±_fun_x_=>_Œ≤))
          (= x |_Std.DHashMap.Internal.AssocList_Œ±_fun_x_=>_Œ≤!val!0|))
  ;; -----------
  ;; universe for _Std.DHashMap.Internal.AssocList.contains_a_l_=_true:
  ;;   _Std.DHashMap.Internal.AssocList.contains_a_l_=_true!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _Std.DHashMap.Internal.AssocList.contains_a_l_=_true!val!0 () _Std.DHashMap.Internal.AssocList.contains_a_l_=_true)
  ;; cardinality constraint:
  (forall ((x _Std.DHashMap.Internal.AssocList.contains_a_l_=_true))
          (= x _Std.DHashMap.Internal.AssocList.contains_a_l_=_true!val!0))
  ;; -----------
  ;; universe for _Œ≤:
  ;;   |_Œ≤!val!0| |_Œ≤!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ≤!val!0| () _Œ≤)
  (declare-fun |_Œ≤!val!1| () _Œ≤)
  ;; cardinality constraint:
  (forall ((x _Œ≤)) (or (= x |_Œ≤!val!0|) (= x |_Œ≤!val!1|)))
  ;; -----------
  ;; universe for _Std.DHashMap.Internal.AssocList.contains_a_l_=_Std.DHashMap.Internal.List.containsKey_a_l.toList:
  ;;   _Std.DHashMap.Internal.AssocList.contains_a_l_=_Std.DHashMap.Internal.List.containsKey_a_l.toList!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _Std.DHashMap.Internal.AssocList.contains_a_l_=_Std.DHashMap.Internal.List.containsKey_a_l.toList!val!0 () _Std.DHashMap.Internal.AssocList.contains_a_l_=_Std.DHashMap.Internal.List.containsKey_a_l.toList)
  ;; cardinality constraint:
  (forall ((x _Std.DHashMap.Internal.AssocList.contains_a_l_=_Std.DHashMap.Internal.List.containsKey_a_l.toList))
          (= x
             _Std.DHashMap.Internal.AssocList.contains_a_l_=_Std.DHashMap.Internal.List.containsKey_a_l.toList!val!0))
  ;; -----------
  ;; universe for _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_Std.DHashMap.Internal.AssocList.contains_a_l:
  ;;   _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_Std.DHashMap.Internal.AssocList.contains_a_l!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_Std.DHashMap.Internal.AssocList.contains_a_l!val!0 () _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_Std.DHashMap.Internal.AssocList.contains_a_l)
  ;; cardinality constraint:
  (forall ((x _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_Std.DHashMap.Internal.AssocList.contains_a_l))
          (= x
             _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_Std.DHashMap.Internal.AssocList.contains_a_l!val!0))
  ;; -----------
  ;; universe for _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_true:
  ;;   _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_true!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_true!val!0 () _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_true)
  ;; cardinality constraint:
  (forall ((x _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_true))
          (= x _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_true!val!0))
  ;; -----------
  ;; universe for ______Œ±____Œ≤:
  ;;   |______Œ±____Œ≤!val!1| |______Œ±____Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |______Œ±____Œ≤!val!1| () ______Œ±____Œ≤)
  (declare-fun |______Œ±____Œ≤!val!0| () ______Œ±____Œ≤)
  ;; cardinality constraint:
  (forall ((x ______Œ±____Œ≤))
          (or (= x |______Œ±____Œ≤!val!1|) (= x |______Œ±____Œ≤!val!0|)))
  ;; -----------
  (define-fun valid_fact_3 () Bool
    true)
  (define-fun _a () _Œ±
    |_Œ±!val!0|)
  (define-fun valid_fact_8 () Bool
    true)
  (define-fun _l () _Std.DHashMap.Internal.AssocList_Œ±_fun_x_=>_Œ≤
    |_Std.DHashMap.Internal.AssocList_Œ±_fun_x_=>_Œ≤!val!0|)
  (define-fun valid_fact_4 () Bool
    (forall ((|_Œ±_1| _Œ±)
         (|_Œ±_2| _Œ±)
         (|_Œ≤_0| _Œ≤)
         (_s_0 _Std.DHashMap.Internal.AssocList_Œ±_fun_x_=>_Œ≤))
  (let ((a!1 (not (_Std.DHashMap.Internal.List.containsKey
                    |_Œ±_1|
                    (_Std.DHashMap.Internal.AssocList.toList
                      (_Std.DHashMap.Internal.AssocList.cons
                        |_Œ±_2|
                        |_Œ≤_0|
                        _s_0))))))
    (or (_BEq.beq |_Œ±_2| |_Œ±_1|)
        (_Std.DHashMap.Internal.List.containsKey
          |_Œ±_1|
          (_Std.DHashMap.Internal.AssocList.toList _s_0))
        a!1))))
  (define-fun valid_fact_6 () Bool
    (forall ((_l_0 _List______Œ±____Œ≤) (|_Œ±_5| _Œ±) (|_Œ±_6| _Œ±) (|_Œ≤_2| _Œ≤))
  (let ((a!1 (not (_Std.DHashMap.Internal.List.containsKey
                    |_Œ±_6|
                    (_List.cons (_Sigma.mk |_Œ±_5| |_Œ≤_2|) _l_0)))))
    (or (_BEq.beq |_Œ±_5| |_Œ±_6|)
        (_Std.DHashMap.Internal.List.containsKey |_Œ±_6| _l_0)
        a!1))))
  (define-fun valid_fact_7 () Bool
    (forall ((_l_1 _List______Œ±____Œ≤) (|_Œ±_7| _Œ±) (|_Œ±_8| _Œ±) (|_Œ≤_3| _Œ≤))
  (let ((a!1 (not (_Std.DHashMap.Internal.List.containsKey
                    |_Œ±_8|
                    (_List.cons (_Sigma.mk |_Œ±_7| |_Œ≤_3|) _l_1)))))
    (or (_BEq.beq |_Œ±_7| |_Œ±_8|)
        (_Std.DHashMap.Internal.List.containsKey |_Œ±_8| _l_1)
        a!1))))
  (define-fun valid_fact_5 () Bool
    (forall ((|_Œ±_3| _Œ±)
         (|_Œ±_4| _Œ±)
         (|_Œ≤_1| _Œ≤)
         (_s_1 _Std.DHashMap.Internal.AssocList_Œ±_fun_x_=>_Œ≤))
  (let ((a!1 (not (_Std.DHashMap.Internal.List.containsKey
                    |_Œ±_3|
                    (_Std.DHashMap.Internal.AssocList.toList
                      (_Std.DHashMap.Internal.AssocList.cons
                        |_Œ±_4|
                        |_Œ≤_1|
                        _s_1))))))
    (or (_BEq.beq |_Œ±_4| |_Œ±_3|)
        (_Std.DHashMap.Internal.List.containsKey
          |_Œ±_3|
          (_Std.DHashMap.Internal.AssocList.toList _s_1))
        a!1))))
  (define-fun valid_fact_0 () Bool
    (_Std.DHashMap.Internal.List.containsKey
  _a
  (_Std.DHashMap.Internal.AssocList.toList _l)))
  (define-fun _h () _Std.DHashMap.Internal.AssocList.contains_a_l_=_true
    _Std.DHashMap.Internal.AssocList.contains_a_l_=_true!val!0)
  (define-fun valid_fact_2 () Bool
    true)
  (define-fun valid_fact_1 () Bool
    (let ((a!1 (= (_Std.DHashMap.Internal.AssocList.get_a_l _h)
              (_Std.DHashMap.Internal.List.getValue_a_l.toList
                (_Eq.trans (_Eq.symm _Std.DHashMap.Internal.AssocList.contains_eq)
                           _h)))))
  (not a!1)))
  (define-fun _Std.DHashMap.Internal.AssocList.contains_eq () _Std.DHashMap.Internal.AssocList.contains_a_l_=_Std.DHashMap.Internal.List.containsKey_a_l.toList
    _Std.DHashMap.Internal.AssocList.contains_a_l_=_Std.DHashMap.Internal.List.containsKey_a_l.toList!val!0)
  (define-fun _Eq.trans ((x!0
    _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_Std.DHashMap.Internal.AssocList.contains_a_l)
   (x!1 _Std.DHashMap.Internal.AssocList.contains_a_l_=_true)) _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_true
    _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_true!val!0)
  (define-fun _Sigma.mk ((x!0 _Œ±) (x!1 _Œ≤)) ______Œ±____Œ≤
    |______Œ±____Œ≤!val!0|)
  (define-fun _Std.DHashMap.Internal.List.getValue_a_l.toList ((x!0
    _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_true)) _Œ≤
    |_Œ≤!val!1|)
  (define-fun _Std.DHashMap.Internal.AssocList.cons ((x!0 _Œ±)
   (x!1 _Œ≤)
   (x!2 _Std.DHashMap.Internal.AssocList_Œ±_fun_x_=>_Œ≤)) _Std.DHashMap.Internal.AssocList_Œ±_fun_x_=>_Œ≤
    |_Std.DHashMap.Internal.AssocList_Œ±_fun_x_=>_Œ≤!val!0|)
  (define-fun _Std.DHashMap.Internal.AssocList.get_a_l ((x!0
    _Std.DHashMap.Internal.AssocList.contains_a_l_=_true)) _Œ≤
    |_Œ≤!val!0|)
  (define-fun _Eq.symm ((x!0
    _Std.DHashMap.Internal.AssocList.contains_a_l_=_Std.DHashMap.Internal.List.containsKey_a_l.toList)) _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_Std.DHashMap.Internal.AssocList.contains_a_l
    _Std.DHashMap.Internal.List.containsKey_a_l.toList_=_Std.DHashMap.Internal.AssocList.contains_a_l!val!0)
  (define-fun _BEq.beq ((x!0 _Œ±) (x!1 _Œ±)) Bool
    false)
  (define-fun _Std.DHashMap.Internal.List.containsKey ((x!0 _Œ±)
   (x!1 _List______Œ±____Œ≤)) Bool
    true)
  (define-fun _Std.DHashMap.Internal.AssocList.toList ((x!0
    _Std.DHashMap.Internal.AssocList_Œ±_fun_x_=>_Œ≤)) _List______Œ±____Œ≤
    _pl___)
)


Testing || UniqueFactorizationMonoid.pow_eq_pow_iff : ‚àÄ {M : Type u_1} [inst : CancelCommMonoidWithZero M] {q : M}, ¬¨IsUnit q ‚Üí q ‚â† 0 ‚Üí ‚àÄ {m n : ‚Ñï}, q ^ m = q ^ n ‚Üî m = n
Result.success

Testing || MvPolynomial.radical_le_vanishingIdeal_zeroLocus : ‚àÄ {k : Type u_1} [inst : Field k] {œÉ : Type u_2} (I : Ideal (MvPolynomial œÉ k)),
  I.radical ‚â§ MvPolynomial.vanishingIdeal (MvPolynomial.zeroLocus I)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{J |
  cifvar_15 (cifvar_1 x_0 J) (cifvar_16 J)}`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || SimpleGraph.Walk.not_nil_cons : ‚àÄ {V : Type u} {G : SimpleGraph V} {u v w : V} {h : G.Adj u v} {p : G.Walk v w}, ¬¨(SimpleGraph.Walk.cons h p).Nil
Result.autoException ::
Auto failed to find proof

Testing || Isometry.preimage_emetric_ball : ‚àÄ {Œ± : Type u} {Œ≤ : Type v} [inst : PseudoEMetricSpace Œ±] [inst_1 : PseudoEMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤},
  Isometry f ‚Üí ‚àÄ (x : Œ±) (r : ENNReal), f ‚Åª¬π' EMetric.ball (f x) r = EMetric.ball x r
Result.success

Testing || CategoryTheory.isCoseparating_empty_of_thin : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : Quiver.IsThin C], CategoryTheory.IsCoseparating ‚àÖ
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Set_C:
  ;;   _Set_C!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _Set_C!val!0 () _Set_C)
  ;; cardinality constraint:
  (forall ((x _Set_C)) (= x _Set_C!val!0))
  ;; -----------
  ;; universe for _C:
  ;;   _C!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _C!val!0 () _C)
  ;; cardinality constraint:
  (forall ((x _C)) (= x _C!val!0))
  ;; -----------
  ;; universe for _Type_v‚ÇÅ:
  ;;   |_Type_v‚ÇÅ!val!1| |_Type_v‚ÇÅ!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Type_v‚ÇÅ!val!1| () _Type_v‚ÇÅ)
  (declare-fun |_Type_v‚ÇÅ!val!0| () _Type_v‚ÇÅ)
  ;; cardinality constraint:
  (forall ((x _Type_v‚ÇÅ)) (or (= x |_Type_v‚ÇÅ!val!1|) (= x |_Type_v‚ÇÅ!val!0|)))
  ;; -----------
  (define-fun _pl__ () _Set_C
    _Set_C!val!0)
  (define-fun valid_fact_1 () Bool
    (not (_CategoryTheory.IsCoseparating _pl__)))
  (define-fun valid_fact_0 () Bool
    (forall ((_c _C) (_c_0 _C)) (_Subsingleton (_Quiver.Hom _c _c_0))))
  (define-fun _Subsingleton ((x!0 _Type_v‚ÇÅ)) Bool
    true)
  (define-fun _CategoryTheory.IsCoseparating ((x!0 _Set_C)) Bool
    false)
  (define-fun _Quiver.Hom ((x!0 _C) (x!1 _C)) _Type_v‚ÇÅ
    |_Type_v‚ÇÅ!val!0|)
)


Testing || ENNReal.fun_eq_funMulInvSnorm_mul_snorm : ‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {Œº : MeasureTheory.Measure Œ±} {p : ‚Ñù} (f : Œ± ‚Üí ENNReal),
  ‚à´‚Åª (a : Œ±), f a ^ p ‚àÇŒº ‚â† 0 ‚Üí
    ‚à´‚Åª (a : Œ±), f a ^ p ‚àÇŒº ‚â† ‚ä§ ‚Üí ‚àÄ {a : Œ±}, f a = ENNReal.funMulInvSnorm f p Œº a * (‚à´‚Åª (c : Œ±), f c ^ p ‚àÇŒº) ^ (1 / p)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `‚à´‚Åª (c : Œ±),
  cifvar_11 (cifvar_6 c) x_1 ‚àÇx_0`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || CategoryTheory.IsFiltered.of_isRightAdjoint : ‚àÄ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.IsFiltered C] {D : Type u‚ÇÅ}
  [inst_2 : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D] (R : CategoryTheory.Functor C D) [inst : R.IsRightAdjoint],
  CategoryTheory.IsFiltered D
Result.autoException ::
Auto failed to find proof

Testing || heq_rec_iff_heq : ‚àÄ {Œ± : Sort u_2} {Œ≤ : Sort u_1} {a b : Œ±} {C : Œ± ‚Üí Sort u_1} {x : Œ≤} {y : C a} {e : a = b}, HEq x (e ‚ñ∏ y) ‚Üî HEq x y
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Œ≤:
  ;;   |_Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ≤!val!0| () _Œ≤)
  ;; cardinality constraint:
  (forall ((x _Œ≤)) (= x |_Œ≤!val!0|))
  ;; -----------
  ;; universe for _C_a:
  ;;   _C_a!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _C_a!val!0 () _C_a)
  ;; cardinality constraint:
  (forall ((x _C_a)) (= x _C_a!val!0))
  ;; -----------
  ;; universe for _a_=_b:
  ;;   _a_=_b!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _a_=_b!val!0 () _a_=_b)
  ;; cardinality constraint:
  (forall ((x _a_=_b)) (= x _a_=_b!val!0))
  ;; -----------
  ;; universe for _C_b:
  ;;   _C_b!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _C_b!val!0 () _C_b)
  ;; cardinality constraint:
  (forall ((x _C_b)) (= x _C_b!val!0))
  ;; -----------
  (define-fun _e () _a_=_b
    _a_=_b!val!0)
  (define-fun valid_fact_0 () Bool
    (= (not (_fun_a_=>_HEq_a _x (_fun_refl_=>_Eq.rec_refl _y _e)))
   (_fun_a_1_=>_HEq_a_1_ _x _y)))
  (define-fun _y () _C_a
    _C_a!val!0)
  (define-fun _x () _Œ≤
    |_Œ≤!val!0|)
  (define-fun _fun_a_1_=>_HEq_a_1_ ((x!0 _Œ≤) (x!1 _C_a)) Bool
    false)
  (define-fun _fun_a_=>_HEq_a ((x!0 _Œ≤) (x!1 _C_b)) Bool
    true)
  (define-fun _fun_refl_=>_Eq.rec_refl ((x!0 _C_a) (x!1 _a_=_b)) _C_b
    _C_b!val!0)
)


Testing || CategoryTheory.braiding_tensorUnit_left_assoc : ‚àÄ {C : Type u‚ÇÅ} [inst : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C] [inst_1 : CategoryTheory.MonoidalCategory C]
  [inst_2 : CategoryTheory.BraidedCategory C] (X : C) {Z : C}
  (h : CategoryTheory.MonoidalCategory.tensorObj X (ùüô_ C) ‚ü∂ Z),
  CategoryTheory.CategoryStruct.comp (Œ≤_ (ùüô_ C) X).hom h =
    CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.leftUnitor X).hom
      (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.rightUnitor X).inv h)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `CategoryTheory.MonoidalCategory.leftUnitor
  x_0`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || lipschitzOnWith_iff_norm_div_le : ‚àÄ {E : Type u_3} {F : Type u_4} [inst : SeminormedGroup E] [inst_1 : SeminormedGroup F] {s : Set E} {f : E ‚Üí F}
  {C : NNReal}, LipschitzOnWith C f s ‚Üî ‚àÄ ‚¶Éx : E‚¶Ñ, x ‚àà s ‚Üí ‚àÄ ‚¶Éy : E‚¶Ñ, y ‚àà s ‚Üí ‚Äñf x / f y‚Äñ ‚â§ ‚ÜëC * ‚Äñx / y‚Äñ
Result.success

Testing || ProbabilityTheory.IsMeasurableRatCDF.tendsto_atBot_zero : ‚àÄ {Œ± : Type u_1} [inst : MeasurableSpace Œ±] {f : Œ± ‚Üí ‚Ñö ‚Üí ‚Ñù},
  ProbabilityTheory.IsMeasurableRatCDF f ‚Üí ‚àÄ (a : Œ±), Filter.Tendsto (f a) Filter.atBot (nhds 0)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Filter.Tendsto (cifvar_8 x_0)
  cifvar_3 (cifvar_4 cifvar_5)`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || ULift.up_injective : ‚àÄ {Œ± : Type u}, Function.Injective ULift.up
Result.autoException ::
Auto failed to find proof

Testing || IsCyclotomicExtension.Rat.absdiscr_prime_pow_succ : ‚àÄ (p : ‚Ñï+) (k : ‚Ñï) (K : Type u) [inst : Field K] [hp : Fact (Nat.Prime ‚Üëp)] [inst_1 : CharZero K]
  [inst_2 : IsCyclotomicExtension {p ^ (k + 1)} ‚Ñö K],
  NumberField.discr K = (-1) ^ (‚Üëp ^ k * (‚Üëp - 1) / 2) * ‚Üë‚Üëp ^ (‚Üëp ^ k * ((‚Üëp - 1) * (k + 1) - 1))
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{ x // cifvar_27 x_0 x }`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || SemilatticeSup.ext : ‚àÄ {Œ± : Type u_1} {A B : SemilatticeSup Œ±}, (‚àÄ (x y : Œ±), x ‚â§ y ‚Üî x ‚â§ y) ‚Üí A = B
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _SemilatticeSup_Œ±:
  ;;   |_SemilatticeSup_Œ±!val!1| |_SemilatticeSup_Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_SemilatticeSup_Œ±!val!1| () _SemilatticeSup_Œ±)
  (declare-fun |_SemilatticeSup_Œ±!val!0| () _SemilatticeSup_Œ±)
  ;; cardinality constraint:
  (forall ((x _SemilatticeSup_Œ±))
          (or (= x |_SemilatticeSup_Œ±!val!1|) (= x |_SemilatticeSup_Œ±!val!0|)))
  ;; -----------
  ;; universe for _PartialOrder_Œ±:
  ;;   |_PartialOrder_Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_PartialOrder_Œ±!val!0| () _PartialOrder_Œ±)
  ;; cardinality constraint:
  (forall ((x _PartialOrder_Œ±)) (= x |_PartialOrder_Œ±!val!0|))
  ;; -----------
  ;; universe for _Œ±_0:
  ;;   |_Œ±_0!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ±_0!val!0| () _Œ±_0)
  ;; cardinality constraint:
  (forall ((x _Œ±_0)) (= x |_Œ±_0!val!0|))
  ;; -----------
  (define-fun _Sup.sup_=_Sup.sup_0 () Bool
    false)
  (define-fun valid_fact_3 () Bool
    true)
  (define-fun valid_fact_15 () Bool
    true)
  (define-fun valid_fact_18 () Bool
    (= _SemilatticeSup.toPartialOrder_0 _SemilatticeSup.toPartialOrder))
  (define-fun valid_fact_11 () Bool
    true)
  (define-fun valid_fact_14 () Bool
    (forall ((|_Œ±_22| _Œ±_0) (|_Œ±_23| _Œ±_0))
  (= (_Sup.sup_0 |_Œ±_22| |_Œ±_23|) (_Sup.sup |_Œ±_22| |_Œ±_23|))))
  (define-fun valid_fact_4 () Bool
    true)
  (define-fun valid_fact_24 () Bool
    true)
  (define-fun valid_fact_21 () Bool
    (= _SemilatticeSup.toPartialOrder _SemilatticeSup.toPartialOrder_0))
  (define-fun valid_fact_9 () Bool
    (forall ((|_Œ±_2| _Œ±_0) (|_Œ±_3| _Œ±_0))
  (= (_Sup.sup |_Œ±_2| |_Œ±_3|) (_Sup.sup_0 |_Œ±_2| |_Œ±_3|))))
  (define-fun _SemilatticeSup.toPartialOrder_0 () _PartialOrder_Œ±
    |_PartialOrder_Œ±!val!0|)
  (define-fun _A () _SemilatticeSup_Œ±
    |_SemilatticeSup_Œ±!val!0|)
  (define-fun valid_fact_6 () Bool
    (or (not _Sup.sup_=_Sup.sup_0)
    (= _SemilatticeSup.toSup_0 _SemilatticeSup.toSup)))
  (define-fun valid_fact_1 () Bool
    (or (not _Sup.sup_=_Sup.sup) (= _SemilatticeSup.toSup _SemilatticeSup.toSup_0)))
  (define-fun valid_fact_7 () Bool
    true)
  (define-fun valid_fact_13 () Bool
    (forall ((|_Œ±_18| _Œ±_0) (|_Œ±_19| _Œ±_0))
  (= (_Sup.sup |_Œ±_18| |_Œ±_19|) (_Sup.sup_0 |_Œ±_18| |_Œ±_19|))))
  (define-fun valid_fact_23 () Bool
    true)
  (define-fun valid_fact_22 () Bool
    (= _SemilatticeSup.toPartialOrder_0 _SemilatticeSup.toPartialOrder))
  (define-fun _Sup.sup_=_Sup.sup () Bool
    false)
  (define-fun valid_fact_20 () Bool
    true)
  (define-fun valid_fact_10 () Bool
    (forall ((|_Œ±_6| _Œ±_0) (|_Œ±_7| _Œ±_0))
  (= (_Sup.sup_0 |_Œ±_6| |_Œ±_7|) (_Sup.sup |_Œ±_6| |_Œ±_7|))))
  (define-fun valid_fact_5 () Bool
    (or (not _Sup.sup_=_Sup.sup) (= _SemilatticeSup.toSup _SemilatticeSup.toSup_0)))
  (define-fun _SemilatticeSup.toPartialOrder () _PartialOrder_Œ±
    |_PartialOrder_Œ±!val!0|)
  (define-fun valid_fact_0 () Bool
    (not (= _A _B)))
  (define-fun valid_fact_19 () Bool
    true)
  (define-fun _B () _SemilatticeSup_Œ±
    |_SemilatticeSup_Œ±!val!1|)
  (define-fun valid_fact_16 () Bool
    true)
  (define-fun valid_fact_12 () Bool
    true)
  (define-fun valid_fact_2 () Bool
    (or (not _Sup.sup_=_Sup.sup_0)
    (= _SemilatticeSup.toSup_0 _SemilatticeSup.toSup)))
  (define-fun valid_fact_17 () Bool
    (= _SemilatticeSup.toPartialOrder _SemilatticeSup.toPartialOrder_0))
  (define-fun valid_fact_8 () Bool
    true)
  (define-fun _Sup.sup_=_Sup.sup_1 () Bool
    false)
  (define-fun _SemilatticeSup.toSup_0 () _Sup_Œ±
    |_Sup_Œ±!val!0|)
  (define-fun _Sup.sup_=_Sup.sup_2 () Bool
    false)
  (define-fun _SemilatticeSup.toSup () _Sup_Œ±
    |_Sup_Œ±!val!0|)
  (define-fun _Sup.sup_0 ((x!0 _Œ±_0) (x!1 _Œ±_0)) _Œ±_0
    |_Œ±_0!val!0|)
  (define-fun _Sup.sup ((x!0 _Œ±_0) (x!1 _Œ±_0)) _Œ±_0
    (_Sup.sup_0 x!0 x!1))
  (define-fun _LE.le ((x!0 _Œ±_0) (x!1 _Œ±_0)) Bool
    false)
)


Testing || balanced_zero : ‚àÄ {ùïú : Type u_1} {E : Type u_3} [inst : SeminormedRing ùïú] [inst_1 : AddCommGroup E] [inst_2 : Module ùïú E], Balanced ùïú 0
Result.autoException ::
Auto failed to find proof

Testing || Orientation.oangle_rotation_oangle_left : ‚àÄ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ‚Ñù V] [inst_2 : Fact (Module.finrank ‚Ñù V = 2)]
  (o : Orientation ‚Ñù V (Fin 2)) (x y : V), o.oangle ((o.rotation (o.oangle x y)) x) y = 0
Result.autoException ::
Auto failed to find proof

Testing || Finsupp.card_Ioc : ‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : PartialOrder Œ±] [inst_1 : Zero Œ±] [inst_2 : LocallyFiniteOrder Œ±]
  (f g : Œπ ‚Üí‚ÇÄ Œ±), (Finset.Ioc f g).card = ‚àè i ‚àà f.support ‚à™ g.support, (Finset.Icc (f i) (g i)).card - 1
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `‚àè
  i ‚àà cifvar_8 (cifvar_9 x_0) (cifvar_9 x_1), cifvar_13 (cifvar_15 (cifvar_19 x_0 i) (cifvar_19 x_1 i))`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || SubfieldClass.coe_ratCast : ‚àÄ {K : Type u} [inst : DivisionRing K] {S : Type u_1} [inst_1 : SetLike S K] [h : SubfieldClass S K] (s : S) (x : ‚Ñö),
  ‚Üë‚Üëx = ‚Üëx
Result.autoException ::
Auto failed to find proof

Testing || AnalyticOn.iteratedFDeriv : ‚àÄ {ùïú : Type u_1} [inst : NontriviallyNormedField ùïú] {E : Type u} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace ùïú E] {F : Type v} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace ùïú F] {f : E ‚Üí F}
  {s : Set E} [inst_5 : CompleteSpace F], AnalyticOnNhd ùïú f s ‚Üí ‚àÄ (n : ‚Ñï), AnalyticOnNhd ùïú (iteratedFDeriv ùïú n f) s
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type Fin n of Œª binder contains bound variables

Testing || Set.image2_inter_subset_left : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_5} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s s' : Set Œ±} {t : Set Œ≤},
  Set.image2 f (s ‚à© s') t ‚äÜ Set.image2 f s t ‚à© Set.image2 f s' t
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Set_Œ±:
  ;;   |_Set_Œ±!val!1| |_Set_Œ±!val!2| |_Set_Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_Œ±!val!1| () _Set_Œ±)
  (declare-fun |_Set_Œ±!val!2| () _Set_Œ±)
  (declare-fun |_Set_Œ±!val!0| () _Set_Œ±)
  ;; cardinality constraint:
  (forall ((x _Set_Œ±))
          (or (= x |_Set_Œ±!val!1|) (= x |_Set_Œ±!val!2|) (= x |_Set_Œ±!val!0|)))
  ;; -----------
  ;; universe for _Set_Œ≤:
  ;;   |_Set_Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_Œ≤!val!0| () _Set_Œ≤)
  ;; cardinality constraint:
  (forall ((x _Set_Œ≤)) (= x |_Set_Œ≤!val!0|))
  ;; -----------
  ;; universe for _Set_Œ≥:
  ;;   |_Set_Œ≥!val!1| |_Set_Œ≥!val!4| |_Set_Œ≥!val!3| |_Set_Œ≥!val!0| |_Set_Œ≥!val!2| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_Œ≥!val!1| () _Set_Œ≥)
  (declare-fun |_Set_Œ≥!val!4| () _Set_Œ≥)
  (declare-fun |_Set_Œ≥!val!3| () _Set_Œ≥)
  (declare-fun |_Set_Œ≥!val!0| () _Set_Œ≥)
  (declare-fun |_Set_Œ≥!val!2| () _Set_Œ≥)
  ;; cardinality constraint:
  (forall ((x _Set_Œ≥))
          (or (= x |_Set_Œ≥!val!1|)
              (= x |_Set_Œ≥!val!4|)
              (= x |_Set_Œ≥!val!3|)
              (= x |_Set_Œ≥!val!0|)
              (= x |_Set_Œ≥!val!2|)))
  ;; -----------
  (define-fun valid_fact_0 () Bool
    (not (_Subset (_Set.image2_f (_Inter.inter _s _s_) _t)
              (_Inter.inter_0 (_Set.image2_f _s _t) (_Set.image2_f _s_ _t)))))
  (define-fun valid_fact_1 () Bool
    (forall ((_s_0 _Set_Œ±) (_s_1 _Set_Œ±) (_s_2 _Set_Œ≤))
  (or (not (_Subset_0 _s_0 _s_1))
      (_Subset (_Set.image2_f _s_0 _s_2) (_Set.image2_f _s_1 _s_2)))))
  (define-fun _s_ () _Set_Œ±
    |_Set_Œ±!val!1|)
  (define-fun _s () _Set_Œ±
    |_Set_Œ±!val!0|)
  (define-fun _t () _Set_Œ≤
    |_Set_Œ≤!val!0|)
  (define-fun _Set.image2_f ((x!0 _Set_Œ±) (x!1 _Set_Œ≤)) _Set_Œ≥
    (let ((a!1 (ite (and (not (= x!0 |_Set_Œ±!val!1|))
                         (not (= x!0 |_Set_Œ±!val!0|)))
                    |_Set_Œ≥!val!0|
                    |_Set_Œ≥!val!4|)))
      (ite (and (= x!0 |_Set_Œ±!val!1|) (not (= x!0 |_Set_Œ±!val!0|)))
           |_Set_Œ≥!val!2|
           (ite (= x!0 |_Set_Œ±!val!0|) |_Set_Œ≥!val!1| a!1))))
  (define-fun _Inter.inter_0 ((x!0 _Set_Œ≥) (x!1 _Set_Œ≥)) _Set_Œ≥
    |_Set_Œ≥!val!3|)
  (define-fun _Subset ((x!0 _Set_Œ≥) (x!1 _Set_Œ≥)) Bool
    false)
  (define-fun _Subset_0 ((x!0 _Set_Œ±) (x!1 _Set_Œ±)) Bool
    false)
  (define-fun _Inter.inter ((x!0 _Set_Œ±) (x!1 _Set_Œ±)) _Set_Œ±
    |_Set_Œ±!val!2|)
)


Testing || Irrational.div_nat : ‚àÄ {x : ‚Ñù}, Irrational x ‚Üí ‚àÄ {m : ‚Ñï}, m ‚â† 0 ‚Üí Irrational (x / ‚Üëm)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Oplax.category_comp : ‚àÄ {B : Type u‚ÇÅ} [inst : CategoryTheory.Bicategory B] {C : Type u‚ÇÇ} [inst_1 : CategoryTheory.Bicategory C]
  (F G : CategoryTheory.OplaxFunctor B C) {X Y Z : F ‚ü∂ G} (Œì : CategoryTheory.Oplax.Modification X Y)
  (Œî : CategoryTheory.Oplax.Modification Y Z), CategoryTheory.CategoryStruct.comp Œì Œî = Œì.vcomp Œî
Result.autoException ::
Auto failed to find proof

Testing || homothety_inv_two : ‚àÄ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Field k] [inst_1 : CharZero k] [inst_2 : AddCommGroup V]
  [inst_3 : Module k V] [inst_4 : AddTorsor V P] (a b : P), (AffineMap.homothety a 2‚Åª¬π) b = midpoint k a b
Result.autoException ::
Auto failed to find proof

Testing || MulActionHom.map_smul : ‚àÄ {M' : Type u_1} {X : Type u_5} [inst : SMul M' X] {Y : Type u_6} [inst_1 : SMul M' Y] (f : X ‚Üí‚Çë[id] Y) (m : M')
  (x : X), f (m ‚Ä¢ x) = m ‚Ä¢ f x
Result.success

Testing || AlgebraicGeometry.Scheme.OpenCover.gluedCoverT'_snd_fst : ‚àÄ {X : AlgebraicGeometry.Scheme} (ùí∞ : X.OpenCover) (x y z : ùí∞.J),
  CategoryTheory.CategoryStruct.comp (ùí∞.gluedCoverT' x y z)
      (CategoryTheory.CategoryStruct.comp
        (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.fst (ùí∞.map y) (ùí∞.map z))
          (CategoryTheory.Limits.pullback.fst (ùí∞.map y) (ùí∞.map x)))
        (CategoryTheory.Limits.pullback.fst (ùí∞.map y) (ùí∞.map x))) =
    CategoryTheory.CategoryStruct.comp
      (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.fst (ùí∞.map x) (ùí∞.map y))
        (CategoryTheory.Limits.pullback.fst (ùí∞.map x) (ùí∞.map z)))
      (CategoryTheory.Limits.pullback.snd (ùí∞.map x) (ùí∞.map y))
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_16.map x_0`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || List.unattach_join : ‚àÄ {Œ± : Type u_1} {p : Œ± ‚Üí Prop} {l : List (List { x // p x })}, l.join.unattach = (List.map List.unattach l).join
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Œ±:
  ;;   |_Œ±!val!1| |_Œ±!val!2| |_Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ±!val!1| () _Œ±)
  (declare-fun |_Œ±!val!2| () _Œ±)
  (declare-fun |_Œ±!val!0| () _Œ±)
  ;; cardinality constraint:
  (forall ((x _Œ±)) (or (= x |_Œ±!val!1|) (= x |_Œ±!val!2|) (= x |_Œ±!val!0|)))
  ;; -----------
  ;; universe for ___x_//_p_x__:
  ;;   ___x_//_p_x__!val!2 ___x_//_p_x__!val!3 ___x_//_p_x__!val!5 ___x_//_p_x__!val!6 ___x_//_p_x__!val!1 ___x_//_p_x__!val!4 ___x_//_p_x__!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun ___x_//_p_x__!val!2 () ___x_//_p_x__)
  (declare-fun ___x_//_p_x__!val!3 () ___x_//_p_x__)
  (declare-fun ___x_//_p_x__!val!5 () ___x_//_p_x__)
  (declare-fun ___x_//_p_x__!val!6 () ___x_//_p_x__)
  (declare-fun ___x_//_p_x__!val!1 () ___x_//_p_x__)
  (declare-fun ___x_//_p_x__!val!4 () ___x_//_p_x__)
  (declare-fun ___x_//_p_x__!val!0 () ___x_//_p_x__)
  ;; cardinality constraint:
  (forall ((x ___x_//_p_x__))
          (or (= x ___x_//_p_x__!val!2)
              (= x ___x_//_p_x__!val!3)
              (= x ___x_//_p_x__!val!5)
              (= x ___x_//_p_x__!val!6)
              (= x ___x_//_p_x__!val!1)
              (= x ___x_//_p_x__!val!4)
              (= x ___x_//_p_x__!val!0)))
  ;; -----------
  (define-fun valid_fact_5 () Bool
    (forall ((_l_7 _List_List_List___x_//_p_x__))
  (= (_List.map_List.unattach (_List.join_1 _l_7))
     (_List.join_2 (_List.map_List.map_List.unattach _l_7)))))
  (define-fun valid_fact_3 () Bool
    (forall ((_l_4 _List_List_List___x_//_p_x__)
         (_l_5 _List_List_List___x_//_p_x__))
  (= (_List.map_List.map_List.unattach (_HAppend.hAppend_3 _l_4 _l_5))
     (_HAppend.hAppend_4
       (_List.map_List.map_List.unattach _l_4)
       (_List.map_List.map_List.unattach _l_5)))))
  (define-fun valid_fact_4 () Bool
    (forall ((_l_6 _List_List___x_//_p_x__))
  (= (_List.map_fun_x_=>__x (_List.join _l_6))
     (_List.join_0 (_List.map_List.unattach _l_6)))))
  (define-fun valid_fact_2 () Bool
    (forall ((_l_2 _List___x_//_p_x__) (_l_3 _List___x_//_p_x__))
  (= (_List.map_fun_x_=>__x (_HAppend.hAppend_1 _l_2 _l_3))
     (_HAppend.hAppend_2
       (_List.map_fun_x_=>__x _l_2)
       (_List.map_fun_x_=>__x _l_3)))))
  (define-fun valid_fact_1 () Bool
    (forall ((_l_0 _List_List___x_//_p_x__) (_l_1 _List_List___x_//_p_x__))
  (= (_List.map_List.unattach (_HAppend.hAppend _l_0 _l_1))
     (_HAppend.hAppend_0
       (_List.map_List.unattach _l_0)
       (_List.map_List.unattach _l_1)))))
  (define-fun valid_fact_6 () Bool
    (forall ((_l_8 _List_List_List_List___x_//_p_x__))
  (= (_List.map_List.map_List.unattach (_List.join_3 _l_8))
     (_List.join_4 (_List.map_List.map_List.map_List.unattach _l_8)))))
  (define-fun valid_fact_0 () Bool
    (not (= (_List.unattach (_List.join _l))
        (_List.join_0 (_List.map_List.unattach _l)))))
  (define-fun _l () _List_List___x_//_p_x__
    _pl____0)
  (define-fun _List.unattach ((x!0 _List___x_//_p_x__)) _List_Œ±
    _pl____1)
  (define-fun _List.join_4 ((x!0 _List_List_List_List_Œ±)) _List_List_List_Œ±
    _pl____4)
  (define-fun _HAppend.hAppend_2 ((x!0 _List_Œ±) (x!1 _List_Œ±)) _List_Œ±
    _pl____1)
  (define-fun _List.map_List.map_List.unattach ((x!0 _List_List_List___x_//_p_x__)) _List_List_List_Œ±
    _pl____4)
  (define-fun _List.join_2 ((x!0 _List_List_List_Œ±)) _List_List_Œ±
    _pl____2)
  (define-fun _List.join ((x!0 _List_List___x_//_p_x__)) _List___x_//_p_x__
    _pl___)
  (define-fun _HAppend.hAppend ((x!0 _List_List___x_//_p_x__)
   (x!1 _List_List___x_//_p_x__)) _List_List___x_//_p_x__
    (_List.cons_0 (_List.cons ___x_//_p_x__!val!2
                              (_List.cons ___x_//_p_x__!val!0 _pl___))
                  _pl____0))
  (define-fun _List.map_fun_x_=>__x ((x!0 _List___x_//_p_x__)) _List_Œ±
    (ite (= x!0 _pl___) (_List.cons_1 |_Œ±!val!0| _pl____1)
      _pl____1))
  (define-fun _List.join_1 ((x!0 _List_List_List___x_//_p_x__)) _List_List___x_//_p_x__
    (_List.cons_0 (_List.cons ___x_//_p_x__!val!3
                              (_List.cons ___x_//_p_x__!val!0 _pl___))
                  (_List.cons_0 (_List.cons ___x_//_p_x__!val!2
                                            (_List.cons ___x_//_p_x__!val!0
                                                        _pl___))
                                _pl____0)))
  (define-fun _HAppend.hAppend_3 ((x!0 _List_List_List___x_//_p_x__)
   (x!1 _List_List_List___x_//_p_x__)) _List_List_List___x_//_p_x__
    (let ((a!1 (_List.cons_0 (_List.cons ___x_//_p_x__!val!3
                                         (_List.cons ___x_//_p_x__!val!0 _pl___))
                             (_List.cons_0 (_List.cons ___x_//_p_x__!val!2
                                                       (_List.cons ___x_//_p_x__!val!0
                                                                   _pl___))
                                           _pl____0))))
    (let ((a!2 (_List.cons_0 (_List.cons ___x_//_p_x__!val!4
                                         (_List.cons ___x_//_p_x__!val!3
                                                     (_List.cons ___x_//_p_x__!val!0
                                                                 _pl___)))
                             a!1)))
      (_List.cons_3 a!2 _pl____3))))
  (define-fun _List.map_List.map_List.map_List.unattach ((x!0
    _List_List_List_List___x_//_p_x__)) _List_List_List_List_Œ±
    _pl____6)
  (define-fun _HAppend.hAppend_0 ((x!0 _List_List_Œ±) (x!1 _List_List_Œ±)) _List_List_Œ±
    _pl____2)
  (define-fun _HAppend.hAppend_4 ((x!0 _List_List_List_Œ±)
   (x!1 _List_List_List_Œ±)) _List_List_List_Œ±
    _pl____4)
  (define-fun _List.join_0 ((x!0 _List_List_Œ±)) _List_Œ±
    (_List.cons_1 |_Œ±!val!0| _pl____1))
  (define-fun _HAppend.hAppend_1 ((x!0 _List___x_//_p_x__)
   (x!1 _List___x_//_p_x__)) _List___x_//_p_x__
    (ite (and (= x!0 _pl___) (= x!1 _pl___))
      (_List.cons ___x_//_p_x__!val!0 _pl___)
      (_List.cons ___x_//_p_x__!val!5
                  (_List.cons ___x_//_p_x__!val!3
                              (_List.cons ___x_//_p_x__!val!0 _pl___)))))
  (define-fun _List.map_List.unattach ((x!0 _List_List___x_//_p_x__)) _List_List_Œ±
    _pl____2)
  (define-fun _List.join_3 ((x!0 _List_List_List_List___x_//_p_x__)) _List_List_List___x_//_p_x__
    (let ((a!1 (_List.cons_0 (_List.cons ___x_//_p_x__!val!3
                                         (_List.cons ___x_//_p_x__!val!0 _pl___))
                             (_List.cons_0 (_List.cons ___x_//_p_x__!val!2
                                                       (_List.cons ___x_//_p_x__!val!0
                                                                   _pl___))
                                           _pl____0))))
    (let ((a!2 (_List.cons_0 (_List.cons ___x_//_p_x__!val!6
                                         (_List.cons ___x_//_p_x__!val!3
                                                     (_List.cons ___x_//_p_x__!val!0
                                                                 _pl___)))
                             a!1))
          (a!3 (_List.cons_0 (_List.cons ___x_//_p_x__!val!4
                                         (_List.cons ___x_//_p_x__!val!3
                                                     (_List.cons ___x_//_p_x__!val!0
                                                                 _pl___)))
                             a!1)))
      (_List.cons_3 a!2 (_List.cons_3 a!3 _pl____3)))))
)


Testing || ContinuousLinearEquiv.piCongrRight_symm_apply : ‚àÄ {R‚ÇÅ : Type u_1} [inst : Semiring R‚ÇÅ] {Œπ : Type u_9} {M : Œπ ‚Üí Type u_10} [inst_1 : (i : Œπ) ‚Üí TopologicalSpace (M i)]
  [inst_2 : (i : Œπ) ‚Üí AddCommMonoid (M i)] [inst_3 : (i : Œπ) ‚Üí Module R‚ÇÅ (M i)] {N : Œπ ‚Üí Type u_11}
  [inst_4 : (i : Œπ) ‚Üí TopologicalSpace (N i)] [inst_5 : (i : Œπ) ‚Üí AddCommMonoid (N i)]
  [inst_6 : (i : Œπ) ‚Üí Module R‚ÇÅ (N i)] (f : (i : Œπ) ‚Üí M i ‚âÉL[R‚ÇÅ] N i) (n : (i : Œπ) ‚Üí N i) (i : Œπ),
  (ContinuousLinearEquiv.piCongrRight f).symm n i = (f i).symm (n i)
Result.autoException ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || Int.le_iff_pos_of_dvd : ‚àÄ {a b : ‚Ñ§}, 0 < a ‚Üí a ‚à£ b ‚Üí (a ‚â§ b ‚Üî 0 < b)
Result.success

Testing || Real.zpow_le_of_le_log : ‚àÄ {x y : ‚Ñù} {n : ‚Ñ§}, 0 < y ‚Üí Real.log x ‚â§ ‚Üën * Real.log y ‚Üí x ‚â§ y ^ n
Result.success

Testing || Ideal.radical_eq_top : ‚àÄ {R : Type u} [inst : CommSemiring R] {I : Ideal R}, I.radical = ‚ä§ ‚Üî I = ‚ä§
Result.autoException ::
Auto failed to find proof

Testing || AlgebraicGeometry.ŒìSpec.toOpen_comp_locallyRingedSpaceAdjunction_homEquiv_app : ‚àÄ {X : AlgebraicGeometry.LocallyRingedSpace} {R : Type u} [inst : CommRing R]
  (f : AlgebraicGeometry.LocallyRingedSpace.Œì.rightOp.obj X ‚ü∂ Opposite.op (CommRingCat.of R))
  (U :
    (TopologicalSpace.Opens
        ‚Üë‚Üë(AlgebraicGeometry.Spec.toLocallyRingedSpace.obj (Opposite.op (CommRingCat.of R))).toPresheafedSpace)·µí·µñ),
  CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.StructureSheaf.toOpen R (Opposite.unop U))
      (((AlgebraicGeometry.ŒìSpec.locallyRingedSpaceAdjunction.homEquiv X (Opposite.op (CommRingCat.of R))) f).c.app U) =
    CategoryTheory.CategoryStruct.comp f.unop (X.presheaf.map (CategoryTheory.homOfLE ‚ãØ).op)
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WeierstrassCurve.Affine.nonsingular_negAdd : ‚àÄ {F : Type u} [inst : Field F] {W : WeierstrassCurve.Affine F} {x‚ÇÅ x‚ÇÇ y‚ÇÅ y‚ÇÇ : F},
  W.Nonsingular x‚ÇÅ y‚ÇÅ ‚Üí
    W.Nonsingular x‚ÇÇ y‚ÇÇ ‚Üí
      (x‚ÇÅ = x‚ÇÇ ‚Üí y‚ÇÅ ‚â† W.negY x‚ÇÇ y‚ÇÇ) ‚Üí
        W.Nonsingular (W.addX x‚ÇÅ x‚ÇÇ (W.slope x‚ÇÅ x‚ÇÇ y‚ÇÅ y‚ÇÇ)) (W.negAddY x‚ÇÅ x‚ÇÇ y‚ÇÅ (W.slope x‚ÇÅ x‚ÇÇ y‚ÇÅ y‚ÇÇ))
Result.autoException ::
Auto failed to find proof

Testing || finrank_le_one : ‚àÄ {R : Type u} {M : Type v} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]
  [inst_3 : NoZeroSMulDivisors R M] [inst_4 : StrongRankCondition R] (v : M),
  (‚àÄ (w : M), ‚àÉ c, c ‚Ä¢ v = w) ‚Üí Module.finrank R M ‚â§ 1
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `One.toOfNat1`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || Option.map‚ÇÇ_coe_left : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Œ±) (b : Option Œ≤),
  Option.map‚ÇÇ f (some a) b = Option.map (fun b => f a b) b
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Œ±:
  ;;   |_Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ±!val!0| () _Œ±)
  ;; cardinality constraint:
  (forall ((x _Œ±)) (= x |_Œ±!val!0|))
  ;; -----------
  ;; universe for _Œ≥:
  ;;   |_Œ≥!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ≥!val!0| () _Œ≥)
  ;; cardinality constraint:
  (forall ((x _Œ≥)) (= x |_Œ≥!val!0|))
  ;; -----------
  (define-fun _a () _Œ±
    |_Œ±!val!0|)
  (define-fun valid_fact_0 () Bool
    (not (= (|_Option.map‚ÇÇ_f| (_some_1 _a) _b) (_Option.map_fun_b_=>_f_a_b _b))))
  (define-fun _b () _Option_Œ≤
    _none)
  (define-fun |_Option.map‚ÇÇ_f| ((x!0 _Option_Œ±) (x!1 _Option_Œ≤)) _Option_Œ≥
    _none_0)
  (define-fun _Option.map_fun_b_=>_f_a_b ((x!0 _Option_Œ≤)) _Option_Œ≥
    (_some_0 |_Œ≥!val!0|))
)


Testing || DomMulAct.inducing_mk_symm : ‚àÄ {M : Type u_1} [inst : TopologicalSpace M], IsInducing ‚áëDomMulAct.mk.symm
Result.success

Testing || ContinuousAlternatingMap.map_update_zero : ‚àÄ {R : Type u_1} {M : Type u_2} {N : Type u_4} {Œπ : Type u_6} [inst : Semiring R] [inst_1 : AddCommMonoid M]
  [inst_2 : Module R M] [inst_3 : TopologicalSpace M] [inst_4 : AddCommMonoid N] [inst_5 : Module R N]
  [inst_6 : TopologicalSpace N] (f : M [‚ãÄ^Œπ]‚ÜíL[R] N) [inst_7 : DecidableEq Œπ] (m : Œπ ‚Üí M) (i : Œπ),
  f (Function.update m i 0) = 0
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _M___^Œπ__L_R__N:
  ;;   |_M___^Œπ__L_R__N!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_M___^Œπ__L_R__N!val!0| () _M___^Œπ__L_R__N)
  ;; cardinality constraint:
  (forall ((x _M___^Œπ__L_R__N)) (= x |_M___^Œπ__L_R__N!val!0|))
  ;; -----------
  ;; universe for _N:
  ;;   _N!val!1 _N!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _N!val!1 () _N)
  (declare-fun _N!val!0 () _N)
  ;; cardinality constraint:
  (forall ((x _N)) (or (= x _N!val!1) (= x _N!val!0)))
  ;; -----------
  (define-fun _f () _M___^Œπ__L_R__N
    |_M___^Œπ__L_R__N!val!0|)
  (define-fun valid_fact_0 () Bool
    (not (= (_fun_a_=>_a_Function.update_m_i_0_ _f) _0_)))
  (define-fun _0_ () _N
    _N!val!1)
  (define-fun _fun_a_=>_a_Function.update_m_i_0_ ((x!0 _M___^Œπ__L_R__N)) _N
    _N!val!0)
)


Testing || ArithmeticFunction.pmul_apply : ‚àÄ {R : Type u_1} [inst : MulZeroClass R] {f g : ArithmeticFunction R} {x : ‚Ñï}, (f.pmul g) x = f x * g x
Result.autoException ::
Auto failed to find proof

Testing || List.dropLast_prefix : ‚àÄ {Œ± : Type u_1} (l : List Œ±), l.dropLast <+: l
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  (define-fun _l () _List_Œ±
    _pl___)
  (define-fun valid_fact_2 () Bool
    (forall ((_l_0 _List_Œ±)) (= (_HAppend.hAppend _l_0 _pl___) _l_0)))
  (define-fun valid_fact_0 () Bool
    (not (_List.IsPrefix (_List.dropLast _l) _l)))
  (define-fun valid_fact_1 () Bool
    (= (_List.dropLast _pl___) _pl___))
  (define-fun valid_fact_3 () Bool
    true)
  (define-fun _List.dropLast ((x!0 _List_Œ±)) _List_Œ±
    _pl___)
  (define-fun _HAppend.hAppend ((x!0 _List_Œ±) (x!1 _List_Œ±)) _List_Œ±
    x!0)
  (define-fun _List.IsPrefix ((x!0 _List_Œ±) (x!1 _List_Œ±)) Bool
    false)
)


Testing || AlgebraicGeometry.Scheme.homOfLE_Œπ : ‚àÄ (X : AlgebraicGeometry.Scheme) {U V : X.Opens} (e : U ‚â§ V), CategoryTheory.CategoryStruct.comp (X.homOfLE e) V.Œπ = U.Œπ
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type ‚Üë‚Üë(‚Üëx_0).toPresheafedSpace of Œª binder contains bound variables

Testing || Set.range_list_getI : ‚àÄ {Œ± : Type u_1} [inst : Inhabited Œ±] (l : List Œ±), Set.range l.getI = insert default {x | x ‚àà l}
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Set.range fun n =>
  cifvar_8 (cifvar_9 x_0 n) x_1`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || IsQuotientMap.isClopen_preimage : ‚àÄ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X ‚Üí Y},
  IsQuotientMap f ‚Üí ‚àÄ {s : Set Y}, IsClopen (f ‚Åª¬π' s) ‚Üî IsClopen s
Result.autoException ::
Auto failed to find proof

Testing || Bifunctor.id_fst : ‚àÄ {F : Type u‚ÇÄ ‚Üí Type u‚ÇÅ ‚Üí Type u‚ÇÇ} [inst : Bifunctor F] [inst_1 : LawfulBifunctor F] {Œ± : Type u‚ÇÄ} {Œ≤ : Type u‚ÇÅ}
  (x : F Œ± Œ≤), Bifunctor.fst id x = x
Result.success

Testing || Auto.Embedding.Lam.LamTerm.rwGenAll_atom : ‚àÄ {conv : Auto.Embedding.Lam.LamTerm ‚Üí Option Auto.Embedding.Lam.LamTerm} {n : ‚Ñï},
  Auto.Embedding.Lam.LamTerm.rwGenAll conv (Auto.Embedding.Lam.LamTerm.atom n) =
    some ((conv (Auto.Embedding.Lam.LamTerm.atom n)).getD (Auto.Embedding.Lam.LamTerm.atom n))
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `match cifvar_7 x_0 with
| some t' => cifvar_5 t'
| none => cifvar_5 x_0`.
This is because it has subterms possessing at least one of the following features
¬∑ Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
¬∑ Œª binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
¬∑ Other (TODO)

Testing || Multiset.Nodup.product : ‚àÄ {Œ± : Type u_1} {Œ≤ : Type v} {s : Multiset Œ±} {t : Multiset Œ≤}, s.Nodup ‚Üí t.Nodup ‚Üí (s √óÀ¢ t).Nodup
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Multiset_Œ±:
  ;;   |_Multiset_Œ±!val!1| |_Multiset_Œ±!val!2| |_Multiset_Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±!val!1| () _Multiset_Œ±)
  (declare-fun |_Multiset_Œ±!val!2| () _Multiset_Œ±)
  (declare-fun |_Multiset_Œ±!val!0| () _Multiset_Œ±)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±))
          (or (= x |_Multiset_Œ±!val!1|)
              (= x |_Multiset_Œ±!val!2|)
              (= x |_Multiset_Œ±!val!0|)))
  ;; -----------
  ;; universe for _Multiset_Œ≤:
  ;;   |_Multiset_Œ≤!val!2| |_Multiset_Œ≤!val!1| |_Multiset_Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ≤!val!2| () _Multiset_Œ≤)
  (declare-fun |_Multiset_Œ≤!val!1| () _Multiset_Œ≤)
  (declare-fun |_Multiset_Œ≤!val!0| () _Multiset_Œ≤)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ≤))
          (or (= x |_Multiset_Œ≤!val!2|)
              (= x |_Multiset_Œ≤!val!1|)
              (= x |_Multiset_Œ≤!val!0|)))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ≤:
  ;;   |_Multiset_Œ±___Œ≤!val!0| |_Multiset_Œ±___Œ≤!val!1| |_Multiset_Œ±___Œ≤!val!2| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ≤!val!0| () _Multiset_Œ±___Œ≤)
  (declare-fun |_Multiset_Œ±___Œ≤!val!1| () _Multiset_Œ±___Œ≤)
  (declare-fun |_Multiset_Œ±___Œ≤!val!2| () _Multiset_Œ±___Œ≤)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ≤))
          (or (= x |_Multiset_Œ±___Œ≤!val!0|)
              (= x |_Multiset_Œ±___Œ≤!val!1|)
              (= x |_Multiset_Œ±___Œ≤!val!2|)))
  ;; -----------
  ;; universe for _Multiset_Œ≤___Œ±:
  ;;   |_Multiset_Œ≤___Œ±!val!0| |_Multiset_Œ≤___Œ±!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ≤___Œ±!val!0| () _Multiset_Œ≤___Œ±)
  (declare-fun |_Multiset_Œ≤___Œ±!val!1| () _Multiset_Œ≤___Œ±)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ≤___Œ±))
          (or (= x |_Multiset_Œ≤___Œ±!val!0|) (= x |_Multiset_Œ≤___Œ±!val!1|)))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ±:
  ;;   |_Multiset_Œ±___Œ±!val!1| |_Multiset_Œ±___Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ±!val!1| () _Multiset_Œ±___Œ±)
  (declare-fun |_Multiset_Œ±___Œ±!val!0| () _Multiset_Œ±___Œ±)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ±))
          (or (= x |_Multiset_Œ±___Œ±!val!1|) (= x |_Multiset_Œ±___Œ±!val!0|)))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ≤___Œ±:
  ;;   |_Multiset_Œ±___Œ≤___Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ≤___Œ±!val!0| () _Multiset_Œ±___Œ≤___Œ±)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ≤___Œ±)) (= x |_Multiset_Œ±___Œ≤___Œ±!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ≤___Œ±_0:
  ;;   |_Multiset_Œ±___Œ≤___Œ±_0!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ≤___Œ±_0!val!0| () _Multiset_Œ±___Œ≤___Œ±_0)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ≤___Œ±_0)) (= x |_Multiset_Œ±___Œ≤___Œ±_0!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ±___Œ≤___Œ±:
  ;;   |_Multiset_Œ±___Œ±___Œ≤___Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ±___Œ≤___Œ±!val!0| () _Multiset_Œ±___Œ±___Œ≤___Œ±)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ±___Œ≤___Œ±))
          (= x |_Multiset_Œ±___Œ±___Œ≤___Œ±!val!0|))
  ;; -----------
  ;; universe for _Œ±:
  ;;   |_Œ±!val!0| |_Œ±!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ±!val!0| () _Œ±)
  (declare-fun |_Œ±!val!1| () _Œ±)
  ;; cardinality constraint:
  (forall ((x _Œ±)) (or (= x |_Œ±!val!0|) (= x |_Œ±!val!1|)))
  ;; -----------
  ;; universe for _Œ≤:
  ;;   |_Œ≤!val!0| |_Œ≤!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Œ≤!val!0| () _Œ≤)
  (declare-fun |_Œ≤!val!1| () _Œ≤)
  ;; cardinality constraint:
  (forall ((x _Œ≤)) (or (= x |_Œ≤!val!0|) (= x |_Œ≤!val!1|)))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ≤___Œ±___Œ≤:
  ;;   |_Multiset_Œ±___Œ≤___Œ±___Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ≤___Œ±___Œ≤!val!0| () _Multiset_Œ±___Œ≤___Œ±___Œ≤)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ≤___Œ±___Œ≤))
          (= x |_Multiset_Œ±___Œ≤___Œ±___Œ≤!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ±___Œ±___Œ≤:
  ;;   |_Multiset_Œ±___Œ±___Œ±___Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ±___Œ±___Œ≤!val!0| () _Multiset_Œ±___Œ±___Œ±___Œ≤)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ±___Œ±___Œ≤))
          (= x |_Multiset_Œ±___Œ±___Œ±___Œ≤!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ±___Œ≤:
  ;;   |_Multiset_Œ±___Œ±___Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ±___Œ≤!val!0| () _Multiset_Œ±___Œ±___Œ≤)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ±___Œ≤)) (= x |_Multiset_Œ±___Œ±___Œ≤!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ±___Œ≤___Œ≤:
  ;;   |_Multiset_Œ±___Œ±___Œ≤___Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ±___Œ≤___Œ≤!val!0| () _Multiset_Œ±___Œ±___Œ≤___Œ≤)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ±___Œ≤___Œ≤))
          (= x |_Multiset_Œ±___Œ±___Œ≤___Œ≤!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ≤___Œ±___Œ≤:
  ;;   |_Multiset_Œ≤___Œ±___Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ≤___Œ±___Œ≤!val!0| () _Multiset_Œ≤___Œ±___Œ≤)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ≤___Œ±___Œ≤)) (= x |_Multiset_Œ≤___Œ±___Œ≤!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ≤___Œ≤:
  ;;   |_Multiset_Œ±___Œ≤___Œ≤!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ≤___Œ≤!val!0| () _Multiset_Œ±___Œ≤___Œ≤)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ≤___Œ≤)) (= x |_Multiset_Œ±___Œ≤___Œ≤!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ≤___Œ±___Œ±:
  ;;   |_Multiset_Œ≤___Œ±___Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ≤___Œ±___Œ±!val!0| () _Multiset_Œ≤___Œ±___Œ±)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ≤___Œ±___Œ±)) (= x |_Multiset_Œ≤___Œ±___Œ±!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ±___Œ≤___Œ±_0:
  ;;   |_Multiset_Œ±___Œ±___Œ≤___Œ±_0!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ±___Œ≤___Œ±_0!val!0| () _Multiset_Œ±___Œ±___Œ≤___Œ±_0)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ±___Œ≤___Œ±_0))
          (= x |_Multiset_Œ±___Œ±___Œ≤___Œ±_0!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ≤___Œ±___Œ±:
  ;;   |_Multiset_Œ±___Œ≤___Œ±___Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ≤___Œ±___Œ±!val!0| () _Multiset_Œ±___Œ≤___Œ±___Œ±)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ≤___Œ±___Œ±))
          (= x |_Multiset_Œ±___Œ≤___Œ±___Œ±!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ≤___Œ≤___Œ±:
  ;;   |_Multiset_Œ±___Œ≤___Œ≤___Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ≤___Œ≤___Œ±!val!0| () _Multiset_Œ±___Œ≤___Œ≤___Œ±)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ≤___Œ≤___Œ±))
          (= x |_Multiset_Œ±___Œ≤___Œ≤___Œ±!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ≤___Œ±___Œ≤___Œ±:
  ;;   |_Multiset_Œ≤___Œ±___Œ≤___Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ≤___Œ±___Œ≤___Œ±!val!0| () _Multiset_Œ≤___Œ±___Œ≤___Œ±)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ≤___Œ±___Œ≤___Œ±))
          (= x |_Multiset_Œ≤___Œ±___Œ≤___Œ±!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ±___Œ±:
  ;;   |_Multiset_Œ±___Œ±___Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ±___Œ±!val!0| () _Multiset_Œ±___Œ±___Œ±)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ±___Œ±)) (= x |_Multiset_Œ±___Œ±___Œ±!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ≤___Œ±___Œ±_0:
  ;;   |_Multiset_Œ±___Œ≤___Œ±___Œ±_0!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ≤___Œ±___Œ±_0!val!0| () _Multiset_Œ±___Œ≤___Œ±___Œ±_0)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ≤___Œ±___Œ±_0))
          (= x |_Multiset_Œ±___Œ≤___Œ±___Œ±_0!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ±___Œ±___Œ≤___Œ±:
  ;;   |_Multiset_Œ±___Œ±___Œ±___Œ≤___Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ±___Œ±___Œ≤___Œ±!val!0| () _Multiset_Œ±___Œ±___Œ±___Œ≤___Œ±)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ±___Œ±___Œ≤___Œ±))
          (= x |_Multiset_Œ±___Œ±___Œ±___Œ≤___Œ±!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ±___Œ≤___Œ±___Œ±:
  ;;   |_Multiset_Œ±___Œ±___Œ≤___Œ±___Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ±___Œ≤___Œ±___Œ±!val!0| () _Multiset_Œ±___Œ±___Œ≤___Œ±___Œ±)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ±___Œ≤___Œ±___Œ±))
          (= x |_Multiset_Œ±___Œ±___Œ≤___Œ±___Œ±!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ±___Œ≤___Œ≤___Œ±:
  ;;   |_Multiset_Œ±___Œ±___Œ≤___Œ≤___Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ±___Œ≤___Œ≤___Œ±!val!0| () _Multiset_Œ±___Œ±___Œ≤___Œ≤___Œ±)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ±___Œ≤___Œ≤___Œ±))
          (= x |_Multiset_Œ±___Œ±___Œ≤___Œ≤___Œ±!val!0|))
  ;; -----------
  ;; universe for _Multiset_Œ±___Œ≤___Œ±___Œ≤___Œ±:
  ;;   |_Multiset_Œ±___Œ≤___Œ±___Œ≤___Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiset_Œ±___Œ≤___Œ±___Œ≤___Œ±!val!0| () _Multiset_Œ±___Œ≤___Œ±___Œ≤___Œ±)
  ;; cardinality constraint:
  (forall ((x _Multiset_Œ±___Œ≤___Œ±___Œ≤___Œ±))
          (= x |_Multiset_Œ±___Œ≤___Œ±___Œ≤___Œ±!val!0|))
  ;; -----------
  (define-fun valid_fact_1 () Bool
    (_Multiset.Nodup_0 _t))
  (define-fun valid_fact_36 () Bool
    (forall ((_l_65 _List_Œ±) (_l_66 _List_Œ≤___Œ±___Œ≤))
  (or (not (_Multiset.Nodup (_Multiset.ofList _l_65)))
      (_List.Nodup_8 (_SProd.sprod_22 _l_65 _l_66))
      (not (_List.Nodup_2 _l_66)))))
  (define-fun valid_fact_33 () Bool
    (forall ((_l_59 _List_Œ±) (_l_60 _List_Œ≤___Œ±))
  (or (not (_Multiset.Nodup (_Multiset.ofList _l_59)))
      (_List.Nodup_5 (_SProd.sprod_14 _l_59 _l_60))
      (not (_List.Nodup _l_60)))))
  (define-fun valid_fact_25 () Bool
    (forall ((_l_43 _List_Œ±___Œ≤___Œ±___Œ≤) (_l_44 _List_Œ±))
  (= (_SProd.sprod_43 (_Multiset.ofList_12 _l_43) (_Multiset.ofList _l_44))
     (_Multiset.ofList_23 (_SProd.sprod_44 _l_43 _l_44)))))
  (define-fun valid_fact_35 () Bool
    (forall ((_l_63 _List_Œ±) (_l_64 _List_Œ±___Œ≤___Œ±))
  (or (not (_Multiset.Nodup (_Multiset.ofList _l_63)))
      (_List.Nodup_7 (_SProd.sprod_18 _l_63 _l_64))
      (not (_List.Nodup_1 _l_64)))))
  (define-fun valid_fact_24 () Bool
    (forall ((_l_41 _List_Œ±___Œ±___Œ≤___Œ≤) (_l_42 _List_Œ±))
  (= (_SProd.sprod_41 (_Multiset.ofList_11 _l_41) (_Multiset.ofList _l_42))
     (_Multiset.ofList_22 (_SProd.sprod_42 _l_41 _l_42)))))
  (define-fun valid_fact_15 () Bool
    (forall ((_l_23 _List_Œ≤___Œ±) (_l_24 _List_Œ±))
  (= (_SProd.sprod_23 (_Multiset.ofList_2 _l_23) (_Multiset.ofList _l_24))
     (_Multiset.ofList_13 (_SProd.sprod_24 _l_23 _l_24)))))
  (define-fun valid_fact_18 () Bool
    (forall ((_l_29 _List_Œ±___Œ≤___Œ≤) (_l_30 _List_Œ±))
  (= (_SProd.sprod_29 (_Multiset.ofList_5 _l_29) (_Multiset.ofList _l_30))
     (_Multiset.ofList_16 (_SProd.sprod_30 _l_29 _l_30)))))
  (define-fun valid_fact_5 () Bool
    (forall ((_l_3 _List_Œ±) (_l_4 _List_Œ±___Œ≤))
  (= (_SProd.sprod_3 (_Multiset.ofList _l_3) (_Multiset.ofList_1 _l_4))
     (_Multiset.ofList_3 (_SProd.sprod_4 _l_3 _l_4)))))
  (define-fun valid_fact_32 () Bool
    (forall ((_l_57 _List_Œ±) (_l_58 _List_Œ±))
  (or (not (_Multiset.Nodup (_Multiset.ofList _l_57)))
      (not (_Multiset.Nodup (_Multiset.ofList _l_58)))
      (_List.Nodup_4 (_SProd.sprod_12 _l_57 _l_58)))))
  (define-fun valid_fact_2 () Bool
    (not (_Multiset.Nodup_1 (_SProd.sprod _s _t))))
  (define-fun valid_fact_29 () Bool
    (forall ((_l_51 _List_Œ±___Œ≤) (_l_52 _List_Œ±))
  (or (not (_Multiset.Nodup (_Multiset.ofList _l_52)))
      (_List.Nodup_1 (_SProd.sprod_6 _l_51 _l_52))
      (not (_Multiset.Nodup_1 (_Multiset.ofList_1 _l_51))))))
  (define-fun valid_fact_0 () Bool
    (_Multiset.Nodup _s))
  (define-fun valid_fact_30 () Bool
    (forall ((_l_53 _List_Œ≤) (_l_54 _List_Œ±___Œ≤))
  (or (not (_Multiset.Nodup_0 (_Multiset.ofList_0 _l_53)))
      (not (_Multiset.Nodup_1 (_Multiset.ofList_1 _l_54)))
      (_List.Nodup_2 (_SProd.sprod_10 _l_53 _l_54)))))
  (define-fun valid_fact_8 () Bool
    (forall ((_l_9 _List_Œ≤) (_l_10 _List_Œ±___Œ≤))
  (= (_SProd.sprod_9 (_Multiset.ofList_0 _l_9) (_Multiset.ofList_1 _l_10))
     (_Multiset.ofList_6 (_SProd.sprod_10 _l_9 _l_10)))))
  (define-fun valid_fact_11 () Bool
    (forall ((_l_15 _List_Œ±) (_l_16 _List_Œ±___Œ±___Œ≤))
  (= (_SProd.sprod_15 (_Multiset.ofList _l_15) (_Multiset.ofList_3 _l_16))
     (_Multiset.ofList_9 (_SProd.sprod_16 _l_15 _l_16)))))
  (define-fun valid_fact_16 () Bool
    (forall ((_l_25 _List_Œ±___Œ±___Œ≤) (_l_26 _List_Œ±))
  (= (_SProd.sprod_25 (_Multiset.ofList_3 _l_25) (_Multiset.ofList _l_26))
     (_Multiset.ofList_14 (_SProd.sprod_26 _l_25 _l_26)))))
  (define-fun valid_fact_31 () Bool
    (forall ((_l_55 _List_Œ±___Œ≤) (_l_56 _List_Œ≤))
  (or (not (_Multiset.Nodup_0 (_Multiset.ofList_0 _l_56)))
      (not (_Multiset.Nodup_1 (_Multiset.ofList_1 _l_55)))
      (_List.Nodup_3 (_SProd.sprod_8 _l_55 _l_56)))))
  (define-fun valid_fact_21 () Bool
    (forall ((_l_35 _List_Œ±___Œ≤___Œ±_0) (_l_36 _List_Œ±))
  (= (_SProd.sprod_35 (_Multiset.ofList_8 _l_35) (_Multiset.ofList _l_36))
     (_Multiset.ofList_19 (_SProd.sprod_36 _l_35 _l_36)))))
  (define-fun _t () _Multiset_Œ≤
    |_Multiset_Œ≤!val!0|)
  (define-fun valid_fact_27 () Bool
    (forall ((_l_47 _List_Œ≤) (_l_48 _List_Œ±))
  (or (_List.Nodup (_SProd.sprod_2 _l_47 _l_48))
      (not (_Multiset.Nodup (_Multiset.ofList _l_48)))
      (not (_Multiset.Nodup_0 (_Multiset.ofList_0 _l_47))))))
  (define-fun valid_fact_14 () Bool
    (forall ((_l_21 _List_Œ±) (_l_22 _List_Œ≤___Œ±___Œ≤))
  (= (_SProd.sprod_21 (_Multiset.ofList _l_21) (_Multiset.ofList_6 _l_22))
     (_Multiset.ofList_12 (_SProd.sprod_22 _l_21 _l_22)))))
  (define-fun valid_fact_13 () Bool
    (forall ((_l_19 _List_Œ±) (_l_20 _List_Œ±___Œ≤___Œ≤))
  (= (_SProd.sprod_19 (_Multiset.ofList _l_19) (_Multiset.ofList_5 _l_20))
     (_Multiset.ofList_11 (_SProd.sprod_20 _l_19 _l_20)))))
  (define-fun valid_fact_26 () Bool
    (forall ((_l_45 _List_Œ±) (_l_46 _List_Œ≤))
  (or (_Multiset.Nodup_1 (_Multiset.ofList_1 (_SProd.sprod_0 _l_45 _l_46)))
      (not (_Multiset.Nodup_0 (_Multiset.ofList_0 _l_46)))
      (not (_Multiset.Nodup (_Multiset.ofList _l_45))))))
  (define-fun valid_fact_12 () Bool
    (forall ((_l_17 _List_Œ±) (_l_18 _List_Œ±___Œ≤___Œ±))
  (= (_SProd.sprod_17 (_Multiset.ofList _l_17) (_Multiset.ofList_4 _l_18))
     (_Multiset.ofList_10 (_SProd.sprod_18 _l_17 _l_18)))))
  (define-fun valid_fact_4 () Bool
    (forall ((_l_1 _List_Œ≤) (_l_2 _List_Œ±))
  (= (_SProd.sprod_1 (_Multiset.ofList_0 _l_1) (_Multiset.ofList _l_2))
     (_Multiset.ofList_2 (_SProd.sprod_2 _l_1 _l_2)))))
  (define-fun valid_fact_6 () Bool
    (forall ((_l_5 _List_Œ±___Œ≤) (_l_6 _List_Œ±))
  (= (_SProd.sprod_5 (_Multiset.ofList_1 _l_5) (_Multiset.ofList _l_6))
     (_Multiset.ofList_4 (_SProd.sprod_6 _l_5 _l_6)))))
  (define-fun valid_fact_9 () Bool
    (forall ((_l_11 _List_Œ±) (_l_12 _List_Œ±))
  (= (_SProd.sprod_11 (_Multiset.ofList _l_11) (_Multiset.ofList _l_12))
     (_Multiset.ofList_7 (_SProd.sprod_12 _l_11 _l_12)))))
  (define-fun valid_fact_22 () Bool
    (forall ((_l_37 _List_Œ±___Œ±___Œ±___Œ≤) (_l_38 _List_Œ±))
  (= (_SProd.sprod_37 (_Multiset.ofList_9 _l_37) (_Multiset.ofList _l_38))
     (_Multiset.ofList_20 (_SProd.sprod_38 _l_37 _l_38)))))
  (define-fun valid_fact_7 () Bool
    (forall ((_l_7 _List_Œ±___Œ≤) (_l_8 _List_Œ≤))
  (= (_SProd.sprod_7 (_Multiset.ofList_1 _l_7) (_Multiset.ofList_0 _l_8))
     (_Multiset.ofList_5 (_SProd.sprod_8 _l_7 _l_8)))))
  (define-fun valid_fact_37 () Bool
    (forall ((_l_67 _List_Œ±) (_l_68 _List_Œ±___Œ≤___Œ≤))
  (or (not (_Multiset.Nodup (_Multiset.ofList _l_67)))
      (_List.Nodup_9 (_SProd.sprod_20 _l_67 _l_68))
      (not (_List.Nodup_3 _l_68)))))
  (define-fun valid_fact_28 () Bool
    (forall ((_l_49 _List_Œ±) (_l_50 _List_Œ±___Œ≤))
  (or (not (_Multiset.Nodup (_Multiset.ofList _l_49)))
      (_List.Nodup_0 (_SProd.sprod_4 _l_49 _l_50))
      (not (_Multiset.Nodup_1 (_Multiset.ofList_1 _l_50))))))
  (define-fun valid_fact_23 () Bool
    (forall ((_l_39 _List_Œ±___Œ±___Œ≤___Œ±) (_l_40 _List_Œ±))
  (= (_SProd.sprod_39 (_Multiset.ofList_10 _l_39) (_Multiset.ofList _l_40))
     (_Multiset.ofList_21 (_SProd.sprod_40 _l_39 _l_40)))))
  (define-fun valid_fact_20 () Bool
    (forall ((_l_33 _List_Œ±___Œ±) (_l_34 _List_Œ±))
  (= (_SProd.sprod_33 (_Multiset.ofList_7 _l_33) (_Multiset.ofList _l_34))
     (_Multiset.ofList_18 (_SProd.sprod_34 _l_33 _l_34)))))
  (define-fun _s () _Multiset_Œ±
    |_Multiset_Œ±!val!0|)
  (define-fun valid_fact_17 () Bool
    (forall ((_l_27 _List_Œ±___Œ≤___Œ±) (_l_28 _List_Œ±))
  (= (_SProd.sprod_27 (_Multiset.ofList_4 _l_27) (_Multiset.ofList _l_28))
     (_Multiset.ofList_15 (_SProd.sprod_28 _l_27 _l_28)))))
  (define-fun valid_fact_10 () Bool
    (forall ((_l_13 _List_Œ±) (_l_14 _List_Œ≤___Œ±))
  (= (_SProd.sprod_13 (_Multiset.ofList _l_13) (_Multiset.ofList_2 _l_14))
     (_Multiset.ofList_8 (_SProd.sprod_14 _l_13 _l_14)))))
  (define-fun valid_fact_3 () Bool
    (forall ((_l _List_Œ±) (_l_0 _List_Œ≤))
  (= (_SProd.sprod (_Multiset.ofList _l) (_Multiset.ofList_0 _l_0))
     (_Multiset.ofList_1 (_SProd.sprod_0 _l _l_0)))))
  (define-fun valid_fact_34 () Bool
    (forall ((_l_61 _List_Œ±) (_l_62 _List_Œ±___Œ±___Œ≤))
  (or (not (_Multiset.Nodup (_Multiset.ofList _l_61)))
      (_List.Nodup_6 (_SProd.sprod_16 _l_61 _l_62))
      (not (_List.Nodup_0 _l_62)))))
  (define-fun valid_fact_19 () Bool
    (forall ((_l_31 _List_Œ≤___Œ±___Œ≤) (_l_32 _List_Œ±))
  (= (_SProd.sprod_31 (_Multiset.ofList_6 _l_31) (_Multiset.ofList _l_32))
     (_Multiset.ofList_17 (_SProd.sprod_32 _l_31 _l_32)))))
  (define-fun _SProd.sprod_9 ((x!0 _Multiset_Œ≤) (x!1 _Multiset_Œ±___Œ≤)) _Multiset_Œ≤___Œ±___Œ≤
    |_Multiset_Œ≤___Œ±___Œ≤!val!0|)
  (define-fun _Multiset.Nodup_0 ((x!0 _Multiset_Œ≤)) Bool
    true)
  (define-fun _Multiset.ofList_8 ((x!0 _List_Œ±___Œ≤___Œ±_0)) _Multiset_Œ±___Œ≤___Œ±_0
    |_Multiset_Œ±___Œ≤___Œ±_0!val!0|)
  (define-fun _SProd.sprod_0 ((x!0 _List_Œ±) (x!1 _List_Œ≤)) _List_Œ±___Œ≤
    _pl____1)
  (define-fun _SProd.sprod_32 ((x!0 _List_Œ≤___Œ±___Œ≤) (x!1 _List_Œ±)) _List_Œ≤___Œ±___Œ≤___Œ±
    _pl____17)
  (define-fun _List.Nodup_2 ((x!0 _List_Œ≤___Œ±___Œ≤)) Bool
    false)
  (define-fun _SProd.sprod_33 ((x!0 _Multiset_Œ±___Œ±) (x!1 _Multiset_Œ±)) _Multiset_Œ±___Œ±___Œ±
    |_Multiset_Œ±___Œ±___Œ±!val!0|)
  (define-fun _SProd.sprod_35 ((x!0 _Multiset_Œ±___Œ≤___Œ±_0) (x!1 _Multiset_Œ±)) _Multiset_Œ±___Œ≤___Œ±___Œ±_0
    |_Multiset_Œ±___Œ≤___Œ±___Œ±_0!val!0|)
  (define-fun _List.Nodup_8 ((x!0 _List_Œ±___Œ≤___Œ±___Œ≤)) Bool
    false)
  (define-fun _SProd.sprod_5 ((x!0 _Multiset_Œ±___Œ≤) (x!1 _Multiset_Œ±)) _Multiset_Œ±___Œ≤___Œ±
    |_Multiset_Œ±___Œ≤___Œ±!val!0|)
  (define-fun _List.Nodup_7 ((x!0 _List_Œ±___Œ±___Œ≤___Œ±)) Bool
    false)
  (define-fun _SProd.sprod_11 ((x!0 _Multiset_Œ±) (x!1 _Multiset_Œ±)) _Multiset_Œ±___Œ±
    |_Multiset_Œ±___Œ±!val!0|)
  (define-fun _SProd.sprod_7 ((x!0 _Multiset_Œ±___Œ≤) (x!1 _Multiset_Œ≤)) _Multiset_Œ±___Œ≤___Œ≤
    |_Multiset_Œ±___Œ≤___Œ≤!val!0|)
  (define-fun _SProd.sprod_3 ((x!0 _Multiset_Œ±) (x!1 _Multiset_Œ±___Œ≤)) _Multiset_Œ±___Œ±___Œ≤
    |_Multiset_Œ±___Œ±___Œ≤!val!0|)
  (define-fun _SProd.sprod_15 ((x!0 _Multiset_Œ±) (x!1 _Multiset_Œ±___Œ±___Œ≤)) _Multiset_Œ±___Œ±___Œ±___Œ≤
    |_Multiset_Œ±___Œ±___Œ±___Œ≤!val!0|)
  (define-fun _SProd.sprod_29 ((x!0 _Multiset_Œ±___Œ≤___Œ≤) (x!1 _Multiset_Œ±)) _Multiset_Œ±___Œ≤___Œ≤___Œ±
    |_Multiset_Œ±___Œ≤___Œ≤___Œ±!val!0|)
  (define-fun _SProd.sprod_42 ((x!0 _List_Œ±___Œ±___Œ≤___Œ≤) (x!1 _List_Œ±)) _List_Œ±___Œ±___Œ≤___Œ≤___Œ±
    _pl____22)
  (define-fun _SProd.sprod_40 ((x!0 _List_Œ±___Œ±___Œ≤___Œ±) (x!1 _List_Œ±)) _List_Œ±___Œ±___Œ≤___Œ±___Œ±
    _pl____21)
  (define-fun _SProd.sprod_44 ((x!0 _List_Œ±___Œ≤___Œ±___Œ≤) (x!1 _List_Œ±)) _List_Œ±___Œ≤___Œ±___Œ≤___Œ±
    _pl____23)
  (define-fun _Multiset.ofList_19 ((x!0 _List_Œ±___Œ≤___Œ±___Œ±_0)) _Multiset_Œ±___Œ≤___Œ±___Œ±_0
    |_Multiset_Œ±___Œ≤___Œ±___Œ±_0!val!0|)
  (define-fun _SProd.sprod_2 ((x!0 _List_Œ≤) (x!1 _List_Œ±)) _List_Œ≤___Œ±
    _pl____2)
  (define-fun _SProd.sprod_13 ((x!0 _Multiset_Œ±) (x!1 _Multiset_Œ≤___Œ±)) _Multiset_Œ±___Œ≤___Œ±_0
    |_Multiset_Œ±___Œ≤___Œ±_0!val!0|)
  (define-fun _SProd.sprod_25 ((x!0 _Multiset_Œ±___Œ±___Œ≤) (x!1 _Multiset_Œ±)) _Multiset_Œ±___Œ±___Œ≤___Œ±_0
    |_Multiset_Œ±___Œ±___Œ≤___Œ±_0!val!0|)
  (define-fun _SProd.sprod_34 ((x!0 _List_Œ±___Œ±) (x!1 _List_Œ±)) _List_Œ±___Œ±___Œ±
    _pl____18)
  (define-fun _SProd.sprod_37 ((x!0 _Multiset_Œ±___Œ±___Œ±___Œ≤)
   (x!1 _Multiset_Œ±)) _Multiset_Œ±___Œ±___Œ±___Œ≤___Œ±
    |_Multiset_Œ±___Œ±___Œ±___Œ≤___Œ±!val!0|)
  (define-fun _Multiset.ofList_22 ((x!0 _List_Œ±___Œ±___Œ≤___Œ≤___Œ±)) _Multiset_Œ±___Œ±___Œ≤___Œ≤___Œ±
    |_Multiset_Œ±___Œ±___Œ≤___Œ≤___Œ±!val!0|)
  (define-fun _SProd.sprod_17 ((x!0 _Multiset_Œ±) (x!1 _Multiset_Œ±___Œ≤___Œ±)) _Multiset_Œ±___Œ±___Œ≤___Œ±
    |_Multiset_Œ±___Œ±___Œ≤___Œ±!val!0|)
  (define-fun _SProd.sprod_30 ((x!0 _List_Œ±___Œ≤___Œ≤) (x!1 _List_Œ±)) _List_Œ±___Œ≤___Œ≤___Œ±
    _pl____16)
  (define-fun _List.Nodup ((x!0 _List_Œ≤___Œ±)) Bool
    false)
  (define-fun _SProd.sprod_27 ((x!0 _Multiset_Œ±___Œ≤___Œ±) (x!1 _Multiset_Œ±)) _Multiset_Œ±___Œ≤___Œ±___Œ±
    |_Multiset_Œ±___Œ≤___Œ±___Œ±!val!0|)
  (define-fun _SProd.sprod_1 ((x!0 _Multiset_Œ≤) (x!1 _Multiset_Œ±)) _Multiset_Œ≤___Œ±
    |_Multiset_Œ≤___Œ±!val!0|)
  (define-fun _Multiset.ofList_12 ((x!0 _List_Œ±___Œ≤___Œ±___Œ≤)) _Multiset_Œ±___Œ≤___Œ±___Œ≤
    |_Multiset_Œ±___Œ≤___Œ±___Œ≤!val!0|)
  (define-fun _Multiset.ofList_9 ((x!0 _List_Œ±___Œ±___Œ±___Œ≤)) _Multiset_Œ±___Œ±___Œ±___Œ≤
    |_Multiset_Œ±___Œ±___Œ±___Œ≤!val!0|)
  (define-fun _Multiset.ofList_3 ((x!0 _List_Œ±___Œ±___Œ≤)) _Multiset_Œ±___Œ±___Œ≤
    |_Multiset_Œ±___Œ±___Œ≤!val!0|)
  (define-fun _SProd.sprod_28 ((x!0 _List_Œ±___Œ≤___Œ±) (x!1 _List_Œ±)) _List_Œ±___Œ≤___Œ±___Œ±
    _pl____15)
  (define-fun _SProd.sprod_18 ((x!0 _List_Œ±) (x!1 _List_Œ±___Œ≤___Œ±)) _List_Œ±___Œ±___Œ≤___Œ±
    (_List.cons_10 (_Prod.mk_8 |_Œ±!val!0|
                               (_Prod.mk_2 (_Prod.mk |_Œ±!val!0| |_Œ≤!val!0|)
                                           |_Œ±!val!0|))
                   _pl____10))
  (define-fun _SProd.sprod_10 ((x!0 _List_Œ≤) (x!1 _List_Œ±___Œ≤)) _List_Œ≤___Œ±___Œ≤
    (_List.cons_6 (_Prod.mk_4 |_Œ≤!val!0| (_Prod.mk |_Œ±!val!0| |_Œ≤!val!0|))
                  _pl____6))
  (define-fun _Multiset.ofList_7 ((x!0 _List_Œ±___Œ±)) _Multiset_Œ±___Œ±
    |_Multiset_Œ±___Œ±!val!0|)
  (define-fun _SProd.sprod_26 ((x!0 _List_Œ±___Œ±___Œ≤) (x!1 _List_Œ±)) _List_Œ±___Œ±___Œ≤___Œ±_0
    _pl____14)
  (define-fun _SProd.sprod_22 ((x!0 _List_Œ±) (x!1 _List_Œ≤___Œ±___Œ≤)) _List_Œ±___Œ≤___Œ±___Œ≤
    (_List.cons_12 (_Prod.mk_10 |_Œ±!val!0|
                                (_Prod.mk_4 |_Œ≤!val!0|
                                            (_Prod.mk |_Œ±!val!0| |_Œ≤!val!0|)))
                   _pl____12))
  (define-fun _SProd.sprod_8 ((x!0 _List_Œ±___Œ≤) (x!1 _List_Œ≤)) _List_Œ±___Œ≤___Œ≤
    (_List.cons_5 (_Prod.mk_3 (_Prod.mk |_Œ±!val!0| |_Œ≤!val!0|) |_Œ≤!val!0|)
                  _pl____5))
  (define-fun _SProd.sprod_23 ((x!0 _Multiset_Œ≤___Œ±) (x!1 _Multiset_Œ±)) _Multiset_Œ≤___Œ±___Œ±
    |_Multiset_Œ≤___Œ±___Œ±!val!0|)
  (define-fun _Multiset.ofList_23 ((x!0 _List_Œ±___Œ≤___Œ±___Œ≤___Œ±)) _Multiset_Œ±___Œ≤___Œ±___Œ≤___Œ±
    |_Multiset_Œ±___Œ≤___Œ±___Œ≤___Œ±!val!0|)
  (define-fun _SProd.sprod_4 ((x!0 _List_Œ±) (x!1 _List_Œ±___Œ≤)) _List_Œ±___Œ±___Œ≤
    (_List.cons_3 (_Prod.mk_1 |_Œ±!val!0| (_Prod.mk |_Œ±!val!0| |_Œ≤!val!0|))
                  _pl____3))
  (define-fun _List.Nodup_6 ((x!0 _List_Œ±___Œ±___Œ±___Œ≤)) Bool
    false)
  (define-fun _Multiset.ofList_16 ((x!0 _List_Œ±___Œ≤___Œ≤___Œ±)) _Multiset_Œ±___Œ≤___Œ≤___Œ±
    |_Multiset_Œ±___Œ≤___Œ≤___Œ±!val!0|)
  (define-fun _Multiset.Nodup ((x!0 _Multiset_Œ±)) Bool
    (ite (= x!0 |_Multiset_Œ±!val!1|) false
      true))
  (define-fun _SProd.sprod_21 ((x!0 _Multiset_Œ±) (x!1 _Multiset_Œ≤___Œ±___Œ≤)) _Multiset_Œ±___Œ≤___Œ±___Œ≤
    |_Multiset_Œ±___Œ≤___Œ±___Œ≤!val!0|)
  (define-fun _SProd.sprod_36 ((x!0 _List_Œ±___Œ≤___Œ±_0) (x!1 _List_Œ±)) _List_Œ±___Œ≤___Œ±___Œ±_0
    _pl____19)
  (define-fun _SProd.sprod_38 ((x!0 _List_Œ±___Œ±___Œ±___Œ≤) (x!1 _List_Œ±)) _List_Œ±___Œ±___Œ±___Œ≤___Œ±
    _pl____20)
  (define-fun _SProd.sprod_43 ((x!0 _Multiset_Œ±___Œ≤___Œ±___Œ≤)
   (x!1 _Multiset_Œ±)) _Multiset_Œ±___Œ≤___Œ±___Œ≤___Œ±
    |_Multiset_Œ±___Œ≤___Œ±___Œ≤___Œ±!val!0|)
  (define-fun _Multiset.Nodup_1 ((x!0 _Multiset_Œ±___Œ≤)) Bool
    false)
  (define-fun _List.Nodup_5 ((x!0 _List_Œ±___Œ≤___Œ±_0)) Bool
    false)
  (define-fun _Multiset.ofList_20 ((x!0 _List_Œ±___Œ±___Œ±___Œ≤___Œ±)) _Multiset_Œ±___Œ±___Œ±___Œ≤___Œ±
    |_Multiset_Œ±___Œ±___Œ±___Œ≤___Œ±!val!0|)
  (define-fun _Multiset.ofList_14 ((x!0 _List_Œ±___Œ±___Œ≤___Œ±_0)) _Multiset_Œ±___Œ±___Œ≤___Œ±_0
    |_Multiset_Œ±___Œ±___Œ≤___Œ±_0!val!0|)
  (define-fun _Multiset.ofList_15 ((x!0 _List_Œ±___Œ≤___Œ±___Œ±)) _Multiset_Œ±___Œ≤___Œ±___Œ±
    |_Multiset_Œ±___Œ≤___Œ±___Œ±!val!0|)
  (define-fun _List.Nodup_1 ((x!0 _List_Œ±___Œ≤___Œ±)) Bool
    false)
  (define-fun _Multiset.ofList_2 ((x!0 _List_Œ≤___Œ±)) _Multiset_Œ≤___Œ±
    |_Multiset_Œ≤___Œ±!val!0|)
  (define-fun _Multiset.ofList_11 ((x!0 _List_Œ±___Œ±___Œ≤___Œ≤)) _Multiset_Œ±___Œ±___Œ≤___Œ≤
    |_Multiset_Œ±___Œ±___Œ≤___Œ≤!val!0|)
  (define-fun _Multiset.ofList_13 ((x!0 _List_Œ≤___Œ±___Œ±)) _Multiset_Œ≤___Œ±___Œ±
    |_Multiset_Œ≤___Œ±___Œ±!val!0|)
  (define-fun _SProd.sprod_16 ((x!0 _List_Œ±) (x!1 _List_Œ±___Œ±___Œ≤)) _List_Œ±___Œ±___Œ±___Œ≤
    (_List.cons_9 (_Prod.mk_7 |_Œ±!val!0|
                              (_Prod.mk_1 |_Œ±!val!0|
                                          (_Prod.mk |_Œ±!val!0| |_Œ≤!val!0|)))
                  _pl____9))
  (define-fun _List.Nodup_4 ((x!0 _List_Œ±___Œ±)) Bool
    false)
  (define-fun _SProd.sprod_41 ((x!0 _Multiset_Œ±___Œ±___Œ≤___Œ≤)
   (x!1 _Multiset_Œ±)) _Multiset_Œ±___Œ±___Œ≤___Œ≤___Œ±
    |_Multiset_Œ±___Œ±___Œ≤___Œ≤___Œ±!val!0|)
  (define-fun _Multiset.ofList_1 ((x!0 _List_Œ±___Œ≤)) _Multiset_Œ±___Œ≤
    |_Multiset_Œ±___Œ≤!val!1|)
  (define-fun _SProd.sprod_31 ((x!0 _Multiset_Œ≤___Œ±___Œ≤) (x!1 _Multiset_Œ±)) _Multiset_Œ≤___Œ±___Œ≤___Œ±
    |_Multiset_Œ≤___Œ±___Œ≤___Œ±!val!0|)
  (define-fun _Multiset.ofList_5 ((x!0 _List_Œ±___Œ≤___Œ≤)) _Multiset_Œ±___Œ≤___Œ≤
    |_Multiset_Œ±___Œ≤___Œ≤!val!0|)
  (define-fun _SProd.sprod_20 ((x!0 _List_Œ±) (x!1 _List_Œ±___Œ≤___Œ≤)) _List_Œ±___Œ±___Œ≤___Œ≤
    (_List.cons_11 (_Prod.mk_9 |_Œ±!val!0|
                               (_Prod.mk_3 (_Prod.mk |_Œ±!val!0| |_Œ≤!val!0|)
                                           |_Œ≤!val!0|))
                   _pl____11))
  (define-fun _List.Nodup_0 ((x!0 _List_Œ±___Œ±___Œ≤)) Bool
    false)
  (define-fun _SProd.sprod_12 ((x!0 _List_Œ±) (x!1 _List_Œ±)) _List_Œ±___Œ±
    _pl____7)
  (define-fun _Multiset.ofList_21 ((x!0 _List_Œ±___Œ±___Œ≤___Œ±___Œ±)) _Multiset_Œ±___Œ±___Œ≤___Œ±___Œ±
    |_Multiset_Œ±___Œ±___Œ≤___Œ±___Œ±!val!0|)
  (define-fun _Multiset.ofList_4 ((x!0 _List_Œ±___Œ≤___Œ±)) _Multiset_Œ±___Œ≤___Œ±
    |_Multiset_Œ±___Œ≤___Œ±!val!0|)
  (define-fun _List.Nodup_3 ((x!0 _List_Œ±___Œ≤___Œ≤)) Bool
    false)
  (define-fun _Multiset.ofList_10 ((x!0 _List_Œ±___Œ±___Œ≤___Œ±)) _Multiset_Œ±___Œ±___Œ≤___Œ±
    |_Multiset_Œ±___Œ±___Œ≤___Œ±!val!0|)
  (define-fun _Multiset.ofList_18 ((x!0 _List_Œ±___Œ±___Œ±)) _Multiset_Œ±___Œ±___Œ±
    |_Multiset_Œ±___Œ±___Œ±!val!0|)
  (define-fun _SProd.sprod_24 ((x!0 _List_Œ≤___Œ±) (x!1 _List_Œ±)) _List_Œ≤___Œ±___Œ±
    _pl____13)
  (define-fun _SProd.sprod ((x!0 _Multiset_Œ±) (x!1 _Multiset_Œ≤)) _Multiset_Œ±___Œ≤
    (ite (and (= x!0 |_Multiset_Œ±!val!1|) (= x!1 |_Multiset_Œ≤!val!1|))
      |_Multiset_Œ±___Œ≤!val!1|
      |_Multiset_Œ±___Œ≤!val!0|))
  (define-fun _SProd.sprod_39 ((x!0 _Multiset_Œ±___Œ±___Œ≤___Œ±)
   (x!1 _Multiset_Œ±)) _Multiset_Œ±___Œ±___Œ≤___Œ±___Œ±
    |_Multiset_Œ±___Œ±___Œ≤___Œ±___Œ±!val!0|)
  (define-fun _Multiset.ofList ((x!0 _List_Œ±)) _Multiset_Œ±
    |_Multiset_Œ±!val!1|)
  (define-fun _SProd.sprod_19 ((x!0 _Multiset_Œ±) (x!1 _Multiset_Œ±___Œ≤___Œ≤)) _Multiset_Œ±___Œ±___Œ≤___Œ≤
    |_Multiset_Œ±___Œ±___Œ≤___Œ≤!val!0|)
  (define-fun _SProd.sprod_14 ((x!0 _List_Œ±) (x!1 _List_Œ≤___Œ±)) _List_Œ±___Œ≤___Œ±_0
    (_List.cons_8 (_Prod.mk_6 |_Œ±!val!0| (_Prod.mk_0 |_Œ≤!val!0| |_Œ±!val!0|))
                  _pl____8))
  (define-fun _Multiset.ofList_17 ((x!0 _List_Œ≤___Œ±___Œ≤___Œ±)) _Multiset_Œ≤___Œ±___Œ≤___Œ±
    |_Multiset_Œ≤___Œ±___Œ≤___Œ±!val!0|)
  (define-fun _Multiset.ofList_6 ((x!0 _List_Œ≤___Œ±___Œ≤)) _Multiset_Œ≤___Œ±___Œ≤
    |_Multiset_Œ≤___Œ±___Œ≤!val!0|)
  (define-fun _SProd.sprod_6 ((x!0 _List_Œ±___Œ≤) (x!1 _List_Œ±)) _List_Œ±___Œ≤___Œ±
    (_List.cons_4 (_Prod.mk_2 (_Prod.mk |_Œ±!val!1| |_Œ≤!val!0|) |_Œ±!val!0|)
                  _pl____4))
  (define-fun _Multiset.ofList_0 ((x!0 _List_Œ≤)) _Multiset_Œ≤
    |_Multiset_Œ≤!val!1|)
  (define-fun _List.Nodup_9 ((x!0 _List_Œ±___Œ±___Œ≤___Œ≤)) Bool
    false)
)


Testing || Set.toFinset_congr : ‚àÄ {Œ± : Type u_1} {s t : Set Œ±} [inst : Fintype ‚Üës] [inst_1 : Fintype ‚Üët], s = t ‚Üí s.toFinset = t.toFinset
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Finset_Œ±:
  ;;   |_Finset_Œ±!val!1| |_Finset_Œ±!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Finset_Œ±!val!1| () _Finset_Œ±)
  (declare-fun |_Finset_Œ±!val!0| () _Finset_Œ±)
  ;; cardinality constraint:
  (forall ((x _Finset_Œ±)) (or (= x |_Finset_Œ±!val!1|) (= x |_Finset_Œ±!val!0|)))
  ;; -----------
  (define-fun valid_fact_0 () Bool
    (not (= _s.toFinset _t.toFinset)))
  (define-fun _t.toFinset () _Finset_Œ±
    |_Finset_Œ±!val!1|)
  (define-fun _s.toFinset () _Finset_Œ±
    |_Finset_Œ±!val!0|)
)


Testing || List.suffix_iff_eq_append : ‚àÄ {Œ± : Type u_1} {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ <:+ l‚ÇÇ ‚Üî List.take (l‚ÇÇ.length - l‚ÇÅ.length) l‚ÇÇ ++ l‚ÇÅ = l‚ÇÇ
Result.autoException ::
Auto failed to find proof

Elapsed time: 100074 ms
