Config = {maxHeartbeats := 65536, timeout := 10, solverConfig = smt z3, logFile := evalOut.txt}

Testing || AEMeasurable.inf : ∀ {M : Type u_1} [inst : MeasurableSpace M] {α : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α}
  {f g : α → M} [inst_1 : Min M] [inst_2 : MeasurableInf₂ M],
  AEMeasurable f μ → AEMeasurable g μ → AEMeasurable (fun a => f a ⊓ g a) μ
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _MeasureTheory.Measure_α:
  ;;   |_MeasureTheory.Measure_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_MeasureTheory.Measure_α!val!0| () _MeasureTheory.Measure_α)
  ;; cardinality constraint:
  (forall ((x _MeasureTheory.Measure_α)) (= x |_MeasureTheory.Measure_α!val!0|))
  ;; -----------
  (define-fun valid_fact_5 () Bool
    _Measurable_fun_p_=>_p.1___p.2_)
  (define-fun valid_fact_41 () Bool
    (forall ((_m_31 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_31))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__g_x___f_x_|
        _m_31)
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___g_x__g_x___f_x_|
             _m_31)))))
  (define-fun valid_fact_0 () Bool
    |_MeasurableInf₂_M|)
  (define-fun valid_fact_29 () Bool
    (forall ((_m_19 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_19))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__g_x_|
             _m_19))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x__g_x_|
        _m_19))))
  (define-fun valid_fact_17 () Bool
    (forall ((_m_7 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_fun_a_=>_f_a___g_a| _m_7))
      (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__f_x___g_x_|
        _m_7))))
  (define-fun valid_fact_15 () Bool
    (forall ((_m_5 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_5))
      (not (|_@AEMeasurable_α_M_inst.1232_m_fun_a_=>_f_a___g_a| _m_5))
      (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__g_x_|
        _m_5))))
  (define-fun |_μ| () _MeasureTheory.Measure_α
    |_MeasureTheory.Measure_α!val!0|)
  (define-fun valid_fact_59 () Bool
    (forall ((_m_49 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_49))
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___g_x__g_x___f_x_|
             _m_49))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___g_x__g_x___f_x_|
        _m_49))))
  (define-fun valid_fact_28 () Bool
    (forall ((_m_18 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_18))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x_|
             _m_18))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__g_x__f_x_|
        _m_18))))
  (define-fun valid_fact_58 () Bool
    (forall ((_m_48 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_48))
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x__f_x___g_x___f_x_|
             _m_48))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___f_x__f_x___g_x___f_x_|
        _m_48))))
  (define-fun valid_fact_18 () Bool
    (forall ((_m_8 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_8))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x__f_x___f_x_|
        _m_8)
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x_|
             _m_8)))))
  (define-fun valid_fact_43 () Bool
    (forall ((_m_33 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_33))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__f_x___g_x___f_x_|
        _m_33)
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___g_x__f_x___g_x___f_x_|
             _m_33)))))
  (define-fun valid_fact_11 () Bool
    (forall ((_m_1 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_1))
      (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_1))
      (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__g_x_|
        _m_1))))
  (define-fun valid_fact_60 () Bool
    (forall ((_m_50 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_50))
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x___g_x__g_x___f_x_|
             _m_50))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___f_x___g_x__g_x___f_x_|
        _m_50))))
  (define-fun valid_fact_27 () Bool
    (forall ((_m_17 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_17))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x_|
             _m_17))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x__f_x_|
        _m_17))))
  (define-fun valid_fact_39 () Bool
    (forall ((_m_29 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_29))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___f_x___g_x__f_x___f_x_|
        _m_29)
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x___g_x__f_x___f_x_|
             _m_29)))))
  (define-fun valid_fact_54 () Bool
    (forall ((_m_44 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_44))
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x__f_x___f_x_|
             _m_44))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___f_x__f_x___f_x_|
        _m_44))))
  (define-fun valid_fact_20 () Bool
    (forall ((_m_10 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_10))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x__g_x___f_x_|
        _m_10)
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__g_x_|
             _m_10)))))
  (define-fun valid_fact_48 () Bool
    (forall ((_m_38 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_38))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__f_x_|
             _m_38))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x___g_x__f_x_|
        _m_38))))
  (define-fun valid_fact_63 () Bool
    (forall ((_m_53 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_53))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x__f_x__f_x_|
        _m_53)
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x__f_x_|
             _m_53)))))
  (define-fun valid_fact_4 () Bool
    _Measurable_fun_p_=>_p.1___p.2_)
  (define-fun valid_fact_6 () Bool
    _Measurable_fun_p_=>_p.1___p.2_)
  (define-fun valid_fact_62 () Bool
    (forall ((_m_52 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_52))
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x___g_x__f_x___g_x___f_x_|
             _m_52))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___f_x___g_x__f_x___g_x___f_x_|
        _m_52))))
  (define-fun valid_fact_49 () Bool
    (forall ((_m_39 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_39))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x___g_x_|
             _m_39))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x__f_x___g_x_|
        _m_39))))
  (define-fun valid_fact_34 () Bool
    (forall ((_m_24 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_24))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x___g_x_|
             _m_24))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__g_x__f_x___g_x_|
        _m_24))))
  (define-fun _Measurable_fun_p_=>_p.1___p.2_ () Bool
    true)
  (define-fun valid_fact_25 () Bool
    (forall ((_m_15 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_15))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___g_x__f_x___g_x___f_x_|
        _m_15)
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x___g_x_|
             _m_15)))))
  (define-fun valid_fact_1 () Bool
    (|_@AEMeasurable_α_M_inst.1232_m_f| |_μ|))
  (define-fun valid_fact_46 () Bool
    (forall ((_m_36 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_36))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x_|
             _m_36))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__g_x__f_x_|
        _m_36))))
  (define-fun valid_fact_33 () Bool
    (forall ((_m_23 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_23))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__g_x_|
             _m_23))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x___g_x__g_x_|
        _m_23))))
  (define-fun valid_fact_38 () Bool
    (forall ((_m_28 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_28))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___f_x__g_x___f_x_|
        _m_28)
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x__g_x___f_x_|
             _m_28)))))
  (define-fun valid_fact_50 () Bool
    (forall ((_m_40 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_40))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__g_x_|
             _m_40))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__g_x__g_x_|
        _m_40))))
  (define-fun valid_fact_9 () Bool
    (forall ((_m _MeasureTheory.Measure_α))
  (or (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x_|
        _m)
      (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m)))))
  (define-fun valid_fact_14 () Bool
    (forall ((_m_4 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_4))
      (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__g_x_|
        _m_4))))
  (define-fun valid_fact_7 () Bool
    _Measurable_fun_p_=>_p.1___p.2_)
  (define-fun valid_fact_57 () Bool
    (forall ((_m_47 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_47))
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x___g_x__f_x___f_x_|
             _m_47))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___f_x___g_x__f_x___f_x_|
        _m_47))))
  (define-fun valid_fact_2 () Bool
    (|_@AEMeasurable_α_M_inst.1232_m_g| |_μ|))
  (define-fun valid_fact_56 () Bool
    (forall ((_m_46 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_46))
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x__g_x___f_x_|
             _m_46))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___f_x__g_x___f_x_|
        _m_46))))
  (define-fun valid_fact_55 () Bool
    (forall ((_m_45 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_45))
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___g_x__f_x___f_x_|
             _m_45))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___g_x__f_x___f_x_|
        _m_45))))
  (define-fun valid_fact_53 () Bool
    (forall ((_m_43 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_43))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__f_x___g_x_|
             _m_43))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x___g_x__f_x___g_x_|
        _m_43))))
  (define-fun valid_fact_10 () Bool
    (forall ((_m_0 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_0))
      (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x_|
        _m_0)
      (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_0)))))
  (define-fun valid_fact_30 () Bool
    (forall ((_m_20 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_20))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__f_x_|
             _m_20))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x___g_x__f_x_|
        _m_20))))
  (define-fun valid_fact_52 () Bool
    (forall ((_m_42 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_42))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x___g_x_|
             _m_42))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__g_x__f_x___g_x_|
        _m_42))))
  (define-fun valid_fact_45 () Bool
    (forall ((_m_35 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_35))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x_|
             _m_35))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x__f_x_|
        _m_35))))
  (define-fun valid_fact_19 () Bool
    (forall ((_m_9 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_9))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___g_x__f_x___f_x_|
        _m_9)
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x_|
             _m_9)))))
  (define-fun valid_fact_3 () Bool
    (not (|_@AEMeasurable_α_M_inst.1232_m_fun_a_=>_f_a___g_a| |_μ|)))
  (define-fun valid_fact_8 () Bool
    _Measurable_fun_p_=>_p.1___p.2_)
  (define-fun valid_fact_47 () Bool
    (forall ((_m_37 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_37))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__g_x_|
             _m_37))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x__g_x_|
        _m_37))))
  (define-fun valid_fact_16 () Bool
    (forall ((_m_6 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_6))
      (not (|_@AEMeasurable_α_M_inst.1232_m_fun_a_=>_f_a___g_a| _m_6))
      (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x___g_x_|
        _m_6))))
  (define-fun valid_fact_42 () Bool
    (forall ((_m_32 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_32))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___f_x___g_x__g_x___f_x_|
        _m_32)
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x___g_x__g_x___f_x_|
             _m_32)))))
  (define-fun valid_fact_51 () Bool
    (forall ((_m_41 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_41))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__g_x_|
             _m_41))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x___g_x__g_x_|
        _m_41))))
  (define-fun valid_fact_61 () Bool
    (forall ((_m_51 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_g| _m_51))
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___g_x__f_x___g_x___f_x_|
             _m_51))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___g_x__f_x___g_x___f_x_|
        _m_51))))
  (define-fun valid_fact_35 () Bool
    (forall ((_m_25 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_25))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__f_x___g_x_|
             _m_25))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x___g_x__f_x___g_x_|
        _m_25))))
  (define-fun |_MeasurableInf₂_M| () Bool
    true)
  (define-fun valid_fact_44 () Bool
    (forall ((_m_34 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_34))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___f_x___g_x__f_x___g_x___f_x_|
        _m_34)
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x___g_x__f_x___g_x___f_x_|
             _m_34)))))
  (define-fun valid_fact_31 () Bool
    (forall ((_m_21 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_21))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x___g_x_|
             _m_21))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x__f_x___g_x_|
        _m_21))))
  (define-fun valid_fact_40 () Bool
    (forall ((_m_30 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_30))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___f_x__f_x___g_x___f_x_|
        _m_30)
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x__f_x___g_x___f_x_|
             _m_30)))))
  (define-fun valid_fact_37 () Bool
    (forall ((_m_27 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_27))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__f_x___f_x_|
        _m_27)
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___g_x__f_x___f_x_|
             _m_27)))))
  (define-fun valid_fact_13 () Bool
    (forall ((_m_3 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_3))
      (not (|_@AEMeasurable_α_M_inst.1232_m_fun_a_=>_f_a___g_a| _m_3))
      (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x___g_x_|
        _m_3))))
  (define-fun valid_fact_22 () Bool
    (forall ((_m_12 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_12))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x__f_x___g_x___f_x_|
        _m_12)
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x___g_x_|
             _m_12)))))
  (define-fun valid_fact_24 () Bool
    (forall ((_m_14 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_14))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x___g_x__g_x___f_x_|
        _m_14)
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__g_x_|
             _m_14)))))
  (define-fun valid_fact_12 () Bool
    (forall ((_m_2 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_2))
      (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__f_x_|
        _m_2)
      (not (|_@AEMeasurable_α_M_inst.1232_m_fun_a_=>_f_a___g_a| _m_2)))))
  (define-fun valid_fact_26 () Bool
    (forall ((_m_16 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_16))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x___g_x__f_x___g_x___f_x_|
        _m_16)
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__f_x___g_x_|
             _m_16)))))
  (define-fun valid_fact_23 () Bool
    (forall ((_m_13 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_13))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___g_x__g_x___f_x_|
        _m_13)
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__g_x_|
             _m_13)))))
  (define-fun valid_fact_32 () Bool
    (forall ((_m_22 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_22))
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__g_x_|
             _m_22))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__g_x__g_x_|
        _m_22))))
  (define-fun valid_fact_21 () Bool
    (forall ((_m_11 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_11))
      (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x___g_x__f_x___f_x_|
        _m_11)
      (not (|_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__f_x_|
             _m_11)))))
  (define-fun valid_fact_36 () Bool
    (forall ((_m_26 _MeasureTheory.Measure_α))
  (or (not (|_@AEMeasurable_α_M_inst.1232_m_f| _m_26))
      (|_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___f_x__f_x___f_x_|
        _m_26)
      (not (|_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x__f_x___f_x_|
             _m_26)))))
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x___g_x__f_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___g_x__f_x___g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___f_x___g_x__f_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x__f_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x___g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___f_x__f_x___g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___f_x___g_x__f_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x__f_x___g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___f_x__f_x___g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__f_x___g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x___g_x__g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M_inst.1232_m_fun_a_=>_f_a___g_a| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__g_x__f_x___g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x___g_x__g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___g_x__g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x___g_x__f_x___g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___f_x__f_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x___g_x__f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___g_x__g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x__f_x___g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x___g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___f_x__g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___f_x__g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__g_x__f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__g_x__g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___g_x__f_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x___g_x__f_x___g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__g_x__g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x__f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___f_x___g_x__f_x___g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___g_x__f_x___g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___f_x___g_x__f_x___g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x__f_x___g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x___g_x__g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M_inst.1232_m_f| ((x!0 _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M_inst.1232_m_g| ((x!0 _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___f_x___g_x__g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x__g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x__g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x___f_x___g_x__g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___f_x__g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>___g_x__f_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x___g_x__f_x___g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x__f_x__f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__f_x___g_x__f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__g_x__g_x__f_x___g_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__f_x__f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__f_x___g_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    false)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___g_x__f_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x___f_x__f_x___f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
  (define-fun |_@AEMeasurable_α_M___M___M_Prod.instMeasurableSpace_m_fun_x_=>__f_x__g_x__f_x_| ((x!0
    _MeasureTheory.Measure_α)) Bool
    true)
)


Testing || Std.HashSet.getD_insert : ∀ {α : Type u} {x : BEq α} {x_1 : Hashable α} {m : Std.HashSet α} [inst : EquivBEq α] [inst : LawfulHashable α]
  {k a fallback : α}, (m.insert k).getD a fallback = if (k == a) = true ∧ k ∉ m then k else m.getD a fallback
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Std.DHashMap.insertIfNew.proof_1
  m✝¹`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || LinOrd.Iso.mk_inv : ∀ {α β : LinOrd} (e : ↑α ≃o ↑β), (LinOrd.Iso.mk e).inv = ↑e.symm
Result.success

Testing || List.sublistsLen_length : ∀ {α : Type u} (l : List α), List.sublistsLen l.length l = [l]
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `List.map (cifvar_9 x_1)
  (cifvar_2 x_0 x_2)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || GenContFract.zeroth_contAux_eq_one_zero : ∀ {K : Type u_1} {g : GenContFract K} [inst : DivisionRing K], g.contsAux 0 = { a := 1, b := 0 }
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Stream' (GenContFract.Pair K) is not a `∀`

Testing || Rat.cast_sub_of_ne_zero : ∀ {α : Type u_3} [inst : DivisionRing α] {p q : ℚ}, ↑p.den ≠ 0 → ↑q.den ≠ 0 → ↑(p - q) = ↑p - ↑q
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `a.den_nz`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || _private.Mathlib.Combinatorics.SimpleGraph.Triangle.Counting.0.SimpleGraph.edgeDensity_badVertices_le : ∀ {α : Type u_1} (G : SimpleGraph α) [inst : DecidableRel G.Adj] {ε : ℝ} {s t : Finset α},
  0 ≤ ε → 2 * ε ≤ ↑(G.edgeDensity s t) → ↑(G.edgeDensity (SimpleGraph.badVertices G ε s t) t) ≤ ↑(G.edgeDensity s t) - ε
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `AddGroup.toSubtractionMonoid`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || _private.Mathlib.Combinatorics.Additive.SmallTripling.0.Finset.small_pos_neg_pos_add : ∀ {G : Type u_1} [inst : DecidableEq G] [inst_1 : AddGroup G] {A : Finset G} {K : ℝ},
  ↑(3 • A).card ≤ K * ↑A.card → ↑(A + -A + A).card ≤ K ^ 3 * ↑A.card
Result.autoException ::
Auto failed to find proof

Testing || AddMonoid.exponent_pi_eq_zero : ∀ {ι : Type u_1} {M : ι → Type u_2} [inst : (i : ι) → AddMonoid (M i)] {j : ι},
  AddMonoid.exponent (M j) = 0 → AddMonoid.exponent ((i : ι) → M i) = 0
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `n • g`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || isLUB_sSup : ∀ {α : Type u_1} [inst : CompleteSemilatticeSup α] (s : Set α), IsLUB s (sSup s)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Set_α:
  ;;   |_Set_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_α!val!0| () _Set_α)
  ;; cardinality constraint:
  (forall ((x _Set_α)) (= x |_Set_α!val!0|))
  ;; -----------
  ;; universe for _α:
  ;;   |_α!val!1| |_α!val!4| |_α!val!2| |_α!val!3| |_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!1| () _α)
  (declare-fun |_α!val!4| () _α)
  (declare-fun |_α!val!2| () _α)
  (declare-fun |_α!val!3| () _α)
  (declare-fun |_α!val!0| () _α)
  ;; cardinality constraint:
  (forall ((x _α))
          (or (= x |_α!val!1|)
              (= x |_α!val!4|)
              (= x |_α!val!2|)
              (= x |_α!val!3|)
              (= x |_α!val!0|)))
  ;; -----------
  (define-fun valid_fact_1 () Bool
    (forall ((_s_0 _Set_α) (|_α_0| _α))
  (or (not (_Membership.mem _s_0 |_α_0|)) (_LE.le |_α_0| (_sSup _s_0)))))
  (define-fun valid_fact_3 () Bool
    (forall ((_s_2 _Set_α) (|_α_2| _α))
  (let ((a!1 (forall ((|_α_3| _α))
               (or (not (_Membership.mem _s_2 |_α_3|))
                   (_LE.le |_α_3| |_α_2|)))))
    (or (not a!1) (_LE.le (_sSup _s_2) |_α_2|)))))
  (define-fun valid_fact_4 () Bool
    (forall ((_s_3 _Set_α) (|_α_4| _α))
  (let ((a!1 (forall ((|_α_5| _α))
               (or (not (_Membership.mem _s_3 |_α_5|))
                   (_LE.le |_α_5| |_α_4|)))))
    (or (not a!1) (_LE.le (_sSup _s_3) |_α_4|)))))
  (define-fun valid_fact_2 () Bool
    (forall ((_s_1 _Set_α) (|_α_1| _α))
  (or (not (_Membership.mem _s_1 |_α_1|)) (_LE.le |_α_1| (_sSup _s_1)))))
  (define-fun valid_fact_5 () Bool
    (forall ((_s_4 _Set_α) (|_α_6| _α))
  (let ((a!1 (forall ((|_α_7| _α))
               (or (not (_Membership.mem _s_4 |_α_7|))
                   (_LE.le |_α_7| |_α_6|)))))
    (or (not a!1) (_LE.le (_sSup _s_4) |_α_6|)))))
  (define-fun valid_fact_0 () Bool
    (not (_IsLUB _s (_sSup _s))))
  (define-fun _s () _Set_α
    |_Set_α!val!0|)
  (define-fun _IsLUB ((x!0 _Set_α) (x!1 _α)) Bool
    false)
  (define-fun _sSup ((x!0 _Set_α)) _α
    |_α!val!0|)
  (define-fun _LE.le ((x!0 _α) (x!1 _α)) Bool
    (or (and (= x!0 |_α!val!3|) (= x!1 |_α!val!0|))
        (and (= x!0 |_α!val!2|) (not (= x!0 |_α!val!3|)) (= x!1 |_α!val!0|))
        (and (not (= x!0 |_α!val!2|))
             (not (= x!0 |_α!val!3|))
             (= x!1 |_α!val!0|))))
  (define-fun _Membership.mem ((x!0 _Set_α) (x!1 _α)) Bool
    (or (= x!1 |_α!val!3|)
        (and (not (= x!1 |_α!val!2|)) (not (= x!1 |_α!val!3|)))
        (and (= x!1 |_α!val!2|) (not (= x!1 |_α!val!3|)))))
)


Testing || Algebra.coe_sInf : ∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A]
  (S : Set (Subalgebra R A)), ↑(sInf S) = ⋂ s ∈ S, ↑s
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a ∈ x_0 of λ binder contains bound variables

Testing || Set.image_mul_left_Ioo : ∀ {α : Type u_1} [inst : LinearOrderedField α] {a : α},
  0 < a → ∀ (b c : α), (fun x => a * x) '' Set.Ioo b c = Set.Ioo (a * b) (a * c)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(fun x => cifvar_9 x x_2) ''
  cifvar_6 x_0 x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || FirstOrder.Language.ElementaryEmbedding.map_rel : ∀ {L : FirstOrder.Language} {M : Type u_1} {N : Type u_2} [inst : L.Structure M] [inst_1 : L.Structure N]
  (φ : L.ElementaryEmbedding M N) {n : ℕ} (r : L.Relations n) (x : Fin n → M),
  FirstOrder.Language.Structure.RelMap r (⇑φ ∘ x) ↔ FirstOrder.Language.Structure.RelMap r x
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_13 x_0 ∘ cifvar_14`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || hnot_le_iff_codisjoint_left : ∀ {α : Type u_2} [inst : CoheytingAlgebra α] {a b : α}, ￢a ≤ b ↔ Codisjoint b a
Result.success

Testing || SemistandardYoungTableau.copy_eq : ∀ {μ : YoungDiagram} (T : SemistandardYoungTableau μ) (entry' : ℕ → ℕ → ℕ) (h : entry' = ⇑T), T.copy entry' h = T
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_8 x_0 = cifvar_8 x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux_map' : ∀ {C : Type u_1} {D : Type u_2} [inst : CategoryTheory.Category.{u_4, u_1} C]
  [inst_1 : CategoryTheory.Category.{u_3, u_2} D] {G : CategoryTheory.Functor C D} {A : Type w}
  [inst_2 : CategoryTheory.Category.{w', w} A] {J : CategoryTheory.GrothendieckTopology C}
  {K : CategoryTheory.GrothendieckTopology D} [inst_3 : G.IsCocontinuous J K] {F : CategoryTheory.Functor Cᵒᵖ A}
  (hF : CategoryTheory.Presheaf.IsSheaf J F) {R : CategoryTheory.Functor Dᵒᵖ A} (α : G.op.comp R ⟶ F) {X : D}
  {S : K.Cover X} (s : CategoryTheory.Limits.Multifork (S.index R)) {Y Y' : C} (f : G.obj Y ⟶ X) (f' : G.obj Y' ⟶ X)
  {W : C} (a : W ⟶ Y) (b : W ⟶ Y'),
  CategoryTheory.CategoryStruct.comp (G.map a) f = CategoryTheory.CategoryStruct.comp (G.map b) f' →
    CategoryTheory.CategoryStruct.comp (CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux hF α s f) (F.map a.op) =
      CategoryTheory.CategoryStruct.comp (CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux hF α s f') (F.map b.op)
Result.autoException ::
Auto failed to find proof

Testing || AlgebraicGeometry.Spec.toSheafedSpace_obj : ∀ (R : CommRingCatᵒᵖ),
  AlgebraicGeometry.Spec.toSheafedSpace.obj R = AlgebraicGeometry.Spec.sheafedSpaceObj (Opposite.unop R)
Result.success

Testing || Set.image_preimage : ∀ {α : Type u_1} {β : Type u_2} {f : α → β}, GaloisConnection (Set.image f) (Set.preimage f)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Set_β:
  ;;   |_Set_β!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_β!val!0| () _Set_β)
  ;; cardinality constraint:
  (forall ((x _Set_β)) (= x |_Set_β!val!0|))
  ;; -----------
  ;; universe for _Set_α:
  ;;   |_Set_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_α!val!0| () _Set_α)
  ;; cardinality constraint:
  (forall ((x _Set_α)) (= x |_Set_α!val!0|))
  ;; -----------
  (define-fun valid_fact_0 () Bool
    (not _GaloisConnection_Set.image_f_Set.preimage_f))
  (define-fun valid_fact_1 () Bool
    (forall ((_s _Set_α) (_s_0 _Set_β))
  (= (_Subset (_Set.image_f _s) _s_0) (_Subset_0 _s (_Set.preimage_f _s_0)))))
  (define-fun _GaloisConnection_Set.image_f_Set.preimage_f () Bool
    false)
  (define-fun _Set.image_f ((x!0 _Set_α)) _Set_β
    |_Set_β!val!0|)
  (define-fun _Set.preimage_f ((x!0 _Set_β)) _Set_α
    |_Set_α!val!0|)
  (define-fun _Subset_0 ((x!0 _Set_α) (x!1 _Set_α)) Bool
    false)
  (define-fun _Subset ((x!0 _Set_β) (x!1 _Set_β)) Bool
    false)
)


Testing || deriv_sinh : ∀ {f : ℝ → ℝ} {x : ℝ}, DifferentiableAt ℝ f x → deriv (fun x => Real.sinh (f x)) x = Real.cosh (f x) * deriv f x
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || WCovBy.le_of_lt : ∀ {α : Type u_1} [inst : LinearOrder α] {a b c : α}, a ⩿ b → c < b → c ≤ a
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _α:
  ;;   |_α!val!0| |_α!val!1| |_α!val!2| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!0| () _α)
  (declare-fun |_α!val!1| () _α)
  (declare-fun |_α!val!2| () _α)
  ;; cardinality constraint:
  (forall ((x _α)) (or (= x |_α!val!0|) (= x |_α!val!1|) (= x |_α!val!2|)))
  ;; -----------
  (define-fun valid_fact_3 () Bool
    true)
  (define-fun valid_fact_2 () Bool
    (_LT.lt _a _c))
  (define-fun _b () _α
    |_α!val!1|)
  (define-fun valid_fact_4 () Bool
    true)
  (define-fun valid_fact_1 () Bool
    (_LT.lt _c _b))
  (define-fun _c () _α
    |_α!val!2|)
  (define-fun _a () _α
    |_α!val!0|)
  (define-fun valid_fact_0 () Bool
    (_WCovBy _a _b))
  (define-fun _LT.lt ((x!0 _α) (x!1 _α)) Bool
    true)
  (define-fun _WCovBy ((x!0 _α) (x!1 _α)) Bool
    true)
)


Testing || Bool.not_eq_not : ∀ {a b : Bool}, ¬a = !b ↔ a = b
Result.success

Testing || CategoryTheory.Limits.coneOfSectionCompYoneda_pt : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] {J : Type w} [inst_1 : CategoryTheory.Category.{t, w} J]
  (F : CategoryTheory.Functor J Cᵒᵖ) (X : C) (s : ↑(F.comp (CategoryTheory.yoneda.obj X)).sections),
  (CategoryTheory.Limits.coneOfSectionCompYoneda F X s).pt = Opposite.op X
Result.success

Testing || WittVector.wittMul_vars : ∀ (p : ℕ) [hp : Fact (Nat.Prime p)] (n : ℕ), (WittVector.wittMul p n).vars ⊆ Finset.univ ×ˢ Finset.range (n + 1)
Result.success

Testing || Real.borel_eq_generateFrom_Ioi_rat : borel ℝ = MeasurableSpace.generateFrom (⋃ a, {Set.Ioi ↑a})
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type x ∈ x_1 of λ binder contains bound variables

Testing || HomologicalComplex₂.comm_f : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_4, u_1} C] [inst_1 : CategoryTheory.Limits.HasZeroMorphisms C]
  {I₁ : Type u_2} {I₂ : Type u_3} {c₁ : ComplexShape I₁} {c₂ : ComplexShape I₂} {K L : HomologicalComplex₂ C c₁ c₂}
  (f : K ⟶ L) (i₁ i₁' : I₁) (i₂ : I₂),
  CategoryTheory.CategoryStruct.comp ((f.f i₁).f i₂) ((L.d i₁ i₁').f i₂) =
    CategoryTheory.CategoryStruct.comp ((K.d i₁ i₁').f i₂) ((f.f i₁').f i₂)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_0.f x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Asymptotics.IsBigO.comp_tendsto : ∀ {α : Type u_1} {β : Type u_2} {E : Type u_3} {F : Type u_4} [inst : Norm E] [inst_1 : Norm F] {f : α → E} {g : α → F}
  {l : Filter α}, f =O[l] g → ∀ {k : β → α} {l' : Filter β}, Filter.Tendsto k l' l → (f ∘ k) =O[l'] (g ∘ k)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _CauSeq.Completion.Cauchy_abs:
  ;;   _CauSeq.Completion.Cauchy_abs!val!3 _CauSeq.Completion.Cauchy_abs!val!0 _CauSeq.Completion.Cauchy_abs!val!1 _CauSeq.Completion.Cauchy_abs!val!2 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _CauSeq.Completion.Cauchy_abs!val!3 () _CauSeq.Completion.Cauchy_abs)
  (declare-fun _CauSeq.Completion.Cauchy_abs!val!0 () _CauSeq.Completion.Cauchy_abs)
  (declare-fun _CauSeq.Completion.Cauchy_abs!val!1 () _CauSeq.Completion.Cauchy_abs)
  (declare-fun _CauSeq.Completion.Cauchy_abs!val!2 () _CauSeq.Completion.Cauchy_abs)
  ;; cardinality constraint:
  (forall ((x _CauSeq.Completion.Cauchy_abs))
          (or (= x _CauSeq.Completion.Cauchy_abs!val!3)
              (= x _CauSeq.Completion.Cauchy_abs!val!0)
              (= x _CauSeq.Completion.Cauchy_abs!val!1)
              (= x _CauSeq.Completion.Cauchy_abs!val!2)))
  ;; -----------
  ;; universe for _Filter_α:
  ;;   |_Filter_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Filter_α!val!0| () _Filter_α)
  ;; cardinality constraint:
  (forall ((x _Filter_α)) (= x |_Filter_α!val!0|))
  ;; -----------
  ;; universe for _Filter_β:
  ;;   |_Filter_β!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Filter_β!val!0| () _Filter_β)
  ;; cardinality constraint:
  (forall ((x _Filter_β)) (= x |_Filter_β!val!0|))
  ;; -----------
  (define-fun valid_fact_0 () Bool
    (exists ((_pl___0 _pl__))
  (_fun_c_l_=>_Asymptotics.IsBigOWith_l_c_f_g _pl___0 _l)))
  (define-fun valid_fact_3 () Bool
    (forall ((_f _Filter_α))
  (or (not (exists ((_pl___2 _pl__))
             (_fun_c_l_=>_Asymptotics.IsBigOWith_l_c_f_g _pl___2 _f)))
      (exists ((_pl___3 _pl__))
        (_fun_c_l_=>_Asymptotics.IsBigOWith_l_c_f_g _pl___3 _f)))))
  (define-fun valid_fact_4 () Bool
    (forall ((_f_0 _Filter_β))
  (or (not (exists ((_pl___4 _pl__))
             (_fun_c_l_=>_Asymptotics.IsBigOWith_l_c_f___k_g___k _pl___4 _f_0)))
      (exists ((_pl___5 _pl__))
        (_fun_c_l_=>_Asymptotics.IsBigOWith_l_c_f___k_g___k _pl___5 _f_0)))))
  (define-fun valid_fact_2 () Bool
    (not (exists ((_pl___1 _pl__))
       (_fun_c_l_=>_Asymptotics.IsBigOWith_l_c_f___k_g___k _pl___1 _l_))))
  (define-fun valid_fact_1 () Bool
    (_Filter.Tendsto_k _l_ _l))
  (define-fun _l () _Filter_α
    |_Filter_α!val!0|)
  (define-fun _l_ () _Filter_β
    |_Filter_β!val!0|)
  (define-fun valid_fact_6 () Bool
    true)
  (define-fun valid_fact_5 () Bool
    true)
  (define-fun _Filter.Tendsto_k ((x!0 _Filter_β) (x!1 _Filter_α)) Bool
    true)
  (define-fun _fun_c_l_=>_Asymptotics.IsBigOWith_l_c_f___k_g___k ((x!0 _pl__)
   (x!1 _Filter_β)) Bool
    false)
  (define-fun _fun_c_l_=>_Asymptotics.IsBigOWith_l_c_f_g ((x!0 _pl__)
   (x!1 _Filter_α)) Bool
    true)
  (define-fun _g ((x!0 _α)) _F
    _F!val!0)
  (define-fun _f_1 ((x!0 _α)) _E
    _E!val!0)
  (define-fun _k ((x!0 _β_0)) _α
    |_α!val!0|)
)


Testing || Filter.Tendsto.cexp : ∀ {α : Type u_1} {l : Filter α} {f : α → ℂ} {z : ℂ},
  Filter.Tendsto f l (nhds z) → Filter.Tendsto (fun x => Complex.exp (f x)) l (nhds (Complex.exp z))
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || IsLocalizedModule.fromLocalizedModule'_add : ∀ {R : Type u_1} [inst : CommSemiring R] (S : Submonoid R) {M : Type u_2} {M' : Type u_3} [inst_1 : AddCommMonoid M]
  [inst_2 : AddCommMonoid M'] [inst_3 : _root_.Module R M] [inst_4 : _root_.Module R M'] (f : M →ₗ[R] M')
  [inst_5 : IsLocalizedModule S f] (x y : LocalizedModule S M),
  IsLocalizedModule.fromLocalizedModule' S f (x + y) =
    IsLocalizedModule.fromLocalizedModule' S f x + IsLocalizedModule.fromLocalizedModule' S f y
Result.autoException ::
Auto failed to find proof

Testing || AffineSubspace.affineSpan_coe : ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module k V]
  [S : AddTorsor V P] (s : AffineSubspace k P), affineSpan k ↑s = s
Result.autoException ::
Auto failed to find proof

Testing || ENat.mem_nhds_natCast_iff : ∀ (n : ℕ) {s : Set ℕ∞}, s ∈ nhds ↑n ↔ ↑n ∈ s
Result.success

Testing || HasProd.div : ∀ {α : Type u_1} {β : Type u_2} [inst : CommGroup α] [inst_1 : TopologicalSpace α] [inst_2 : TopologicalGroup α]
  {f g : β → α} {a₁ a₂ : α}, HasProd f a₁ → HasProd g a₂ → HasProd (fun b => f b / g b) (a₁ / a₂)
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || IsLocalization.coeSubmodule_fg : ∀ {R : Type u_1} [inst : CommSemiring R] (S : Type u_2) [inst_1 : CommSemiring S] [inst_2 : Algebra R S],
  Function.Injective ⇑(algebraMap R S) → ∀ (I : Ideal R), (IsLocalization.coeSubmodule S I).FG ↔ Submodule.FG I
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Function.Injective
  (cifvar_11 x_0)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.IsPullback.of_right : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {X₁₁ X₁₂ X₁₃ X₂₁ X₂₂ X₂₃ : C} {h₁₁ : X₁₁ ⟶ X₁₂}
  {h₁₂ : X₁₂ ⟶ X₁₃} {h₂₁ : X₂₁ ⟶ X₂₂} {h₂₂ : X₂₂ ⟶ X₂₃} {v₁₁ : X₁₁ ⟶ X₂₁} {v₁₂ : X₁₂ ⟶ X₂₂} {v₁₃ : X₁₃ ⟶ X₂₃},
  CategoryTheory.IsPullback (CategoryTheory.CategoryStruct.comp h₁₁ h₁₂) v₁₁ v₁₃
      (CategoryTheory.CategoryStruct.comp h₂₁ h₂₂) →
    CategoryTheory.CategoryStruct.comp h₁₁ v₁₂ = CategoryTheory.CategoryStruct.comp v₁₁ h₂₁ →
      CategoryTheory.IsPullback h₁₂ v₁₂ v₁₃ h₂₂ → CategoryTheory.IsPullback h₁₁ v₁₁ v₁₂ h₂₁
Result.success

Testing || Nat.nonempty_properDivisors : ∀ {n : ℕ}, n.properDivisors.Nonempty ↔ 1 < n
Result.autoException ::
Auto failed to find proof

Testing || RingEquiv.map_prod : ∀ {α : Type u_1} {R : Type u_2} {S : Type u_3} [inst : CommSemiring R] [inst_1 : CommSemiring S] (g : R ≃+* S)
  (f : α → R) (s : Finset α), g (∏ x ∈ s, f x) = ∏ x ∈ s, g (f x)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `∏ x ∈ x_1,
  cifvar_2 x_0 (cifvar_10 x)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || dist_smul : ∀ {M : Type u} {X : Type w} [inst : PseudoMetricSpace X] [inst_1 : SMul M X] [inst_2 : IsometricSMul M X] (c : M)
  (x y : X), dist (c • x) (c • y) = dist x y
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Isometry fun x => cifvar_4 x_0 x`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || map_mul_right_nhds₀ : ∀ {G₀ : Type u_3} [inst : TopologicalSpace G₀] [inst_1 : GroupWithZero G₀] [inst_2 : ContinuousMul G₀] {a : G₀},
  a ≠ 0 → ∀ (b : G₀), Filter.map (fun x => x * a) (nhds b) = nhds (b * a)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Filter.map (cifvar_11 x_0)
  (cifvar_7 x_1)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Nat.find_le : ∀ {n : ℕ} {p : ℕ → Prop} [inst : DecidablePred p] {h : ∃ n, p n}, p n → Nat.find h ≤ n
Result.autoException ::
Auto failed to find proof

Testing || Finset.subset_mul_left : ∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : MulOneClass α] (s : Finset α) {t : Finset α}, 1 ∈ t → s ⊆ s * t
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `a.decidableEq b`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || IterateAddAct.ext : ∀ {α : Type u_1} {f : α → α} {x y : IterateAddAct f}, x.val = y.val → x = y
Result.success

Testing || Mathlib.Vector.mem_cons_of_mem : ∀ {α : Type u_1} {n : ℕ} (a a' : α) (v : Mathlib.Vector α n), a' ∈ v.toList → a' ∈ (a ::ᵥ v).toList
Result.success

Testing || Measurable.set_lintegral_kernel : ∀ {α : Type u_1} {β : Type u_2} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} {κ : ProbabilityTheory.Kernel α β}
  [inst : ProbabilityTheory.IsSFiniteKernel κ] {f : β → ENNReal},
  Measurable f → ∀ {s : Set β}, MeasurableSet s → Measurable fun a => ∫⁻ (b : β) in s, f b ∂κ a
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Nat.dvd_zero : ∀ (a : ℕ), a ∣ 0
Result.autoException ::
Auto failed to find proof

Testing || Function.Embedding.toEquivRange_symm_apply_self : ∀ {α : Type u_1} {β : Type u_2} [inst : Fintype α] [inst_1 : DecidableEq β] (f : α ↪ β) (a : α),
  f.toEquivRange.symm ⟨f a, ⋯⟩ = a
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _α_____x_//_x___Set.range__f__:
  ;;   |_α_____x_//_x___Set.range__f__!val!1| |_α_____x_//_x___Set.range__f__!val!0| |_α_____x_//_x___Set.range__f__!val!3| |_α_____x_//_x___Set.range__f__!val!2| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α_____x_//_x___Set.range__f__!val!1| () _α_____x_//_x___Set.range__f__)
  (declare-fun |_α_____x_//_x___Set.range__f__!val!0| () _α_____x_//_x___Set.range__f__)
  (declare-fun |_α_____x_//_x___Set.range__f__!val!3| () _α_____x_//_x___Set.range__f__)
  (declare-fun |_α_____x_//_x___Set.range__f__!val!2| () _α_____x_//_x___Set.range__f__)
  ;; cardinality constraint:
  (forall ((x _α_____x_//_x___Set.range__f__))
          (or (= x |_α_____x_//_x___Set.range__f__!val!1|)
              (= x |_α_____x_//_x___Set.range__f__!val!0|)
              (= x |_α_____x_//_x___Set.range__f__!val!3|)
              (= x |_α_____x_//_x___Set.range__f__!val!2|)))
  ;; -----------
  ;; universe for ___x_//_x___Set.range__f_____α:
  ;;   |___x_//_x___Set.range__f_____α!val!0| |___x_//_x___Set.range__f_____α!val!1| |___x_//_x___Set.range__f_____α!val!2| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |___x_//_x___Set.range__f_____α!val!0| () ___x_//_x___Set.range__f_____α)
  (declare-fun |___x_//_x___Set.range__f_____α!val!1| () ___x_//_x___Set.range__f_____α)
  (declare-fun |___x_//_x___Set.range__f_____α!val!2| () ___x_//_x___Set.range__f_____α)
  ;; cardinality constraint:
  (forall ((x ___x_//_x___Set.range__f_____α))
          (or (= x |___x_//_x___Set.range__f_____α!val!0|)
              (= x |___x_//_x___Set.range__f_____α!val!1|)
              (= x |___x_//_x___Set.range__f_____α!val!2|)))
  ;; -----------
  ;; universe for _f_a___Set.range__f:
  ;;   _f_a___Set.range__f!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _f_a___Set.range__f!val!0 () _f_a___Set.range__f)
  ;; cardinality constraint:
  (forall ((x _f_a___Set.range__f)) (= x _f_a___Set.range__f!val!0))
  ;; -----------
  ;; universe for ___x_//_x___Set.range__f__:
  ;;   ___x_//_x___Set.range__f__!val!1 ___x_//_x___Set.range__f__!val!2 ___x_//_x___Set.range__f__!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun ___x_//_x___Set.range__f__!val!1 () ___x_//_x___Set.range__f__)
  (declare-fun ___x_//_x___Set.range__f__!val!2 () ___x_//_x___Set.range__f__)
  (declare-fun ___x_//_x___Set.range__f__!val!0 () ___x_//_x___Set.range__f__)
  ;; cardinality constraint:
  (forall ((x ___x_//_x___Set.range__f__))
          (or (= x ___x_//_x___Set.range__f__!val!1)
              (= x ___x_//_x___Set.range__f__!val!2)
              (= x ___x_//_x___Set.range__f__!val!0)))
  ;; -----------
  ;; universe for _α:
  ;;   |_α!val!0| |_α!val!1| |_α!val!2| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!0| () _α)
  (declare-fun |_α!val!1| () _α)
  (declare-fun |_α!val!2| () _α)
  ;; cardinality constraint:
  (forall ((x _α)) (or (= x |_α!val!0|) (= x |_α!val!1|) (= x |_α!val!2|)))
  ;; -----------
  ;; universe for _α___β:
  ;;   |_α___β!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α___β!val!0| () _α___β)
  ;; cardinality constraint:
  (forall ((x _α___β)) (= x |_α___β!val!0|))
  ;; -----------
  ;; universe for _Set_β:
  ;;   |_Set_β!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_β!val!0| () _Set_β)
  ;; cardinality constraint:
  (forall ((x _Set_β)) (= x |_Set_β!val!0|))
  ;; -----------
  ;; universe for _β:
  ;;   |_β!val!1| |_β!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_β!val!1| () _β)
  (declare-fun |_β!val!0| () _β)
  ;; cardinality constraint:
  (forall ((x _β)) (or (= x |_β!val!1|) (= x |_β!val!0|)))
  ;; -----------
  (define-fun _a () _α
    |_α!val!2|)
  (define-fun valid_fact_5 () Bool
    true)
  (define-fun valid_fact_2 () Bool
    (forall ((|_α_1| _α_____x_//_x___Set.range__f__)
         (_pl__ ___x_//_x___Set.range__f__)
         (|_α_2| _α))
  (= (= (_DFunLike.coe (_Equiv.symm |_α_1|) _pl__) |_α_2|)
     (= _pl__ (_DFunLike.coe_1 |_α_1| |_α_2|)))))
  (define-fun _f () _α___β
    |_α___β!val!0|)
  (define-fun valid_fact_4 () Bool
    true)
  (define-fun valid_fact_1 () Bool
    (forall ((|_α_0| _α))
  (_Membership.mem _Set.range__f (_DFunLike.coe_0 _f |_α_0|))))
  (define-fun valid_fact_3 () Bool
    (forall ((_pl___0 ___x_//_x___Set.range__f_____α)
         (|_α_3| _α)
         (_pl___1 ___x_//_x___Set.range__f__))
  (= (= (_DFunLike.coe_1 (_Equiv.symm_0 _pl___0) |_α_3|) _pl___1)
     (= |_α_3| (_DFunLike.coe _pl___0 _pl___1)))))
  (define-fun _Set.mem_range_self_a () _f_a___Set.range__f
    _f_a___Set.range__f!val!0)
  (define-fun _Set.range__f () _Set_β
    |_Set_β!val!0|)
  (define-fun valid_fact_0 () Bool
    (not (= (_DFunLike.coe (_Equiv.symm _f.toEquivRange)
                       (_Subtype.mk_f_a _Set.mem_range_self_a))
        _a)))
  (define-fun _f.toEquivRange () _α_____x_//_x___Set.range__f__
    |_α_____x_//_x___Set.range__f__!val!0|)
  (define-fun _Equiv.symm ((x!0 _α_____x_//_x___Set.range__f__)) ___x_//_x___Set.range__f_____α
    (ite (and (not (= x!0 |_α_____x_//_x___Set.range__f__!val!3|))
              (not (= x!0 |_α_____x_//_x___Set.range__f__!val!0|))
              (not (= x!0 |_α_____x_//_x___Set.range__f__!val!1|)))
         |___x_//_x___Set.range__f_____α!val!2|
         (ite (= x!0 |_α_____x_//_x___Set.range__f__!val!1|)
              |___x_//_x___Set.range__f_____α!val!1|
              |___x_//_x___Set.range__f_____α!val!0|)))
  (define-fun _DFunLike.coe_0 ((x!0 _α___β) (x!1 _α)) _β
    (ite (= x!0 |_α___β!val!0|) |_β!val!0| |_β!val!1|))
  (define-fun _DFunLike.coe ((x!0 ___x_//_x___Set.range__f_____α)
   (x!1 ___x_//_x___Set.range__f__)) _α
    (let ((a!1 (or (and (= x!0 |___x_//_x___Set.range__f_____α!val!0|)
                        (not (= x!1 ___x_//_x___Set.range__f__!val!2))
                        (not (= x!1 ___x_//_x___Set.range__f__!val!0)))
                   (and (not (= x!0 |___x_//_x___Set.range__f_____α!val!2|))
                        (not (= x!0 |___x_//_x___Set.range__f_____α!val!0|))
                        (not (= x!1 ___x_//_x___Set.range__f__!val!2))
                        (not (= x!1 ___x_//_x___Set.range__f__!val!0))))))
    (let ((a!2 (ite a!1
                    |_α!val!1|
                    (ite (and (= x!0 |___x_//_x___Set.range__f_____α!val!0|)
                              (= x!1 ___x_//_x___Set.range__f__!val!0))
                         |_α!val!0|
                         |_α!val!2|))))
    (let ((a!3 (ite (and (not (= x!0 |___x_//_x___Set.range__f_____α!val!2|))
                         (not (= x!0 |___x_//_x___Set.range__f_____α!val!0|))
                         (= x!1 ___x_//_x___Set.range__f__!val!0))
                    |_α!val!0|
                    a!2)))
    (let ((a!4 (ite (and (= x!0 |___x_//_x___Set.range__f_____α!val!2|)
                         (not (= x!0 |___x_//_x___Set.range__f_____α!val!0|))
                         (not (= x!1 ___x_//_x___Set.range__f__!val!2))
                         (not (= x!1 ___x_//_x___Set.range__f__!val!0)))
                    |_α!val!1|
                    a!3)))
      (ite (and (= x!0 |___x_//_x___Set.range__f_____α!val!2|)
                (not (= x!0 |___x_//_x___Set.range__f_____α!val!0|))
                (= x!1 ___x_//_x___Set.range__f__!val!0))
           |_α!val!0|
           a!4))))))
  (define-fun _Subtype.mk_f_a ((x!0 _f_a___Set.range__f)) ___x_//_x___Set.range__f__
    ___x_//_x___Set.range__f__!val!0)
  (define-fun _DFunLike.coe_1 ((x!0 _α_____x_//_x___Set.range__f__) (x!1 _α)) ___x_//_x___Set.range__f__
    (let ((a!1 (or (and (= x!0 |_α_____x_//_x___Set.range__f__!val!1|)
                        (not (= x!1 |_α!val!1|))
                        (not (= x!1 |_α!val!0|)))
                   (and (= x!0 |_α_____x_//_x___Set.range__f__!val!0|)
                        (not (= x!0 |_α_____x_//_x___Set.range__f__!val!1|))
                        (not (= x!1 |_α!val!1|))
                        (not (= x!1 |_α!val!0|)))
                   (and (= x!0 |_α_____x_//_x___Set.range__f__!val!3|)
                        (not (= x!0 |_α_____x_//_x___Set.range__f__!val!0|))
                        (not (= x!0 |_α_____x_//_x___Set.range__f__!val!1|))
                        (not (= x!1 |_α!val!1|))
                        (not (= x!1 |_α!val!0|)))
                   (and (not (= x!0 |_α_____x_//_x___Set.range__f__!val!3|))
                        (not (= x!0 |_α_____x_//_x___Set.range__f__!val!0|))
                        (not (= x!0 |_α_____x_//_x___Set.range__f__!val!1|))
                        (not (= x!1 |_α!val!1|))
                        (not (= x!1 |_α!val!0|)))))
          (a!2 (or (and (not (= x!0 |_α_____x_//_x___Set.range__f__!val!3|))
                        (not (= x!0 |_α_____x_//_x___Set.range__f__!val!0|))
                        (not (= x!0 |_α_____x_//_x___Set.range__f__!val!1|))
                        (= x!1 |_α!val!0|))
                   (and (= x!0 |_α_____x_//_x___Set.range__f__!val!1|)
                        (= x!1 |_α!val!0|))
                   (and (= x!0 |_α_____x_//_x___Set.range__f__!val!0|)
                        (not (= x!0 |_α_____x_//_x___Set.range__f__!val!1|))
                        (= x!1 |_α!val!0|)))))
      (ite (and (= x!0 |_α_____x_//_x___Set.range__f__!val!3|)
                (not (= x!0 |_α_____x_//_x___Set.range__f__!val!0|))
                (not (= x!0 |_α_____x_//_x___Set.range__f__!val!1|))
                (= x!1 |_α!val!0|))
           ___x_//_x___Set.range__f__!val!0
           (ite a!1
                ___x_//_x___Set.range__f__!val!2
                (ite a!2
                     ___x_//_x___Set.range__f__!val!0
                     ___x_//_x___Set.range__f__!val!1)))))
  (define-fun _Membership.mem ((x!0 _Set_β) (x!1 _β)) Bool
    true)
  (define-fun _Equiv.symm_0 ((x!0 ___x_//_x___Set.range__f_____α)) _α_____x_//_x___Set.range__f__
    (ite (and (not (= x!0 |___x_//_x___Set.range__f_____α!val!2|))
              (not (= x!0 |___x_//_x___Set.range__f_____α!val!0|)))
         |_α_____x_//_x___Set.range__f__!val!2|
         (ite (= x!0 |___x_//_x___Set.range__f_____α!val!0|)
              |_α_____x_//_x___Set.range__f__!val!1|
              |_α_____x_//_x___Set.range__f__!val!3|)))
)


Testing || Matrix.star_dotProduct_star : ∀ {m : Type u_2} {α : Type v} [inst : Fintype m] [inst_1 : NonUnitalSemiring α] [inst_2 : StarRing α] (v w : m → α),
  Matrix.dotProduct (star v) (star w) = star (Matrix.dotProduct w v)
Result.success

Testing || Finset.singleton_infs_singleton : ∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : SemilatticeInf α] {a b : α}, {a} ⊼ {b} = {a ⊓ b}
Result.success

Testing || IsConjRoot.isIntegral : ∀ {R : Type u_1} {A : Type u_5} [inst : CommRing R] [inst_1 : Ring A] [inst_2 : Algebra R A] {x y : A},
  IsIntegral R x → IsConjRoot R x y → IsIntegral R y
Result.autoException ::
Auto failed to find proof

Testing || SimpleGraph.Walk.transfer_transfer : ∀ {V : Type u} {G : SimpleGraph V} {u v : V} (p : G.Walk u v) {H : SimpleGraph V} (hp : ∀ e ∈ p.edges, e ∈ H.edgeSet)
  {K : SimpleGraph V} (hp' : ∀ e ∈ (p.transfer H hp).edges, e ∈ K.edgeSet),
  (p.transfer H hp).transfer K hp' = p.transfer K ⋯
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type (p.transfer H hp).edges =
  x✝ of λ binder contains bound variables

Testing || CategoryTheory.ofTypeMonad_μ_app : ∀ (m : Type u → Type u) [inst : Monad m] [inst_1 : LawfulMonad m] {α : Type u} (a : m (m α)),
  (CategoryTheory.ofTypeMonad m).μ.app α a = joinM a
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: ((CategoryTheory.ofTypeMonad m).comp
        (CategoryTheory.ofTypeMonad m).toFunctor).obj
    α ⟶
  (CategoryTheory.ofTypeMonad m).obj α is not a `∀`

Testing || measure_Ioc_lt_top : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : TopologicalSpace α] [inst_2 : CompactIccSpace α] {m : MeasurableSpace α}
  {μ : MeasureTheory.Measure α} [inst_3 : MeasureTheory.IsLocallyFiniteMeasure μ] {a b : α}, μ (Set.Ioc a b) < ⊤
Result.success

Testing || List.takeDTR_go_eq : ∀ {α : Type u_1} {dflt : α} {acc : Array α} (n : ℕ) (l : List α),
  List.takeDTR.go dflt n l acc = acc.toList ++ List.takeD n l dflt
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_29 as ≤ cifvar_29 as`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Symmetric.iff : ∀ {α : Type u_1} {r : α → α → Prop}, Symmetric r → ∀ (x y : α), r x y ↔ r y x
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _α:
  ;;   |_α!val!0| |_α!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!0| () _α)
  (declare-fun |_α!val!1| () _α)
  ;; cardinality constraint:
  (forall ((x _α)) (or (= x |_α!val!0|) (= x |_α!val!1|)))
  ;; -----------
  (define-fun _Symmetric_r () Bool
    true)
  (define-fun _y () _α
    |_α!val!1|)
  (define-fun valid_fact_0 () Bool
    _Symmetric_r)
  (define-fun valid_fact_1 () Bool
    (= (not (_r _x _y)) (_r _y _x)))
  (define-fun _x () _α
    |_α!val!0|)
  (define-fun _r ((x!0 _α) (x!1 _α)) Bool
    (ite (and (= x!0 |_α!val!1|) (= x!1 |_α!val!0|)) false
      true))
)


Testing || LieModuleEquiv.symm_apply_apply : ∀ {R : Type u} {L : Type v} {M : Type w} {N : Type w₁} [inst : CommRing R] [inst_1 : LieRing L]
  [inst_2 : AddCommGroup M] [inst_3 : AddCommGroup N] [inst_4 : _root_.Module R M] [inst_5 : _root_.Module R N]
  [inst_6 : LieRingModule L M] [inst_7 : LieRingModule L N] (e : M ≃ₗ⁅R,L⁆ N) (x : M), e.symm (e x) = x
Result.autoException ::
Auto failed to find proof

Testing || AffineIndependent.mem_affineSpan_iff : ∀ {k : Type u_1} {V : Type u_2} {P : Type u_3} [inst : Ring k] [inst_1 : AddCommGroup V] [inst_2 : _root_.Module k V]
  [inst_3 : AddTorsor V P] {ι : Type u_4} [inst_4 : Nontrivial k] {p : ι → P},
  AffineIndependent k p → ∀ (i : ι) (s : Set ι), p i ∈ affineSpan k (p '' s) ↔ i ∈ s
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm ((∃ x0 : #2, (!11 (!15 (!5 !6) (λx1 : #2, (∃ x2 : #6, ((!17 (!18 (!5 !6)) x2) ∧ ((!7 !8) = (!19 x2 x1)))))) x0)) = (!3 (!4 (!5 !6)) (!7 !8))) is not type correct

Testing || CategoryTheory.ofTypeMonad_obj : ∀ (m : Type u → Type u) [inst : Monad m] [inst_1 : LawfulMonad m] (a : Type u),
  (CategoryTheory.ofTypeMonad m).obj a = m a
Result.success

Testing || Set.center_eq_univ : ∀ (M : Type u_1) [inst : CommSemigroup M], Set.center M = Set.univ
Result.autoException ::
Auto failed to find proof

Testing || LinearIsometryEquiv.differentiableOn : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {s : Set E}
  (iso : E ≃ₗᵢ[𝕜] F), DifferentiableOn 𝕜 (⇑iso) s
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Differentiable cifvar_5
  (cifvar_8 x_0)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || TwoUniqueSums.of_addHom : ∀ {G : Type u} {H : Type v} [inst : Add G] [inst_1 : Add H] (f : H →ₙ+ G),
  (∀ ⦃a b c d : H⦄, a + b = c + d → f a = f c ∧ f b = f d → a = c ∧ b = d) → ∀ [inst : TwoUniqueSums G], TwoUniqueSums H
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.image (cifvar_3 x_5) x_0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || SimpleGraph.Walk.map_toDeleteEdges_eq : ∀ {V : Type u} {G : SimpleGraph V} {v w : V} (s : Set (Sym2 V)) {p : G.Walk v w} (hp : ∀ e ∈ p.edges, e ∉ s),
  SimpleGraph.Walk.map (SimpleGraph.Hom.mapSpanningSubgraphs ⋯) (SimpleGraph.Walk.toDeleteEdges s p hp) = p
Result.autoException ::
Auto failed to find proof

Testing || LinearEquiv.symm_apply_apply : ∀ {R : Type u_1} {S : Type u_5} {M : Type u_6} {M₂ : Type u_8} [inst : Semiring R] [inst_1 : Semiring S]
  [inst_2 : AddCommMonoid M] [inst_3 : AddCommMonoid M₂] {module_M : _root_.Module R M}
  {module_S_M₂ : _root_.Module S M₂} {σ : R →+* S} {σ' : S →+* R} {re₁ : RingHomInvPair σ σ'}
  {re₂ : RingHomInvPair σ' σ} (e : M ≃ₛₗ[σ] M₂) (b : M), e.symm (e b) = b
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _R__+*_S:
  ;;   _R__+*_S!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _R__+*_S!val!0 () _R__+*_S)
  ;; cardinality constraint:
  (forall ((x _R__+*_S)) (= x _R__+*_S!val!0))
  ;; -----------
  ;; universe for _S__+*_R:
  ;;   _S__+*_R!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _S__+*_R!val!0 () _S__+*_R)
  ;; cardinality constraint:
  (forall ((x _S__+*_R)) (= x _S__+*_R!val!0))
  ;; -----------
  ;; universe for _M_____σ__M₂:
  ;;   |_M_____σ__M₂!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_M_____σ__M₂!val!0| () _M_____σ__M₂)
  ;; cardinality constraint:
  (forall ((x _M_____σ__M₂)) (= x |_M_____σ__M₂!val!0|))
  ;; -----------
  ;; universe for _M₂_____σ___M:
  ;;   |_M₂_____σ___M!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_M₂_____σ___M!val!0| () _M₂_____σ___M)
  ;; cardinality constraint:
  (forall ((x _M₂_____σ___M)) (= x |_M₂_____σ___M!val!0|))
  ;; -----------
  ;; universe for _M:
  ;;   _M!val!1 _M!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _M!val!1 () _M)
  (declare-fun _M!val!0 () _M)
  ;; cardinality constraint:
  (forall ((x _M)) (or (= x _M!val!1) (= x _M!val!0)))
  ;; -----------
  ;; universe for _M₂:
  ;;   |_M₂!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_M₂!val!0| () _M₂)
  ;; cardinality constraint:
  (forall ((x _M₂)) (= x |_M₂!val!0|))
  ;; -----------
  (define-fun valid_fact_2 () Bool
    (not (= (_DFunLike.coe_0 (_LinearEquiv.symm _e) (_DFunLike.coe _e _b)) _b)))
  (define-fun valid_fact_1 () Bool
    (_RingHomInvPair_0 |_σ_| |_σ|))
  (define-fun _b () _M
    _M!val!0)
  (define-fun valid_fact_0 () Bool
    (_RingHomInvPair |_σ| |_σ_|))
  (define-fun |_σ| () _R__+*_S
    _R__+*_S!val!0)
  (define-fun |_σ_| () _S__+*_R
    _S__+*_R!val!0)
  (define-fun _e () _M_____σ__M₂
    |_M_____σ__M₂!val!0|)
  (define-fun _DFunLike.coe ((x!0 _M_____σ__M₂) (x!1 _M)) _M₂
    |_M₂!val!0|)
  (define-fun _DFunLike.coe_0 ((x!0 _M₂_____σ___M) (x!1 _M₂)) _M
    _M!val!1)
  (define-fun _RingHomInvPair_0 ((x!0 _S__+*_R) (x!1 _R__+*_S)) Bool
    true)
  (define-fun _RingHomInvPair ((x!0 _R__+*_S) (x!1 _S__+*_R)) Bool
    true)
  (define-fun _LinearEquiv.symm ((x!0 _M_____σ__M₂)) _M₂_____σ___M
    |_M₂_____σ___M!val!0|)
)


Testing || Valuation.IsEquiv.ne_zero : ∀ {R : Type u_3} {Γ₀ : Type u_4} {Γ'₀ : Type u_5} [inst : Ring R] [inst_1 : LinearOrderedCommMonoidWithZero Γ₀]
  [inst_2 : LinearOrderedCommMonoidWithZero Γ'₀] {v₁ : Valuation R Γ₀} {v₂ : Valuation R Γ'₀},
  v₁.IsEquiv v₂ → ∀ {r : R}, v₁ r ≠ 0 ↔ v₂ r ≠ 0
Result.success

Testing || List.pwFilter_map : ∀ {α : Type u_1} {R : α → α → Prop} {β : Type u_2} [inst : DecidableRel R] (f : β → α) (l : List β),
  List.pwFilter R (List.map f l) = List.map f (List.pwFilter (fun x y => R (f x) (f y)) l)
Result.autoException ::
Auto failed to find proof

Testing || Relator.RightUnique.forall₂ : ∀ {α : Type u_1} {β : Type u_2} {R : α → β → Prop}, Relator.RightUnique R → Relator.RightUnique (List.Forall₂ R)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  (define-fun valid_fact_2 () Bool
    (let ((a!1 (forall ((_l _List_α) (_l_0 _List_β) (_l_1 _List_β))
             (or (= _l_0 _l_1)
                 (not (|_List.Forall₂_R| _l _l_1))
                 (not (|_List.Forall₂_R| _l _l_0))))))
  (or (not _Relator.RightUnique_R) a!1)))
  (define-fun valid_fact_0 () Bool
    _Relator.RightUnique_R)
  (define-fun _Relator.RightUnique_R () Bool
    true)
  (define-fun |_Relator.RightUnique_List.Forall₂_R| () Bool
    false)
  (define-fun valid_fact_1 () Bool
    (not |_Relator.RightUnique_List.Forall₂_R|))
  (define-fun valid_fact_3 () Bool
    (let ((a!1 (forall ((_l_2 _List_List_α)
                    (_l_3 _List_List_β)
                    (_l_4 _List_List_β))
             (or (= _l_3 _l_4)
                 (not (|_List.Forall₂_List.Forall₂_R| _l_2 _l_4))
                 (not (|_List.Forall₂_List.Forall₂_R| _l_2 _l_3))))))
  (or (not |_Relator.RightUnique_List.Forall₂_R|) a!1)))
  (define-fun |_List.Forall₂_R| ((x!0 _List_α) (x!1 _List_β)) Bool
    false)
  (define-fun |_List.Forall₂_List.Forall₂_R| ((x!0 _List_List_α)
   (x!1 _List_List_β)) Bool
    false)
)


Testing || CFC.quasispectrum_zero_eq : ∀ {R : Type u_1} {A : Type u_2} {p : A → Prop} [inst : CommSemiring R] [inst_1 : Nontrivial R] [inst_2 : StarRing R]
  [inst_3 : MetricSpace R] [inst_4 : TopologicalSemiring R] [inst_5 : ContinuousStar R] [inst_6 : NonUnitalRing A]
  [inst_7 : StarRing A] [inst_8 : TopologicalSpace A] [inst_9 : _root_.Module R A] [inst_10 : IsScalarTower R A A]
  [inst_11 : SMulCommClass R A A] [instCFCₙ : NonUnitalContinuousFunctionalCalculus R p], quasispectrum R 0 = {0}
Result.autoException ::
_private.Auto.Translation.LamFOL2SMT.0.Auto.SMT.lamTerm2STermAux :: Argument number mismatch. Higher order input?

Testing || taylor_mean_remainder_cauchy : ∀ {f : ℝ → ℝ} {x x₀ : ℝ} {n : ℕ},
  x₀ < x →
    ContDiffOn ℝ (↑n) f (Set.Icc x₀ x) →
      DifferentiableOn ℝ (iteratedDerivWithin n f (Set.Icc x₀ x)) (Set.Ioo x₀ x) →
        ∃ x' ∈ Set.Ioo x₀ x,
          f x - taylorWithinEval f n (Set.Icc x₀ x) x₀ x =
            iteratedDerivWithin (n + 1) f (Set.Icc x₀ x) x' * (x - x') ^ n / ↑n.factorial * (x - x₀)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Idempotents.DoldKan.N_obj : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  [inst_2 : CategoryTheory.IsIdempotentComplete C] [inst_3 : CategoryTheory.Limits.HasFiniteCoproducts C]
  (X : CategoryTheory.SimplicialObject C),
  CategoryTheory.Idempotents.DoldKan.N.obj X =
    (CategoryTheory.Idempotents.toKaroubiEquivalence (ChainComplex C ℕ)).inverse.obj
      (AlgebraicTopology.DoldKan.N₁.obj X)
Result.success

Testing || HomogeneousLocalization.val_zsmul : ∀ {ι : Type u_1} {R : Type u_2} {A : Type u_3} [inst : CommRing R] [inst_1 : CommRing A] [inst_2 : Algebra R A]
  {𝒜 : ι → Submodule R A} (x : Submonoid A) (n : ℤ) (y : HomogeneousLocalization 𝒜 x), (n • y).val = n • y.val
Result.success

Testing || Filter.NeBot.mul_zero_nonneg : ∀ {α : Type u_2} [inst : MulZeroClass α] {f : Filter α}, f.NeBot → 0 ≤ f * 0
Result.autoException ::
Auto failed to find proof

Testing || sdiff_sdiff : ∀ {α : Type u_2} [inst : GeneralizedCoheytingAlgebra α] (a b c : α), (a \ b) \ c = a \ (b ⊔ c)
Result.autoException ::
Auto failed to find proof

Testing || Rat.ofInt_eq_cast : ∀ (n : ℤ), Rat.ofInt n = ↑n
Result.success

Testing || QPF.Fix.ind_rec : ∀ {F : Type u → Type u} [q : QPF F] {α : Type u} (g₁ g₂ : QPF.Fix F → α),
  (∀ (x : F (QPF.Fix F)), g₁ <$> x = g₂ <$> x → g₁ (QPF.Fix.mk x) = g₂ (QPF.Fix.mk x)) → ∀ (x : QPF.Fix F), g₁ x = g₂ x
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _QPF.Fix_F:
  ;;   _QPF.Fix_F!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _QPF.Fix_F!val!0 () _QPF.Fix_F)
  ;; cardinality constraint:
  (forall ((x _QPF.Fix_F)) (= x _QPF.Fix_F!val!0))
  ;; -----------
  ;; universe for _α:
  ;;   |_α!val!1| |_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!1| () _α)
  (declare-fun |_α!val!0| () _α)
  ;; cardinality constraint:
  (forall ((x _α)) (or (= x |_α!val!1|) (= x |_α!val!0|)))
  ;; -----------
  ;; universe for __QPF.P_F_QPF.Fix_F:
  ;;   __QPF.P_F_QPF.Fix_F!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun __QPF.P_F_QPF.Fix_F!val!0 () __QPF.P_F_QPF.Fix_F)
  ;; cardinality constraint:
  (forall ((x __QPF.P_F_QPF.Fix_F)) (= x __QPF.P_F_QPF.Fix_F!val!0))
  ;; -----------
  ;; universe for __QPF.P_F_α:
  ;;   |__QPF.P_F_α!val!3| |__QPF.P_F_α!val!2| |__QPF.P_F_α!val!0| |__QPF.P_F_α!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |__QPF.P_F_α!val!3| () __QPF.P_F_α)
  (declare-fun |__QPF.P_F_α!val!2| () __QPF.P_F_α)
  (declare-fun |__QPF.P_F_α!val!0| () __QPF.P_F_α)
  (declare-fun |__QPF.P_F_α!val!1| () __QPF.P_F_α)
  ;; cardinality constraint:
  (forall ((x __QPF.P_F_α))
          (or (= x |__QPF.P_F_α!val!3|)
              (= x |__QPF.P_F_α!val!2|)
              (= x |__QPF.P_F_α!val!0|)
              (= x |__QPF.P_F_α!val!1|)))
  ;; -----------
  ;; universe for _F_QPF.Fix_F:
  ;;   _F_QPF.Fix_F!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _F_QPF.Fix_F!val!0 () _F_QPF.Fix_F)
  ;; cardinality constraint:
  (forall ((x _F_QPF.Fix_F)) (= x _F_QPF.Fix_F!val!0))
  ;; -----------
  ;; universe for _F_α:
  ;;   |_F_α!val!1| |_F_α!val!2| |_F_α!val!3| |_F_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_F_α!val!1| () _F_α)
  (declare-fun |_F_α!val!2| () _F_α)
  (declare-fun |_F_α!val!3| () _F_α)
  (declare-fun |_F_α!val!0| () _F_α)
  ;; cardinality constraint:
  (forall ((x _F_α))
          (or (= x |_F_α!val!1|)
              (= x |_F_α!val!2|)
              (= x |_F_α!val!3|)
              (= x |_F_α!val!0|)))
  ;; -----------
  ;; universe for __QPF.P_F_QPF.P_F.W:
  ;;   __QPF.P_F_QPF.P_F.W!val!1 __QPF.P_F_QPF.P_F.W!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun __QPF.P_F_QPF.P_F.W!val!1 () __QPF.P_F_QPF.P_F.W)
  (declare-fun __QPF.P_F_QPF.P_F.W!val!0 () __QPF.P_F_QPF.P_F.W)
  ;; cardinality constraint:
  (forall ((x __QPF.P_F_QPF.P_F.W))
          (or (= x __QPF.P_F_QPF.P_F.W!val!1) (= x __QPF.P_F_QPF.P_F.W!val!0)))
  ;; -----------
  ;; universe for _F_QPF.P_F.W:
  ;;   _F_QPF.P_F.W!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _F_QPF.P_F.W!val!0 () _F_QPF.P_F.W)
  ;; cardinality constraint:
  (forall ((x _F_QPF.P_F.W)) (= x _F_QPF.P_F.W!val!0))
  ;; -----------
  ;; universe for _QPF.P_F.W:
  ;;   _QPF.P_F.W!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _QPF.P_F.W!val!0 () _QPF.P_F.W)
  ;; cardinality constraint:
  (forall ((x _QPF.P_F.W)) (= x _QPF.P_F.W!val!0))
  ;; -----------
  (define-fun valid_fact_5 () Bool
    true)
  (define-fun valid_fact_3 () Bool
    (forall ((_pl___0 __QPF.P_F_QPF.Fix_F))
  (= (_QPF.abs (|_QPF.P_F.map_g₂| _pl___0))
     (|_Functor.map_g₂| (_QPF.abs_0 _pl___0)))))
  (define-fun valid_fact_4 () Bool
    (forall ((_pl___1 __QPF.P_F_QPF.Fix_F))
  (= (_QPF.abs_1 (_QPF.P_F.map_QPF.fixToW _pl___1))
     (_Functor.map_QPF.fixToW (_QPF.abs_0 _pl___1)))))
  (define-fun valid_fact_2 () Bool
    (forall ((_pl__ __QPF.P_F_QPF.Fix_F))
  (= (_QPF.abs (|_QPF.P_F.map_g₁| _pl__))
     (|_Functor.map_g₁| (_QPF.abs_0 _pl__)))))
  (define-fun valid_fact_1 () Bool
    (not (= (|_g₁| _x) (|_g₂| _x))))
  (define-fun _x () _QPF.Fix_F
    _QPF.Fix_F!val!0)
  (define-fun valid_fact_0 () Bool
    (forall ((_f _F_QPF.Fix_F))
  (let ((a!1 (_Quotient.mk_QPF.Wsetoid
               (_PFunctor.W.mk (_QPF.P_F.map_QPF.fixToW (_QPF.repr _f))))))
    (or (not (= (|_Functor.map_g₁| _f) (|_Functor.map_g₂| _f)))
        (= (|_g₁| a!1) (|_g₂| a!1))))))
  (define-fun _QPF.abs ((x!0 __QPF.P_F_α)) _F_α
    (ite (= x!0 |__QPF.P_F_α!val!1|) |_F_α!val!1|
      |_F_α!val!0|))
  (define-fun _Quotient.mk_QPF.Wsetoid ((x!0 _QPF.P_F.W)) _QPF.Fix_F
    _QPF.Fix_F!val!0)
  (define-fun |_QPF.P_F.map_g₁| ((x!0 __QPF.P_F_QPF.Fix_F)) __QPF.P_F_α
    |__QPF.P_F_α!val!1|)
  (define-fun |_g₁| ((x!0 _QPF.Fix_F)) _α
    |_α!val!0|)
  (define-fun _QPF.repr ((x!0 _F_QPF.Fix_F)) __QPF.P_F_QPF.Fix_F
    __QPF.P_F_QPF.Fix_F!val!0)
  (define-fun _QPF.abs_0 ((x!0 __QPF.P_F_QPF.Fix_F)) _F_QPF.Fix_F
    _F_QPF.Fix_F!val!0)
  (define-fun _Functor.map_QPF.fixToW ((x!0 _F_QPF.Fix_F)) _F_QPF.P_F.W
    _F_QPF.P_F.W!val!0)
  (define-fun |_Functor.map_g₁| ((x!0 _F_QPF.Fix_F)) _F_α
    |_F_α!val!1|)
  (define-fun |_Functor.map_g₂| ((x!0 _F_QPF.Fix_F)) _F_α
    |_F_α!val!0|)
  (define-fun _QPF.P_F.map_QPF.fixToW ((x!0 __QPF.P_F_QPF.Fix_F)) __QPF.P_F_QPF.P_F.W
    __QPF.P_F_QPF.P_F.W!val!0)
  (define-fun _PFunctor.W.mk ((x!0 __QPF.P_F_QPF.P_F.W)) _QPF.P_F.W
    _QPF.P_F.W!val!0)
  (define-fun |_QPF.P_F.map_g₂| ((x!0 __QPF.P_F_QPF.Fix_F)) __QPF.P_F_α
    |__QPF.P_F_α!val!0|)
  (define-fun |_g₂| ((x!0 _QPF.Fix_F)) _α
    |_α!val!1|)
  (define-fun _QPF.abs_1 ((x!0 __QPF.P_F_QPF.P_F.W)) _F_QPF.P_F.W
    _F_QPF.P_F.W!val!0)
)


Testing || Polynomial.eval_one_cyclotomic_not_prime_pow : ∀ {R : Type u_1} [inst : Ring R] {n : ℕ},
  (∀ {p : ℕ}, Nat.Prime p → ∀ (k : ℕ), p ^ k ≠ n) → Polynomial.eval 1 (Polynomial.cyclotomic n R) = 1
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Function.Injective fun x =>
  cifvar_2 x_0 x`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || leibniz_cross : ∀ {R : Type u_1} [inst : CommRing R] (u v w : Fin 3 → R),
  (crossProduct u) ((crossProduct v) w) = (crossProduct ((crossProduct u) v)) w + (crossProduct v) ((crossProduct u) w)
Result.autoException ::
(deterministic) timeout at `whnf`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Real.one_sub_le_exp_neg : ∀ (x : ℝ), 1 - x ≤ Real.exp (-x)
Result.success

Testing || Monovary.sum_smul_comp_perm_le_sum_smul : ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : LinearOrderedSemiring α] [inst_1 : ExistsAddOfLE α]
  [inst_2 : LinearOrderedCancelAddCommMonoid β] [inst_3 : _root_.Module α β] [inst_4 : PosSMulMono α β]
  {σ : Equiv.Perm ι} {f : ι → α} {g : ι → β} [inst_5 : Fintype ι],
  Monovary f g → ∑ i : ι, f i • g (σ i) ≤ ∑ i : ι, f i • g i
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `∑ i ∈ x_0,
  cifvar_10 (cifvar_11 i) (cifvar_12 (cifvar_13 cifvar_14 (cifvar_13 x_1 i)))`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || IndexedPartition.disjoint : ∀ {ι : Type u_1} {α : Type u_2} {s : ι → Set α}, IndexedPartition s → Pairwise (Disjoint on s)
Result.autoException ::
Auto failed to find proof

Testing || isConjRoot_iff_mem_minpoly_rootSet : ∀ {K : Type u_2} {S : Type u_4} [inst : CommRing S] [inst_1 : Field K] [inst_2 : Algebra K S] [inst_3 : IsDomain S]
  {x y : S}, IsIntegral K x → (IsConjRoot K x y ↔ y ∈ (minpoly K x).rootSet S)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_2.toFinset`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || List.Perm.eraseP : ∀ {α : Type u_1} (f : α → Bool) {l₁ l₂ : List α},
  List.Pairwise (fun a b => f a = true → f b = true → False) l₁ →
    l₁.Perm l₂ → (List.eraseP f l₁).Perm (List.eraseP f l₂)
Result.autoException ::
Auto failed to find proof

Testing || Fin.appendIsometry_symm_apply : ∀ {α : Type u} [inst : PseudoEMetricSpace α] (m n : ℕ) (f : Fin (m + n) → α),
  (Fin.appendIsometry m n).symm f = (fun i => f (Fin.castAdd n i), fun i => f (Fin.natAdd m i))
Result.autoException ::
_private.Auto.Translation.LamFOL2SMT.0.Auto.SMT.lamSort2SSortAux :: Unexpected error. Higher order input?

Testing || AddUnits.addRight_bijective : ∀ {M : Type u_3} [inst : AddMonoid M] (a : AddUnits M), Function.Bijective fun x => x + ↑a
Result.autoException ::
Auto failed to find proof

Testing || SimpleGraph.Walk.length_transfer : ∀ {V : Type u} {G : SimpleGraph V} {u v : V} (p : G.Walk u v) {H : SimpleGraph V} (hp : ∀ e ∈ p.edges, e ∈ H.edgeSet),
  (p.transfer H hp).length = p.length
Result.autoException ::
Auto failed to find proof

Testing || CliffordAlgebra.forall_mul_self_eq_iff : ∀ {R : Type u_1} [inst : CommRing R] {M : Type u_2} [inst_1 : AddCommGroup M] [inst_2 : _root_.Module R M]
  {Q : QuadraticForm R M} {A : Type u_4} [inst_3 : Ring A] [inst_4 : Algebra R A],
  IsUnit 2 →
    ∀ (f : M →ₗ[R] A),
      (∀ (x : M), f x * f x = (algebraMap R A) (Q x)) ↔
        (LinearMap.mul R A).compl₂ f ∘ₗ f + (LinearMap.mul R A).flip.compl₂ f ∘ₗ f =
          LinearMap.compr₂ (QuadraticMap.polarBilin Q) (Algebra.linearMap R A)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `QuadraticMap.polar (cifvar_10 x_0)
  a b`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || Topology.IsQuotientMap.image_connectedComponent : ∀ {α : Type u} {β : Type v} [inst : TopologicalSpace α] [inst_1 : TopologicalSpace β] {f : α → β},
  Topology.IsQuotientMap f →
    (∀ (y : β), IsConnected (f ⁻¹' {y})) → ∀ (a : α), f '' connectedComponent a = connectedComponent (f a)
Result.success

Testing || isPiSystem_iUnion_of_monotone : ∀ {α : Type u_3} {ι : Type u_4} [inst : SemilatticeSup ι] (p : ι → Set (Set α)),
  (∀ (n : ι), IsPiSystem (p n)) → Monotone p → IsPiSystem (⋃ n, p n)
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #1, ((!5 x0 (λx1 : #2, (∀ x2 : #2, ((!6 x0 x2) → ((!7 (!8 x1 x2)) → (!6 x0 (!8 x1 x2))))))) = (!0 x0))) is not type correct

Testing || Setoid.eq_of_mem_eqv_class : ∀ {α : Type u_1} {c : Set (Set α)},
  (∀ (a : α), ∃! b, b ∈ c ∧ a ∈ b) → ∀ {x : α} {b b' : Set α}, b ∈ c → x ∈ b → b' ∈ c → x ∈ b' → b = b'
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `∃! b,
  cifvar_2 (cifvar_3 cifvar_4 b) (cifvar_5 b x_0)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || univLE_max : UnivLE.{u, max u v}
Result.autoException ::
Auto failed to find proof

Testing || hasLineDerivAt_zero : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {F : Type u_2} [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace 𝕜 F] {E : Type u_3} [inst_3 : AddCommGroup E] [inst_4 : _root_.Module 𝕜 E] {f : E → F} {x : E},
  HasLineDerivAt 𝕜 f 0 x 0
Result.autoException ::
Auto failed to find proof

Testing || Complex.polarCoord_apply : ∀ (a : ℂ), ↑Complex.polarCoord a = (Complex.abs a, a.arg)
Result.autoException ::
Auto failed to find proof

Testing || Complex.cosh_sub : ∀ (x y : ℂ), Complex.cosh (x - y) = Complex.cosh x * Complex.cosh y - Complex.sinh x * Complex.sinh y
Result.success

Testing || MeasureTheory.Measure.restrict_apply' : ∀ {α : Type u_2} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s t : Set α},
  MeasurableSet s → (μ.restrict s) t = μ (t ∩ s)
Result.success

Testing || Inseparable.mem_open_iff : ∀ {X : Type u_1} [inst : TopologicalSpace X] {x y : X} {s : Set X}, Inseparable x y → IsOpen s → (x ∈ s ↔ y ∈ s)
Result.success

Testing || CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse_map_base : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] (F : CategoryTheory.Functor C CategoryTheory.Cat)
  {X Y : CategoryTheory.Grothendieck F} (f : X ⟶ Y),
  ((CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse F).map f).base = f.base
Result.success

Testing || UniqueFactorizationMonoid.squarefree_iff_nodup_normalizedFactors : ∀ {R : Type u_1} [inst : CancelCommMonoidWithZero R] [inst_1 : UniqueFactorizationMonoid R]
  [inst_2 : NormalizationMonoid R] {x : R},
  x ≠ 0 → (Squarefree x ↔ (UniqueFactorizationMonoid.normalizedFactors x).Nodup)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Multiset.count a x_1`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || ContDiffAt.prod_map : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type uE} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type uF} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {n : WithTop ℕ∞}
  {E' : Type u_3} [inst_5 : NormedAddCommGroup E'] [inst_6 : NormedSpace 𝕜 E'] {F' : Type u_4}
  [inst_7 : NormedAddCommGroup F'] [inst_8 : NormedSpace 𝕜 F'] {f : E → F} {g : E' → F'} {x : E} {y : E'},
  ContDiffAt 𝕜 n f x → ContDiffAt 𝕜 n g y → ContDiffAt 𝕜 n (Prod.map f g) (x, y)
Result.success

Testing || MeasureTheory.isClosed_aeStronglyMeasurable' : ∀ {α : Type u_1} {F : Type u_2} {p : ENNReal} [inst : NormedAddCommGroup F] {m m0 : MeasurableSpace α}
  {μ : MeasureTheory.Measure α} [inst_1 : Fact (1 ≤ p)] [inst_2 : CompleteSpace F],
  m ≤ m0 → IsClosed {f | MeasureTheory.AEStronglyMeasurable' m (↑↑f) μ}
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _ENNReal:
  ;;   _ENNReal!val!1 _ENNReal!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _ENNReal!val!1 () _ENNReal)
  (declare-fun _ENNReal!val!0 () _ENNReal)
  ;; cardinality constraint:
  (forall ((x _ENNReal)) (or (= x _ENNReal!val!1) (= x _ENNReal!val!0)))
  ;; -----------
  ;; universe for _MeasurableSpace_α:
  ;;   |_MeasurableSpace_α!val!0| |_MeasurableSpace_α!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_MeasurableSpace_α!val!0| () _MeasurableSpace_α)
  (declare-fun |_MeasurableSpace_α!val!1| () _MeasurableSpace_α)
  ;; cardinality constraint:
  (forall ((x _MeasurableSpace_α))
          (or (= x |_MeasurableSpace_α!val!0|)
              (= x |_MeasurableSpace_α!val!1|)))
  ;; -----------
  ;; universe for _Set__MeasureTheory.Lp_F_p_μ:
  ;;   |_Set__MeasureTheory.Lp_F_p_μ!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set__MeasureTheory.Lp_F_p_μ!val!0| () _Set__MeasureTheory.Lp_F_p_μ)
  ;; cardinality constraint:
  (forall ((x _Set__MeasureTheory.Lp_F_p_μ))
          (= x |_Set__MeasureTheory.Lp_F_p_μ!val!0|))
  ;; -----------
  (define-fun _CompleteSpace_F () Bool
    true)
  (define-fun valid_fact_1 () Bool
    _CompleteSpace_F)
  (define-fun valid_fact_3 () Bool
    (not (_IsClosed |__f___MeasureTheory.AEStronglyMeasurable__m___f_μ_|)))
  (define-fun _1_ () _ENNReal
    _ENNReal!val!0)
  (define-fun valid_fact_4 () Bool
    (forall ((_s _Set__MeasureTheory.Lp_F_p_μ))
  (or (_IsClosed _s) (not (_IsComplete _s)))))
  (define-fun valid_fact_2 () Bool
    (_LE.le_0 _m _m0_))
  (define-fun _p () _ENNReal
    _ENNReal!val!1)
  (define-fun _m0_ () _MeasurableSpace_α
    |_MeasurableSpace_α!val!1|)
  (define-fun _m () _MeasurableSpace_α
    |_MeasurableSpace_α!val!0|)
  (define-fun |__f___MeasureTheory.AEStronglyMeasurable__m___f_μ_| () _Set__MeasureTheory.Lp_F_p_μ
    |_Set__MeasureTheory.Lp_F_p_μ!val!0|)
  (define-fun valid_fact_0 () Bool
    (_Fact (_LE.le _1_ _p)))
  (define-fun _Fact ((x!0 Bool)) Bool
    true)
  (define-fun _IsClosed ((x!0 _Set__MeasureTheory.Lp_F_p_μ)) Bool
    false)
  (define-fun _LE.le ((x!0 _ENNReal) (x!1 _ENNReal)) Bool
    false)
  (define-fun _IsComplete ((x!0 _Set__MeasureTheory.Lp_F_p_μ)) Bool
    false)
  (define-fun _LE.le_0 ((x!0 _MeasurableSpace_α) (x!1 _MeasurableSpace_α)) Bool
    true)
)


Testing || ProbabilityTheory.Kernel.fst_comp : ∀ {α : Type u_1} {β : Type u_2} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} {γ : Type u_3} {δ : Type u_4}
  {mγ : MeasurableSpace γ} {mδ : MeasurableSpace δ} (κ : ProbabilityTheory.Kernel α β)
  (η : ProbabilityTheory.Kernel β (γ × δ)), (η.comp κ).fst = η.fst.comp κ
Result.success

Testing || TypeVec.dropFun_id : ∀ {n : ℕ} {α : TypeVec.{u_1} (n + 1)}, TypeVec.dropFun TypeVec.id = TypeVec.id
Result.success

Testing || Real.cos_sq_add_sin_sq : ∀ (x : ℝ), Real.cos x ^ 2 + Real.sin x ^ 2 = 1
Result.success

Testing || Equiv.addCommSemigroup.proof_1 : ∀ {α : Type u_2} {β : Type u_1} (e : α ≃ β) [inst : AddCommSemigroup β] (x y : α), e (e.symm (e x + e y)) = e x + e y
Result.success

Testing || Nat.lcm_pos : ∀ {m n : ℕ}, 0 < m → 0 < n → 0 < m.lcm n
Result.success

Testing || PProd.exists' : ∀ {α : Sort u_1} {β : Sort u_2} {p : α → β → Prop}, (∃ x, p x.fst x.snd) ↔ ∃ a b, p a b
Result.success

Testing || div_le_div_left : ∀ {α : Type u_2} [inst : LinearOrderedSemifield α] {a b c : α}, 0 < a → 0 < b → 0 < c → (a / b ≤ a / c ↔ c ≤ b)
Result.success

Testing || Set.Finite.induction_to_univ : ∀ {α : Type u} [inst : Finite α] {C : Set α → Prop} (S0 : Set α),
  C S0 → (∀ (S : Set α), S ≠ Set.univ → C S → ∃ a ∉ S, C (insert a S)) → C Set.univ
Result.autoException ::
Auto failed to find proof

Testing || VectorBundleCore.continuous_proj : ∀ {R : Type u_1} {B : Type u_2} {F : Type u_3} [inst : NontriviallyNormedField R] [inst_1 : NormedAddCommGroup F]
  [inst_2 : NormedSpace R F] [inst_3 : TopologicalSpace B] {ι : Type u_5} (Z : VectorBundleCore R B F ι),
  Continuous Z.proj
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Bundle.TotalSpace cifvar_3
  (cifvar_4 x_0)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || CategoryTheory.equivYoneda'_inv_val : ∀ (S : CategoryTheory.Sheaf CategoryTheory.typesGrothendieckTopology (Type u)),
  (CategoryTheory.equivYoneda' S).inv.val = (CategoryTheory.equivYoneda S.val ⋯).inv
Result.success

Testing || Fintype.decidableEqAddEquivFintype.proof_1 : ∀ {α : Type u_1} {β : Type u_2} [inst : Add α] [inst_1 : Add β] (a b : α ≃+ β), ⇑a = ⇑b ↔ a = b
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_8 a✝ = cifvar_8 b`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || intervalIntegral.intervalIntegrable_log : ∀ {a b : ℝ} {μ : MeasureTheory.Measure ℝ} [inst : MeasureTheory.IsLocallyFiniteMeasure μ],
  0 ∉ Set.uIcc a b → IntervalIntegrable Real.log μ a b
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x.decidableEq cifvar_7`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || StrictConcaveOn.concaveOn : ∀ {𝕜 : Type u_1} {E : Type u_2} {β : Type u_5} [inst : OrderedSemiring 𝕜] [inst_1 : AddCommMonoid E]
  [inst_2 : OrderedAddCommMonoid β] [inst_3 : _root_.Module 𝕜 E] [inst_4 : _root_.Module 𝕜 β] {s : Set E} {f : E → β},
  StrictConcaveOn 𝕜 s f → ConcaveOn 𝕜 s f
Result.success

Testing || ProbabilityTheory.Kernel.ae_compProd_iff : ∀ {α : Type u_1} {β : Type u_2} {mα : MeasurableSpace α} {mβ : MeasurableSpace β} {γ : Type u_3}
  {mγ : MeasurableSpace γ} {κ : ProbabilityTheory.Kernel α β} [inst : ProbabilityTheory.IsSFiniteKernel κ]
  {η : ProbabilityTheory.Kernel (α × β) γ} [inst : ProbabilityTheory.IsSFiniteKernel η] {a : α} {p : β × γ → Prop},
  MeasurableSet {x | p x} →
    ((∀ᵐ (bc : β × γ) ∂(κ.compProd η) a, p bc) ↔ ∀ᵐ (b : β) ∂κ a, ∀ᵐ (c : γ) ∂η (a, b), p (b, c))
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `∀ᶠ (c : γ) in
  cifvar_20 (cifvar_21 x_2 (cifvar_22 x_4 b)), cifvar_18 (cifvar_19 b c)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || SMulPosReflectLT.toSMulPosMono : ∀ {α : Type u_1} {β : Type u_2} [inst : SMul α β] [inst_1 : Preorder α] [inst_2 : LinearOrder β]
  [inst_3 : _root_.Zero β] [inst_4 : SMulPosReflectLT α β], SMulPosMono α β
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Zero.toOfNat0`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || MeasureTheory.withDensity_indicator_one : ∀ {α : Type u_1} {m0 : MeasurableSpace α} {μ : MeasureTheory.Measure α} {s : Set α},
  MeasurableSet s → μ.withDensity (s.indicator 1) = μ.restrict s
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Set_α:
  ;;   |_Set_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_α!val!0| () _Set_α)
  ;; cardinality constraint:
  (forall ((x _Set_α)) (= x |_Set_α!val!0|))
  ;; -----------
  ;; universe for _MeasureTheory.Measure_α:
  ;;   |_MeasureTheory.Measure_α!val!2| |_MeasureTheory.Measure_α!val!0| |_MeasureTheory.Measure_α!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_MeasureTheory.Measure_α!val!2| () _MeasureTheory.Measure_α)
  (declare-fun |_MeasureTheory.Measure_α!val!0| () _MeasureTheory.Measure_α)
  (declare-fun |_MeasureTheory.Measure_α!val!1| () _MeasureTheory.Measure_α)
  ;; cardinality constraint:
  (forall ((x _MeasureTheory.Measure_α))
          (or (= x |_MeasureTheory.Measure_α!val!2|)
              (= x |_MeasureTheory.Measure_α!val!0|)
              (= x |_MeasureTheory.Measure_α!val!1|)))
  ;; -----------
  (define-fun valid_fact_0 () Bool
    (_MeasurableSet _s))
  (define-fun valid_fact_1 () Bool
    (not (= (|_fun_μ_=>_μ.withDensity_s.indicator_1_| |_μ|)
        (_MeasureTheory.Measure.restrict |_μ| _s))))
  (define-fun _s () _Set_α
    |_Set_α!val!0|)
  (define-fun |_μ| () _MeasureTheory.Measure_α
    |_MeasureTheory.Measure_α!val!0|)
  (define-fun _MeasurableSet ((x!0 _Set_α)) Bool
    true)
  (define-fun _MeasureTheory.Measure.restrict ((x!0 _MeasureTheory.Measure_α)
   (x!1 _Set_α)) _MeasureTheory.Measure_α
    |_MeasureTheory.Measure_α!val!2|)
  (define-fun |_fun_μ_=>_μ.withDensity_s.indicator_1_| ((x!0
    _MeasureTheory.Measure_α)) _MeasureTheory.Measure_α
    |_MeasureTheory.Measure_α!val!1|)
)


Testing || add_halves' : ∀ {R : Type u_1} [inst : DivisionSemiring R] [inst_1 : NeZero 2] (a : R), a / 2 + a / 2 = a
Result.success

Testing || CategoryTheory.Limits.preservesBiproductsOfShape_of_preservesProductsOfShape : ∀ {C : Type u} [inst : CategoryTheory.Category.{v, u} C] [inst_1 : CategoryTheory.Preadditive C] {D : Type u'}
  [inst_2 : CategoryTheory.Category.{v', u'} D] [inst_3 : CategoryTheory.Preadditive D] (F : CategoryTheory.Functor C D)
  [inst_4 : F.PreservesZeroMorphisms] {J : Type} [inst_5 : Fintype J]
  [inst_6 : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) F],
  CategoryTheory.Limits.PreservesBiproductsOfShape J F
Result.autoException ::
Auto failed to find proof

Testing || WithTop.image_coe_Ioi : ∀ {α : Type u_1} [inst : Preorder α] {a : α}, WithTop.some '' Set.Ioi a = Set.Ioo ↑a ⊤
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (∀ x0 : #3, (∀ x1 : #3, ((!14 (!26 x0) (λx2 : #3, (!26 x2 x1))) = (!3 x0 x1)))) is not type correct

Testing || CategoryTheory.forgetEnrichment_id : ∀ {C : Type u₁} (W : Type v) [inst : CategoryTheory.Category.{w, v} W] [inst_1 : CategoryTheory.MonoidalCategory W]
  [inst_2 : CategoryTheory.EnrichedCategory W C] (X : CategoryTheory.ForgetEnrichment W C),
  CategoryTheory.ForgetEnrichment.homTo W (CategoryTheory.CategoryStruct.id X) =
    CategoryTheory.eId W (CategoryTheory.ForgetEnrichment.to W X)
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: 𝟙_ (Type w) ⟶
  (CategoryTheory.coyoneda.obj (Opposite.op (𝟙_ W))).obj (𝟙_ W) is not a `∀`

Testing || CategoryTheory.Comma.mapLeftComp_inv_app_left : ∀ {A : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} A] {B : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} B]
  {T : Type u₃} [inst_2 : CategoryTheory.Category.{v₃, u₃} T] (R : CategoryTheory.Functor B T)
  {L₁ L₂ L₃ : CategoryTheory.Functor A T} (l : L₁ ⟶ L₂) (l' : L₂ ⟶ L₃) (X : CategoryTheory.Comma L₃ R),
  ((CategoryTheory.Comma.mapLeftComp R l l').inv.app X).left = CategoryTheory.CategoryStruct.id X.left
Result.success

Testing || Order.pred_lt : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : PredOrder α] [inst_2 : NoMinOrder α] (a : α), Order.pred a < a
Result.success

Testing || isOfFinAddOrder_zero : ∀ {G : Type u_1} [inst : AddMonoid G], IsOfFinAddOrder 0
Result.success

Testing || gradient_eq : ∀ {𝕜 : Type u_1} {F : Type u_2} [inst : RCLike 𝕜] [inst_1 : NormedAddCommGroup F] [inst_2 : InnerProductSpace 𝕜 F]
  [inst_3 : CompleteSpace F] {f : F → 𝕜} {f' : F → F}, (∀ (x : F), HasGradientAt f (f' x) x) → gradient f = f'
Result.autoException ::
Auto failed to find proof

Testing || padicNorm.int_lt_one_iff : ∀ {p : ℕ} [hp : Fact (Nat.Prime p)] (m : ℤ), padicNorm p ↑m < 1 ↔ ↑p ∣ m
Result.success

Testing || FiberBundle.mem_baseSet_trivializationAt : ∀ {B : Type u_2} (F : Type u_3) [inst : TopologicalSpace B] [inst_1 : TopologicalSpace F] (E : B → Type u_5)
  [inst_2 : TopologicalSpace (Bundle.TotalSpace F E)] [inst_3 : (b : B) → TopologicalSpace (E b)]
  [inst_4 : FiberBundle F E] (b : B), b ∈ (trivializationAt F E b).baseSet
Result.success

Testing || Multiset.map_add_left_Ioc : ∀ {α : Type u_1} [inst : OrderedCancelAddCommMonoid α] [inst_1 : ExistsAddOfLE α] [inst_2 : LocallyFiniteOrder α]
  (a b c : α), Multiset.map (fun x => c + x) (Multiset.Ioc a b) = Multiset.Ioc (c + a) (c + b)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.image
  (fun x => cifvar_7 x_3 x) (cifvar_10 x_1 x_2)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Testing || IsOpen.div_right : ∀ {G : Type w} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G] {s t : Set G},
  IsOpen s → IsOpen (s / t)
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type a ∈ x_1 of λ binder contains bound variables

Testing || ZModModule.add_add_add_cancel : ∀ {G : Type u_2} [inst : AddCommGroup G] [inst_1 : _root_.Module (ZMod 2) G] (x y z : G), x + y + (y + z) = x + z
Result.success

Testing || ProbabilityTheory.centralMoment_one' : ∀ {Ω : Type u_1} {m : MeasurableSpace Ω} {X : Ω → ℝ} {μ : MeasureTheory.Measure Ω}
  [inst : MeasureTheory.IsFiniteMeasure μ],
  MeasureTheory.Integrable X μ → ProbabilityTheory.centralMoment X 1 μ = (1 - (μ Set.univ).toReal) * ∫ (x : Ω), X x ∂μ
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Functor.relativelyRepresentable.symmetry_fst_assoc : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {D : Type u₂} [inst_1 : CategoryTheory.Category.{v₂, u₂} D]
  {F : CategoryTheory.Functor C D} {Y : D} {b : C} {f' : F.obj b ⟶ Y} (hf' : F.relativelyRepresentable f') {a : C}
  {g : F.obj a ⟶ Y} (hg : F.relativelyRepresentable g) [inst_2 : F.Full] [inst_3 : F.Faithful] {Z : C} (h : a ⟶ Z),
  CategoryTheory.CategoryStruct.comp (hf'.symmetry hg) (CategoryTheory.CategoryStruct.comp (hg.fst' f') h) =
    CategoryTheory.CategoryStruct.comp (hf'.snd g) h
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: CategoryTheory.MorphismProperty D is not a `∀`

Testing || Duper.rule15bTheorem : ∀ (b : Bool), (!!b) = b
Result.success

Testing || Real.summable_cexp_multipliable : ∀ {α : Type u_1} {ι : Type u_2} (f : ι → α → ℝ),
  (∀ (x : α) (n : ι), 0 < f n x) →
    (∀ (x : α), Summable fun n => Real.log (f n x)) → ∀ (a : α), Multipliable fun b => f b a
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Summable fun n =>
  cifvar_7 (cifvar_2 n x_0)`.
This is because it has subterms possessing at least one of the following features
· Type argument with bound variables, e.g. `@Fin.add (n + 2) a b` where `n` is a bound variable
· λ binders whose type contain bound variables, e.g. `fun (x : a) => x` where `a` is a bound variable
· Other (TODO)
`set_option auto.mono.ignoreNonQuasiHigherOrder true` will instruct Lean-auto to ignore all the `LemmaInst`s which contain expressions that cannot be handeled by the current procedure

Elapsed time: 132657 ms

Summary:

0 E AEMeasurable.inf
1 E Std.HashSet.getD_insert
2 S LinOrd.Iso.mk_inv
3 E List.sublistsLen_length
4 E GenContFract.zeroth_contAux_eq_one_zero
5 E Rat.cast_sub_of_ne_zero
6 E _private.Mathlib.Combinatorics.SimpleGraph.Triangle.Counting.0.SimpleGraph.edgeDensity_badVertices_le
7 E _private.Mathlib.Combinatorics.Additive.SmallTripling.0.Finset.small_pos_neg_pos_add
8 E AddMonoid.exponent_pi_eq_zero
9 E isLUB_sSup
10 E Algebra.coe_sInf
11 E Set.image_mul_left_Ioo
12 E FirstOrder.Language.ElementaryEmbedding.map_rel
13 S hnot_le_iff_codisjoint_left
14 E SemistandardYoungTableau.copy_eq
15 E CategoryTheory.RanIsSheafOfIsCocontinuous.liftAux_map'
16 S AlgebraicGeometry.Spec.toSheafedSpace_obj
17 E Set.image_preimage
18 E deriv_sinh
19 E WCovBy.le_of_lt
20 S Bool.not_eq_not
21 S CategoryTheory.Limits.coneOfSectionCompYoneda_pt
22 S WittVector.wittMul_vars
23 E Real.borel_eq_generateFrom_Ioi_rat
24 E HomologicalComplex₂.comm_f
25 E Asymptotics.IsBigO.comp_tendsto
26 E Filter.Tendsto.cexp
27 E IsLocalizedModule.fromLocalizedModule'_add
28 E AffineSubspace.affineSpan_coe
29 S ENat.mem_nhds_natCast_iff
30 E HasProd.div
31 E IsLocalization.coeSubmodule_fg
32 S CategoryTheory.IsPullback.of_right
33 E Nat.nonempty_properDivisors
34 E RingEquiv.map_prod
35 E dist_smul
36 E map_mul_right_nhds₀
37 E Nat.find_le
38 E Finset.subset_mul_left
39 S IterateAddAct.ext
40 S Mathlib.Vector.mem_cons_of_mem
41 E Measurable.set_lintegral_kernel
42 E Nat.dvd_zero
43 E Function.Embedding.toEquivRange_symm_apply_self
44 S Matrix.star_dotProduct_star
45 S Finset.singleton_infs_singleton
46 E IsConjRoot.isIntegral
47 E SimpleGraph.Walk.transfer_transfer
48 E CategoryTheory.ofTypeMonad_μ_app
49 S measure_Ioc_lt_top
50 E List.takeDTR_go_eq
51 E Symmetric.iff
52 E LieModuleEquiv.symm_apply_apply
53 E AffineIndependent.mem_affineSpan_iff
54 S CategoryTheory.ofTypeMonad_obj
55 E Set.center_eq_univ
56 E LinearIsometryEquiv.differentiableOn
57 E TwoUniqueSums.of_addHom
58 E SimpleGraph.Walk.map_toDeleteEdges_eq
59 E LinearEquiv.symm_apply_apply
60 S Valuation.IsEquiv.ne_zero
61 E List.pwFilter_map
62 E Relator.RightUnique.forall₂
63 E CFC.quasispectrum_zero_eq
64 E taylor_mean_remainder_cauchy
65 S CategoryTheory.Idempotents.DoldKan.N_obj
66 S HomogeneousLocalization.val_zsmul
67 E Filter.NeBot.mul_zero_nonneg
68 E sdiff_sdiff
69 S Rat.ofInt_eq_cast
70 E QPF.Fix.ind_rec
71 E Polynomial.eval_one_cyclotomic_not_prime_pow
72 E leibniz_cross
73 S Real.one_sub_le_exp_neg
74 E Monovary.sum_smul_comp_perm_le_sum_smul
75 E IndexedPartition.disjoint
76 E isConjRoot_iff_mem_minpoly_rootSet
77 E List.Perm.eraseP
78 E Fin.appendIsometry_symm_apply
79 E AddUnits.addRight_bijective
80 E SimpleGraph.Walk.length_transfer
81 E CliffordAlgebra.forall_mul_self_eq_iff
82 S Topology.IsQuotientMap.image_connectedComponent
83 E isPiSystem_iUnion_of_monotone
84 E Setoid.eq_of_mem_eqv_class
85 E univLE_max
86 E hasLineDerivAt_zero
87 E Complex.polarCoord_apply
88 S Complex.cosh_sub
89 S MeasureTheory.Measure.restrict_apply'
90 S Inseparable.mem_open_iff
91 S CategoryTheory.Grothendieck.compAsSmallFunctorEquivalenceInverse_map_base
92 E UniqueFactorizationMonoid.squarefree_iff_nodup_normalizedFactors
93 S ContDiffAt.prod_map
94 E MeasureTheory.isClosed_aeStronglyMeasurable'
95 S ProbabilityTheory.Kernel.fst_comp
96 S TypeVec.dropFun_id
97 S Real.cos_sq_add_sin_sq
98 S Equiv.addCommSemigroup.proof_1
99 S Nat.lcm_pos
100 S PProd.exists'
101 S div_le_div_left
102 E Set.Finite.induction_to_univ
103 E VectorBundleCore.continuous_proj
104 S CategoryTheory.equivYoneda'_inv_val
105 E Fintype.decidableEqAddEquivFintype.proof_1
106 E intervalIntegral.intervalIntegrable_log
107 S StrictConcaveOn.concaveOn
108 E ProbabilityTheory.Kernel.ae_compProd_iff
109 E SMulPosReflectLT.toSMulPosMono
110 E MeasureTheory.withDensity_indicator_one
111 S add_halves'
112 E CategoryTheory.Limits.preservesBiproductsOfShape_of_preservesProductsOfShape
113 E WithTop.image_coe_Ioi
114 E CategoryTheory.forgetEnrichment_id
115 S CategoryTheory.Comma.mapLeftComp_inv_app_left
116 S Order.pred_lt
117 S isOfFinAddOrder_zero
118 E gradient_eq
119 S padicNorm.int_lt_one_iff
120 S FiberBundle.mem_baseSet_trivializationAt
121 E Multiset.map_add_left_Ioc
122 E IsOpen.div_right
123 S ZModModule.add_add_add_cancel
124 E ProbabilityTheory.centralMoment_one'
125 E CategoryTheory.Functor.relativelyRepresentable.symmetry_fst_assoc
126 S Duper.rule15bTheorem
127 E Real.summable_cexp_multipliable
