Config = {maxHeartbeats := 65536, timeout := 10, solverConfig = smt z3, logFile := evalOut.txt}

Testing || AlgebraicGeometry.LocallyRingedSpace.restrictStalkIso_hom_eq_germ_apply : ∀ {U : TopCat} (X : AlgebraicGeometry.LocallyRingedSpace) {f : U ⟶ X.toTopCat} (h : IsOpenEmbedding ⇑f)
  (V : TopologicalSpace.Opens ↑U) (x : ↑U) (hx : x ∈ V) (y : ↑((X.restrict h).presheaf.obj (Opposite.op V))),
  (X.restrictStalkIso h x).hom (((X.restrict h).presheaf.germ V x hx) y) = (X.presheaf.germ (⋯.functor.obj V) (f x) ⋯) y
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Module.Quotient.mk_smul_mk : ∀ {R : Type u_1} (M : Type u_2) [inst : CommRing R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (I : Ideal R)
  (r : R) (m : M), (Ideal.Quotient.mk I) r • Submodule.Quotient.mk m = Submodule.Quotient.mk (r • m)
Result.autoException ::
Auto failed to find proof

Testing || BoundedLatticeHom.asBoolRing_id : ∀ {α : Type u_1} [inst : BooleanAlgebra α], (BoundedLatticeHom.id α).asBoolRing = RingHom.id (AsBoolRing α)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _BoundedLatticeHom_α_α:
  ;;   |_BoundedLatticeHom_α_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_BoundedLatticeHom_α_α!val!0| () _BoundedLatticeHom_α_α)
  ;; cardinality constraint:
  (forall ((x _BoundedLatticeHom_α_α)) (= x |_BoundedLatticeHom_α_α!val!0|))
  ;; -----------
  ;; universe for _AsBoolRing_α__+*_AsBoolRing_α:
  ;;   |_AsBoolRing_α__+*_AsBoolRing_α!val!1| |_AsBoolRing_α__+*_AsBoolRing_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_AsBoolRing_α__+*_AsBoolRing_α!val!1| () _AsBoolRing_α__+*_AsBoolRing_α)
  (declare-fun |_AsBoolRing_α__+*_AsBoolRing_α!val!0| () _AsBoolRing_α__+*_AsBoolRing_α)
  ;; cardinality constraint:
  (forall ((x _AsBoolRing_α__+*_AsBoolRing_α))
          (or (= x |_AsBoolRing_α__+*_AsBoolRing_α!val!1|)
              (= x |_AsBoolRing_α__+*_AsBoolRing_α!val!0|)))
  ;; -----------
  (define-fun |_RingHom.id_AsBoolRing_α| () _AsBoolRing_α__+*_AsBoolRing_α
    |_AsBoolRing_α__+*_AsBoolRing_α!val!1|)
  (define-fun valid_fact_0 () Bool
    (not (= (_BoundedLatticeHom.asBoolRing |_BoundedLatticeHom.id_α|)
        |_RingHom.id_AsBoolRing_α|)))
  (define-fun |_BoundedLatticeHom.id_α| () _BoundedLatticeHom_α_α
    |_BoundedLatticeHom_α_α!val!0|)
  (define-fun _BoundedLatticeHom.asBoolRing ((x!0 _BoundedLatticeHom_α_α)) _AsBoolRing_α__+*_AsBoolRing_α
    |_AsBoolRing_α__+*_AsBoolRing_α!val!0|)
)


Testing || ofAdd_list_prod : ∀ {α : Type u_3} [inst : AddMonoid α] (s : List α),
  Multiplicative.ofAdd s.sum = (List.map (⇑Multiplicative.ofAdd) s).prod
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _α___Multiplicative_α:
  ;;   |_α___Multiplicative_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α___Multiplicative_α!val!0| () _α___Multiplicative_α)
  ;; cardinality constraint:
  (forall ((x _α___Multiplicative_α)) (= x |_α___Multiplicative_α!val!0|))
  ;; -----------
  ;; universe for _Multiplicative_α:
  ;;   |_Multiplicative_α!val!2| |_Multiplicative_α!val!0| |_Multiplicative_α!val!1| |_Multiplicative_α!val!3| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Multiplicative_α!val!2| () _Multiplicative_α)
  (declare-fun |_Multiplicative_α!val!0| () _Multiplicative_α)
  (declare-fun |_Multiplicative_α!val!1| () _Multiplicative_α)
  (declare-fun |_Multiplicative_α!val!3| () _Multiplicative_α)
  ;; cardinality constraint:
  (forall ((x _Multiplicative_α))
          (or (= x |_Multiplicative_α!val!2|)
              (= x |_Multiplicative_α!val!0|)
              (= x |_Multiplicative_α!val!1|)
              (= x |_Multiplicative_α!val!3|)))
  ;; -----------
  (define-fun _s () _List_α
    _pl___)
  (define-fun valid_fact_0 () Bool
    (not (= (_DFunLike.coe _Multiplicative.ofAdd (_List.sum _s))
        (_List.prod (_List.map__Multiplicative.ofAdd _s)))))
  (define-fun valid_fact_1 () Bool
    _List.map_fun_a_=>_a_=_id)
  (define-fun _List.map_fun_a_=>_a_=_id () Bool
    true)
  (define-fun _Multiplicative.ofAdd () _α___Multiplicative_α
    |_α___Multiplicative_α!val!0|)
  (define-fun _List.sum ((x!0 _List_α)) _Multiplicative_α
    |_Multiplicative_α!val!0|)
  (define-fun _DFunLike.coe ((x!0 _α___Multiplicative_α)
   (x!1 _Multiplicative_α)) _Multiplicative_α
    |_Multiplicative_α!val!1|)
  (define-fun _List.map__Multiplicative.ofAdd ((x!0 _List_α)) _List_α
    (_List.cons |_Multiplicative_α!val!3| _pl___))
  (define-fun _List.prod ((x!0 _List_α)) _Multiplicative_α
    |_Multiplicative_α!val!2|)
)


Testing || CategoryTheory.HasSheafify.isLeftExact : ∀ {C : Type u₁} {inst : CategoryTheory.Category.{v₁, u₁} C} {J : CategoryTheory.GrothendieckTopology C} {A : Type u₂}
  {inst_1 : CategoryTheory.Category.{v₂, u₂} A} [self : CategoryTheory.HasSheafify J A],
  Nonempty (CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.sheafToPresheaf J A).leftAdjoint)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _CategoryTheory.GrothendieckTopology_C:
  ;;   _CategoryTheory.GrothendieckTopology_C!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _CategoryTheory.GrothendieckTopology_C!val!0 () _CategoryTheory.GrothendieckTopology_C)
  ;; cardinality constraint:
  (forall ((x _CategoryTheory.GrothendieckTopology_C))
          (= x _CategoryTheory.GrothendieckTopology_C!val!0))
  ;; -----------
  ;; universe for _CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A:
  ;;   _CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A!val!0 () _CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A)
  ;; cardinality constraint:
  (forall ((x _CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A))
          (= x
             _CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A!val!0))
  ;; -----------
  ;; universe for _Type__max__max_1__max__max_u₁_u₂__v₁__v₂__u₁_v₂_:
  ;;   |_Type__max__max_1__max__max_u₁_u₂__v₁__v₂__u₁_v₂_!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Type__max__max_1__max__max_u₁_u₂__v₁__v₂__u₁_v₂_!val!0| () _Type__max__max_1__max__max_u₁_u₂__v₁__v₂__u₁_v₂_)
  ;; cardinality constraint:
  (forall ((x _Type__max__max_1__max__max_u₁_u₂__v₁__v₂__u₁_v₂_))
          (= x
             |_Type__max__max_1__max__max_u₁_u₂__v₁__v₂__u₁_v₂_!val!0|))
  ;; -----------
  (define-fun _CategoryTheory.sheafToPresheaf_J_A.leftAdjoint () _CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A
    _CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A!val!0)
  (define-fun valid_fact_0 () Bool
    (_fun_J_=>_CategoryTheory.HasSheafify_J_A _J))
  (define-fun valid_fact_1 () Bool
    (not (_Nonempty (_CategoryTheory.Limits.PreservesFiniteLimits
                  _CategoryTheory.sheafToPresheaf_J_A.leftAdjoint))))
  (define-fun _J () _CategoryTheory.GrothendieckTopology_C
    _CategoryTheory.GrothendieckTopology_C!val!0)
  (define-fun _fun_J_=>_CategoryTheory.HasSheafify_J_A ((x!0
    _CategoryTheory.GrothendieckTopology_C)) Bool
    true)
  (define-fun _CategoryTheory.Limits.PreservesFiniteLimits ((x!0
    _CategoryTheory.Functor_CategoryTheory.Functor_C___A_CategoryTheory.Sheaf_J_A)) _Type__max__max_1__max__max_u₁_u₂__v₁__v₂__u₁_v₂_
    |_Type__max__max_1__max__max_u₁_u₂__v₁__v₂__u₁_v₂_!val!0|)
  (define-fun _Nonempty ((x!0
    _Type__max__max_1__max__max_u₁_u₂__v₁__v₂__u₁_v₂_)) Bool
    false)
)


Testing || MvPolynomial.cardinal_mk_eq_max_lift : ∀ {σ : Type u} {R : Type v} [inst : CommSemiring R] [inst_1 : Nonempty σ] [inst_2 : Nontrivial R],
  Cardinal.mk (MvPolynomial σ R) =
    max (max (Cardinal.lift.{u, v} (Cardinal.mk R)) (Cardinal.lift.{v, u} (Cardinal.mk σ))) Cardinal.aleph0
Result.autoException ::
Auto failed to find proof

Testing || ContinuousMap.Homotopy.apply_one : ∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f₀ f₁ : C(X, Y)}
  (F : f₀.Homotopy f₁) (x : X), F (1, x) = f₁ x
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _f₀.Homotopy_f₁:
  ;;   |_f₀.Homotopy_f₁!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_f₀.Homotopy_f₁!val!0| () _f₀.Homotopy_f₁)
  ;; cardinality constraint:
  (forall ((x _f₀.Homotopy_f₁)) (= x |_f₀.Homotopy_f₁!val!0|))
  ;; -----------
  ;; universe for ___x_//_x___Set.Icc_0_1__:
  ;;   ___x_//_x___Set.Icc_0_1__!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun ___x_//_x___Set.Icc_0_1__!val!0 () ___x_//_x___Set.Icc_0_1__)
  ;; cardinality constraint:
  (forall ((x ___x_//_x___Set.Icc_0_1__)) (= x ___x_//_x___Set.Icc_0_1__!val!0))
  ;; -----------
  ;; universe for _X:
  ;;   _X!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _X!val!0 () _X)
  ;; cardinality constraint:
  (forall ((x _X)) (= x _X!val!0))
  ;; -----------
  ;; universe for _Y:
  ;;   _Y!val!0 _Y!val!1 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _Y!val!0 () _Y)
  (declare-fun _Y!val!1 () _Y)
  ;; cardinality constraint:
  (forall ((x _Y)) (or (= x _Y!val!0) (= x _Y!val!1)))
  ;; -----------
  ;; universe for _C_X__Y_:
  ;;   _C_X__Y_!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _C_X__Y_!val!0 () _C_X__Y_)
  ;; cardinality constraint:
  (forall ((x _C_X__Y_)) (= x _C_X__Y_!val!0))
  ;; -----------
  (define-fun |_f₁| () _C_X__Y_
    _C_X__Y_!val!0)
  (define-fun _x () _X
    _X!val!0)
  (define-fun valid_fact_0 () Bool
    (not (= (_DFunLike.coe _F (_Prod.mk _1_ _x)) (_DFunLike.coe_0 |_f₁| _x))))
  (define-fun _1_ () ___x_//_x___Set.Icc_0_1__
    ___x_//_x___Set.Icc_0_1__!val!0)
  (define-fun _F () _f₀.Homotopy_f₁
    |_f₀.Homotopy_f₁!val!0|)
  (define-fun _DFunLike.coe_0 ((x!0 _C_X__Y_) (x!1 _X)) _Y
    _Y!val!1)
  (define-fun _DFunLike.coe ((x!0 _f₀.Homotopy_f₁)
   (x!1 ___x_//_x___Set.Icc_0_1_____X)) _Y
    _Y!val!0)
)


Testing || Asymptotics.IsBigOWith.const_mul_right : ∀ {α : Type u_1} {E : Type u_3} {𝕜 : Type u_15} [inst : Norm E] [inst_1 : NormedDivisionRing 𝕜] {f : α → E}
  {l : Filter α} {g : α → 𝕜} {c : 𝕜},
  c ≠ 0 →
    ∀ {c' : ℝ}, 0 ≤ c' → Asymptotics.IsBigOWith c' l f g → Asymptotics.IsBigOWith (c' * ‖c‖⁻¹) l f fun x => c * g x
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _pl___0:
  ;;   _pl___0!val!1 _pl___0!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _pl___0!val!1 () _pl___0)
  (declare-fun _pl___0!val!0 () _pl___0)
  ;; cardinality constraint:
  (forall ((x _pl___0)) (or (= x _pl___0!val!1) (= x _pl___0!val!0)))
  ;; -----------
  ;; universe for _CauSeq.Completion.Cauchy_abs:
  ;;   _CauSeq.Completion.Cauchy_abs!val!3 _CauSeq.Completion.Cauchy_abs!val!0 _CauSeq.Completion.Cauchy_abs!val!1 _CauSeq.Completion.Cauchy_abs!val!4 _CauSeq.Completion.Cauchy_abs!val!5 _CauSeq.Completion.Cauchy_abs!val!2 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _CauSeq.Completion.Cauchy_abs!val!3 () _CauSeq.Completion.Cauchy_abs)
  (declare-fun _CauSeq.Completion.Cauchy_abs!val!0 () _CauSeq.Completion.Cauchy_abs)
  (declare-fun _CauSeq.Completion.Cauchy_abs!val!1 () _CauSeq.Completion.Cauchy_abs)
  (declare-fun _CauSeq.Completion.Cauchy_abs!val!4 () _CauSeq.Completion.Cauchy_abs)
  (declare-fun _CauSeq.Completion.Cauchy_abs!val!5 () _CauSeq.Completion.Cauchy_abs)
  (declare-fun _CauSeq.Completion.Cauchy_abs!val!2 () _CauSeq.Completion.Cauchy_abs)
  ;; cardinality constraint:
  (forall ((x _CauSeq.Completion.Cauchy_abs))
          (or (= x _CauSeq.Completion.Cauchy_abs!val!3)
              (= x _CauSeq.Completion.Cauchy_abs!val!0)
              (= x _CauSeq.Completion.Cauchy_abs!val!1)
              (= x _CauSeq.Completion.Cauchy_abs!val!4)
              (= x _CauSeq.Completion.Cauchy_abs!val!5)
              (= x _CauSeq.Completion.Cauchy_abs!val!2)))
  ;; -----------
  ;; universe for _Filter_α:
  ;;   |_Filter_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Filter_α!val!0| () _Filter_α)
  ;; cardinality constraint:
  (forall ((x _Filter_α)) (= x |_Filter_α!val!0|))
  ;; -----------
  (define-fun _c () _pl___0
    _pl___0!val!0)
  (define-fun valid_fact_5 () Bool
    (forall ((_pl___3 _pl__) (_pl___4 _pl__) (_f_0 _Filter_α))
  (or (not (_LE.le _0__0 _pl___3))
      (_fun_c_l_=>_Asymptotics.IsBigOWith_l_c_f_g
        (_HMul.hMul _pl___3 _pl___4)
        _f_0)
      (not (_fun_c_1_l_=>_Asymptotics.IsBigOWith_l_c_1_fun_x_=>_c_*_g_x_g
             _pl___4
             _f_0))
      (not (_fun_c_1_l_=>_Asymptotics.IsBigOWith_l_c_1_f_fun_x_=>_c_*_g_x
             _pl___3
             _f_0)))))
  (define-fun valid_fact_3 () Bool
    (let ((a!1 (_fun_c_1_l_=>_Asymptotics.IsBigOWith_l_c_1_f_fun_x_=>_c_*_g_x
             (_HMul.hMul _c_ (_Inv.inv (_norm _c)))
             _l)))
  (not a!1)))
  (define-fun _0_ () _pl___0
    _pl___0!val!1)
  (define-fun valid_fact_4 () Bool
    (forall ((_pl___1 _pl__) (_pl___2 _pl__) (_f _Filter_α))
  (or (_fun_c_1_l_=>_Asymptotics.IsBigOWith_l_c_1_f_fun_x_=>_c_*_g_x
        (_HMul.hMul _pl___1 _pl___2)
        _f)
      (not (_LE.le _0__0 _pl___1))
      (not (_fun_c_1_l_=>_Asymptotics.IsBigOWith_l_c_1_g_fun_x_=>_c_*_g_x
             _pl___2
             _f))
      (not (_fun_c_l_=>_Asymptotics.IsBigOWith_l_c_f_g _pl___1 _f)))))
  (define-fun valid_fact_2 () Bool
    (_fun_c_l_=>_Asymptotics.IsBigOWith_l_c_f_g _c_ _l))
  (define-fun valid_fact_1 () Bool
    (_LE.le _0__0 _c_))
  (define-fun _c_ () _pl__
    (_Real.ofCauchy _CauSeq.Completion.Cauchy_abs!val!1))
  (define-fun _l () _Filter_α
    |_Filter_α!val!0|)
  (define-fun valid_fact_0 () Bool
    (not (= _c _0_)))
  (define-fun valid_fact_6 () Bool
    (forall ((_pl___5 _pl__) (_pl___6 _pl__) (_f_1 _Filter_α))
  (or (not (_LE.le _0__0 _pl___5))
      (_fun_c_1_l_=>_Asymptotics.IsBigOWith_l_c_1_g_fun_x_=>_c_*_g_x
        (_HMul.hMul _pl___5 _pl___6)
        _f_1)
      (not (_fun_c_1_l_=>_Asymptotics.IsBigOWith_l_c_1_f_fun_x_=>_c_*_g_x
             _pl___6
             _f_1))
      (not (_fun_c_l_=>_Asymptotics.IsBigOWith_l_c_g_f _pl___5 _f_1)))))
  (define-fun _0__0 () _pl__
    (_Real.ofCauchy _CauSeq.Completion.Cauchy_abs!val!0))
  (define-fun _fun_c_1_l_=>_Asymptotics.IsBigOWith_l_c_1_g_fun_x_=>_c_*_g_x ((x!0
    _pl__)
   (x!1 _Filter_α)) Bool
    false)
  (define-fun _fun_c_l_=>_Asymptotics.IsBigOWith_l_c_g_f ((x!0 _pl__)
   (x!1 _Filter_α)) Bool
    false)
  (define-fun _LE.le ((x!0 _pl__) (x!1 _pl__)) Bool
    (and (= x!0 (_Real.ofCauchy _CauSeq.Completion.Cauchy_abs!val!0))
         (not (= x!1 (_Real.ofCauchy _CauSeq.Completion.Cauchy_abs!val!4)))
         (not (= x!1 (_Real.ofCauchy _CauSeq.Completion.Cauchy_abs!val!3)))))
  (define-fun _fun_c_1_l_=>_Asymptotics.IsBigOWith_l_c_1_f_fun_x_=>_c_*_g_x ((x!0
    _pl__)
   (x!1 _Filter_α)) Bool
    false)
  (define-fun _fun_c_1_l_=>_Asymptotics.IsBigOWith_l_c_1_fun_x_=>_c_*_g_x_g ((x!0
    _pl__)
   (x!1 _Filter_α)) Bool
    false)
  (define-fun _HMul.hMul ((x!0 _pl__) (x!1 _pl__)) _pl__
    (let ((a!1 (and (not (= x!0
                            (_Real.ofCauchy _CauSeq.Completion.Cauchy_abs!val!4)))
                    (not (= x!0
                            (_Real.ofCauchy _CauSeq.Completion.Cauchy_abs!val!3)))
                    (= x!1 (_Real.ofCauchy _CauSeq.Completion.Cauchy_abs!val!3)))))
      (ite a!1
           (_Real.ofCauchy _CauSeq.Completion.Cauchy_abs!val!4)
           (_Real.ofCauchy _CauSeq.Completion.Cauchy_abs!val!5))))
  (define-fun _norm ((x!0 _pl___0)) _pl__
    (_Real.ofCauchy _CauSeq.Completion.Cauchy_abs!val!2))
  (define-fun _Inv.inv ((x!0 _pl__)) _pl__
    (_Real.ofCauchy _CauSeq.Completion.Cauchy_abs!val!3))
  (define-fun _fun_c_l_=>_Asymptotics.IsBigOWith_l_c_f_g ((x!0 _pl__)
   (x!1 _Filter_α)) Bool
    (and (not (= x!0 (_Real.ofCauchy _CauSeq.Completion.Cauchy_abs!val!4)))
         (not (= x!0 (_Real.ofCauchy _CauSeq.Completion.Cauchy_abs!val!3)))))
)


Testing || CategoryTheory.GradedObject.TriangleIndexData.hp₁₂ : ∀ {I₁ : Type u_1} {I₂ : Type u_2} {I₃ : Type u_3} {J : Type u_4} [inst : Zero I₂] {r : I₁ × I₂ × I₃ → J}
  {π : I₁ × I₃ → J} (self : CategoryTheory.GradedObject.TriangleIndexData r π) (i : I₁ × I₂ × I₃),
  π (self.p₁₂ (i.1, i.2.1), i.2.2) = r i
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _CategoryTheory.GradedObject.TriangleIndexData_r_π:
  ;;   |_CategoryTheory.GradedObject.TriangleIndexData_r_π!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_CategoryTheory.GradedObject.TriangleIndexData_r_π!val!0| () _CategoryTheory.GradedObject.TriangleIndexData_r_π)
  ;; cardinality constraint:
  (forall ((x _CategoryTheory.GradedObject.TriangleIndexData_r_π))
          (= x |_CategoryTheory.GradedObject.TriangleIndexData_r_π!val!0|))
  ;; -----------
  ;; universe for _I₂:
  ;;   |_I₂!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_I₂!val!0| () _I₂)
  ;; cardinality constraint:
  (forall ((x _I₂)) (= x |_I₂!val!0|))
  ;; -----------
  ;; universe for _I₃:
  ;;   |_I₃!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_I₃!val!0| () _I₃)
  ;; cardinality constraint:
  (forall ((x _I₃)) (= x |_I₃!val!0|))
  ;; -----------
  ;; universe for _I₁:
  ;;   |_I₁!val!1| |_I₁!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_I₁!val!1| () _I₁)
  (declare-fun |_I₁!val!0| () _I₁)
  ;; cardinality constraint:
  (forall ((x _I₁)) (or (= x |_I₁!val!1|) (= x |_I₁!val!0|)))
  ;; -----------
  ;; universe for _J:
  ;;   _J!val!0 _J!val!1 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _J!val!0 () _J)
  (declare-fun _J!val!1 () _J)
  ;; cardinality constraint:
  (forall ((x _J)) (or (= x _J!val!0) (= x _J!val!1)))
  ;; -----------
  (define-fun valid_fact_0 () Bool
    (let ((a!1 (|_CategoryTheory.GradedObject.TriangleIndexData.p₁₂|
             _self
             (_Prod.mk (_Prod.fst_1 _i) (_Prod.fst_0 (_Prod.snd_1 _i))))))
(let ((a!2 (|_π| (_Prod.mk_2 a!1 (_Prod.snd_0 (_Prod.snd_1 _i))))))
  (not (= a!2 (_r _i))))))
  (define-fun _i () _I₁___I₂___I₃
    (_Prod.mk_1 |_I₁!val!0| (_Prod.mk_0 |_I₂!val!0| |_I₃!val!0|)))
  (define-fun _self () _CategoryTheory.GradedObject.TriangleIndexData_r_π
    |_CategoryTheory.GradedObject.TriangleIndexData_r_π!val!0|)
  (define-fun _r ((x!0 _I₁___I₂___I₃)) _J
    _J!val!1)
  (define-fun |_CategoryTheory.GradedObject.TriangleIndexData.p₁₂| ((x!0
    _CategoryTheory.GradedObject.TriangleIndexData_r_π)
   (x!1 _I₁___I₂)) _I₁
    |_I₁!val!1|)
  (define-fun |_π| ((x!0 _I₁___I₃)) _J
    _J!val!0)
)


Testing || Matrix.toEuclideanLin_piLp_equiv_symm : ∀ {𝕜 : Type u_3} [inst : RCLike 𝕜] {m : Type u_8} {n : Type u_9} [inst_1 : Fintype n] [inst_2 : DecidableEq n]
  (A : Matrix m n 𝕜) (x : n → 𝕜),
  (Matrix.toEuclideanLin A) ((WithLp.equiv 2 ((i : n) → (fun x => 𝕜) i)).symm x) =
    (WithLp.equiv 2 (m → 𝕜)).symm ((Matrix.toLin' A) x)
Result.autoException ::
Auto failed to find proof

Testing || CoalgebraCat.of_isAddCommGroup : ∀ (R : Type u) [inst : CommRing R] (X : Type v) [inst_1 : AddCommGroup X] [inst_2 : Module R X]
  [inst_3 : Coalgebra R X], (CoalgebraCat.of R X).isAddCommGroup = inst_1
Result.autoException ::
Auto.Reif.resolveTy :: Unable to resolve AddCommGroup ↑(CoalgebraCat.of R X).toModuleCat

Testing || ContinuousMultilinearMap.iteratedFDerivComponent_apply : ∀ {𝕜 : Type u} {ι : Type v} {E₁ : ι → Type wE₁} {G : Type wG} [inst : NontriviallyNormedField 𝕜]
  [inst_1 : (i : ι) → SeminormedAddCommGroup (E₁ i)] [inst_2 : (i : ι) → NormedSpace 𝕜 (E₁ i)]
  [inst_3 : SeminormedAddCommGroup G] [inst_4 : NormedSpace 𝕜 G] [inst_5 : Fintype ι] {α : Type u_1}
  [inst_6 : Fintype α] (f : ContinuousMultilinearMap 𝕜 E₁ G) {s : Set ι} (e : α ≃ ↑s)
  [inst_7 : DecidablePred fun x => x ∈ s] (v : (i : { a // a ∉ s }) → E₁ ↑i) (w : α → (i : ι) → E₁ i),
  ((f.iteratedFDerivComponent e) v) w = f fun j => if h : j ∈ s then w (e.symm ⟨j, h⟩) j else v ⟨j, h⟩
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || nontrivial_iff_lt : ∀ {α : Type u_1} [inst : LinearOrder α], Nontrivial α ↔ ∃ x y, x < y
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Type_u_1_:
  ;;   _Type_u_1_!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _Type_u_1_!val!0 () _Type_u_1_)
  ;; cardinality constraint:
  (forall ((x _Type_u_1_)) (= x _Type_u_1_!val!0))
  ;; -----------
  ;; universe for _α_1:
  ;;   |_α_1!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α_1!val!0| () _α_1)
  ;; cardinality constraint:
  (forall ((x _α_1)) (= x |_α_1!val!0|))
  ;; -----------
  (define-fun |_α| () _Type_u_1_
    _Type_u_1_!val!0)
  (define-fun valid_fact_1 () Bool
    (forall ((|_α_3| _α_1) (|_α_4| _α_1))
  (or (_Nontrivial |_α|) (not (_LT.lt |_α_3| |_α_4|)))))
  (define-fun valid_fact_0 () Bool
    (= (not (_Nontrivial |_α|))
   (exists ((|_α_0| _α_1) (|_α_2| _α_1)) (_LT.lt |_α_0| |_α_2|))))
  (define-fun _LT.lt ((x!0 _α_1) (x!1 _α_1)) Bool
    false)
  (define-fun _Nontrivial ((x!0 _Type_u_1_)) Bool
    true)
)


Testing || isUniformInducing_iff_uniformSpace : ∀ {α : Type u} {β : Type v} [inst : UniformSpace α] [inst_1 : UniformSpace β] {f : α → β},
  IsUniformInducing f ↔ UniformSpace.comap f inst_1 = inst
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Filter_β___β:
  ;;   |_Filter_β___β!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Filter_β___β!val!0| () _Filter_β___β)
  ;; cardinality constraint:
  (forall ((x _Filter_β___β)) (= x |_Filter_β___β!val!0|))
  ;; -----------
  ;; universe for _Filter_α___α:
  ;;   |_Filter_α___α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Filter_α___α!val!0| () _Filter_α___α)
  ;; cardinality constraint:
  (forall ((x _Filter_α___α)) (= x |_Filter_α___α!val!0|))
  ;; -----------
  ;; universe for _UniformSpace_α:
  ;;   |_UniformSpace_α!val!1| |_UniformSpace_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_UniformSpace_α!val!1| () _UniformSpace_α)
  (declare-fun |_UniformSpace_α!val!0| () _UniformSpace_α)
  ;; cardinality constraint:
  (forall ((x _UniformSpace_α))
          (or (= x |_UniformSpace_α!val!1|) (= x |_UniformSpace_α!val!0|)))
  ;; -----------
  (define-fun |_uniformity_β| () _Filter_β___β
    |_Filter_β___β!val!0|)
  (define-fun valid_fact_3 () Bool
    true)
  (define-fun valid_fact_2 () Bool
    true)
  (define-fun _UniformSpace.mk_cifvar_7_cifvar_8_cifvar_9_cifvar_10_exfvar_3_ () _UniformSpace_α
    |_UniformSpace_α!val!0|)
  (define-fun valid_fact_4 () Bool
    true)
  (define-fun valid_fact_1 () Bool
    true)
  (define-fun |_uniformity_α| () _Filter_α___α
    |_Filter_α___α!val!0|)
  (define-fun valid_fact_0 () Bool
    (= (not (= (_Filter.comap_fun_p_=>__f_p.1__f_p.2_ |_uniformity_β|)
           |_uniformity_α|))
   (= _UniformSpace.mk_cifvar_7_cifvar_8_cifvar_9_cifvar_10_exfvar_3_
      _inst.116_)))
  (define-fun _inst.116_ () _UniformSpace_α
    |_UniformSpace_α!val!1|)
  (define-fun _inst.119_ () _UniformSpace_β
    |_UniformSpace_β!val!0|)
  (define-fun _Filter.comap_fun_p_=>__f_p.1__f_p.2_ ((x!0 _Filter_β___β)) _Filter_α___α
    |_Filter_α___α!val!0|)
  (define-fun _Membership.mem_0 ((x!0 _Filter_α___α) (x!1 _Set_α___α)) Bool
    false)
  (define-fun _Membership.mem ((x!0 _Filter_β___β) (x!1 _Set_β___β)) Bool
    false)
)


Testing || Ordinal.lt_omega0_opow_succ : ∀ {a b : Ordinal.{u_1}}, a < Ordinal.omega0 ^ Order.succ b ↔ ∃ n, a < Ordinal.omega0 ^ b * ↑n
Result.autoException ::
Auto failed to find proof

Testing || Affine.Simplex.centroid_eq_affineCombination_of_pointsWithCircumcenter : ∀ {V : Type u_1} {P : Type u_2} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [inst_2 : MetricSpace P]
  [inst_3 : NormedAddTorsor V P] {n : ℕ} (s : Affine.Simplex ℝ P n) (fs : Finset (Fin (n + 1))),
  Finset.centroid ℝ fs s.points =
    (Finset.affineCombination ℝ Finset.univ s.pointsWithCircumcenter)
      (Affine.Simplex.centroidWeightsWithCircumcenter fs)
Result.autoException ::
Auto failed to find proof

Testing || List.prod_inv : ∀ {G : Type u_7} [inst : CommGroup G] (L : List G), L.prod⁻¹ = (List.map (fun x => x⁻¹) L).prod
Result.autoException ::
Auto failed to find proof

Testing || Filter.BoundedAtFilter.mul : ∀ {α : Type u_2} {β : Type u_3} [inst : SeminormedRing β] {l : Filter α} {f g : α → β},
  l.BoundedAtFilter f → l.BoundedAtFilter g → l.BoundedAtFilter (f * g)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Filter_α:
  ;;   |_Filter_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Filter_α!val!0| () _Filter_α)
  ;; cardinality constraint:
  (forall ((x _Filter_α)) (= x |_Filter_α!val!0|))
  ;; -----------
  (define-fun valid_fact_2 () Bool
    (not (_fun_l_=>_l.BoundedAtFilter_f_*_g _l)))
  (define-fun valid_fact_0 () Bool
    (_fun_l_=>_l.BoundedAtFilter_f _l))
  (define-fun valid_fact_1 () Bool
    (_fun_l_=>_l.BoundedAtFilter_g _l))
  (define-fun _l () _Filter_α
    |_Filter_α!val!0|)
  (define-fun _fun_l_=>_l.BoundedAtFilter_f_*_g ((x!0 _Filter_α)) Bool
    false)
  (define-fun _fun_l_=>_l.BoundedAtFilter_f ((x!0 _Filter_α)) Bool
    true)
  (define-fun _fun_l_=>_l.BoundedAtFilter_g ((x!0 _Filter_α)) Bool
    true)
)


Testing || connectedComponentIn_mem_nhds : ∀ {α : Type u} [inst : TopologicalSpace α] [inst_1 : LocallyConnectedSpace α] {F : Set α} {x : α},
  F ∈ nhds x → connectedComponentIn F x ∈ nhds x
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `(cifvar_2 x_0).HasBasis
  (fun s => cifvar_9 (cifvar_10 s) (cifvar_9 (cifvar_11 s x_0) (cifvar_12 s))) cifvar_13`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || WithTop.coe_bot : ∀ {α : Type u_1} [inst : Bot α], ↑⊥ = ⊥
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _α:
  ;;   |_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!0| () _α)
  ;; cardinality constraint:
  (forall ((x _α)) (= x |_α!val!0|))
  ;; -----------
  ;; universe for _WithTop_α:
  ;;   |_WithTop_α!val!0| |_WithTop_α!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_WithTop_α!val!0| () _WithTop_α)
  (declare-fun |_WithTop_α!val!1| () _WithTop_α)
  ;; cardinality constraint:
  (forall ((x _WithTop_α))
          (or (= x |_WithTop_α!val!0|) (= x |_WithTop_α!val!1|)))
  ;; -----------
  (define-fun valid_fact_0 () Bool
    (not (= (_WithTop.some _pl__) _pl___0)))
  (define-fun _pl___0 () _WithTop_α
    |_WithTop_α!val!1|)
  (define-fun _pl__ () _α
    |_α!val!0|)
  (define-fun _WithTop.some ((x!0 _α)) _WithTop_α
    |_WithTop_α!val!0|)
)


Testing || Sat.Clause.reify_zero : ∀ {v : Sat.Valuation}, Sat.Clause.reify v Sat.Clause.nil True
Result.autoException ::
Auto failed to find proof

Testing || Ordinal.nadd_one : ∀ (a : Ordinal.{u}), a.nadd 1 = Order.succ a
Result.autoException ::
Auto failed to find proof

Testing || QuotientMap.restrictPreimage_isOpen : ∀ {X : Type u} {Y : Type v} [inst : TopologicalSpace X] [inst_1 : TopologicalSpace Y] {f : X → Y},
  IsQuotientMap f → ∀ {s : Set Y}, IsOpen s → IsQuotientMap (s.restrictPreimage f)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{ x // cifvar_6 (cifvar_7 s) x }`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || Equiv.piCongrLeft_apply : ∀ {α : Sort u_1} {β : Sort u_4} (P : β → Sort w) (e : α ≃ β) (f : (a : α) → P (e a)) (b : β),
  (Equiv.piCongrLeft P e) f b = ⋯ ▸ f (e.symm b)
Result.autoException ::
Auto.Monomorphization.ConstInst.toExpr :: Unexpected error

Testing || RingHom.locally_iff_exists : ∀ {P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → (R →+* S) → Prop} {R S : Type u}
  [inst : CommRing R] [inst_1 : CommRing S],
  (RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P) →
    ∀ (f : R →+* S),
      RingHom.Locally (fun {R S} [CommRing R] [CommRing S] => P) f ↔
        ∃ ι s,
          ∃ (_ : Ideal.span (Set.range s) = ⊤),
            ∃ Sₜ x x_1, ∃ (_ : ∀ (i : ι), IsLocalization.Away (s i) (Sₜ i)), ∀ (i : ι), P ((algebraMap S (Sₜ i)).comp f)
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type CommRing R✝ of λ binder contains bound variables

Testing || OrderIso.refl_toEquiv : ∀ {α : Type u_2} [inst : LE α], (OrderIso.refl α).toEquiv = Equiv.refl α
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_:
  ;;   _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_!val!0 () _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_)
  ;; cardinality constraint:
  (forall ((x _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_))
          (= x _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_!val!0))
  ;; -----------
  ;; universe for _α___α:
  ;;   |_α___α!val!1| |_α___α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α___α!val!1| () _α___α)
  (declare-fun |_α___α!val!0| () _α___α)
  ;; cardinality constraint:
  (forall ((x _α___α)) (or (= x |_α___α!val!1|) (= x |_α___α!val!0|)))
  ;; -----------
  (define-fun valid_fact_0 () Bool
    (not (= (_RelIso.toEquiv |_OrderIso.refl_α|) |_Equiv.refl_α|)))
  (define-fun |_OrderIso.refl_α| () _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_
    _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_!val!0)
  (define-fun |_Equiv.refl_α| () _α___α
    |_α___α!val!1|)
  (define-fun _RelIso.toEquiv ((x!0
    _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_)) _α___α
    |_α___α!val!0|)
)


Testing || OrderIso.smulRightDual_symm_apply : ∀ {α : Type u_1} (β : Type u_2) [inst : LinearOrderedField α] [inst_1 : OrderedAddCommGroup β] [inst_2 : Module α β]
  {a : α} [inst_3 : PosSMulMono α β] (ha : a < 0) (a_1 : βᵒᵈ),
  (RelIso.symm (OrderIso.smulRightDual β ha)) a_1 = a⁻¹ • OrderDual.ofDual a_1
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _α:
  ;;   |_α!val!0| |_α!val!1| |_α!val!2| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!0| () _α)
  (declare-fun |_α!val!1| () _α)
  (declare-fun |_α!val!2| () _α)
  ;; cardinality constraint:
  (forall ((x _α)) (or (= x |_α!val!0|) (= x |_α!val!1|) (= x |_α!val!2|)))
  ;; -----------
  ;; universe for _a_<_0_:
  ;;   _a_<_0_!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _a_<_0_!val!0 () _a_<_0_)
  ;; cardinality constraint:
  (forall ((x _a_<_0_)) (= x _a_<_0_!val!0))
  ;; -----------
  ;; universe for _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_:
  ;;   _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_!val!0 () _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_)
  ;; cardinality constraint:
  (forall ((x _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_))
          (= x _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_!val!0))
  ;; -----------
  ;; universe for _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0:
  ;;   _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0!val!0 () _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0)
  ;; cardinality constraint:
  (forall ((x _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0))
          (= x _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0!val!0))
  ;; -----------
  ;; universe for _β:
  ;;   |_β!val!0| |_β!val!1| |_β!val!2| |_β!val!3| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_β!val!0| () _β)
  (declare-fun |_β!val!1| () _β)
  (declare-fun |_β!val!2| () _β)
  (declare-fun |_β!val!3| () _β)
  ;; cardinality constraint:
  (forall ((x _β))
          (or (= x |_β!val!0|)
              (= x |_β!val!1|)
              (= x |_β!val!2|)
              (= x |_β!val!3|)))
  ;; -----------
  ;; universe for _β_____β:
  ;;   |_β_____β!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_β_____β!val!0| () _β_____β)
  ;; cardinality constraint:
  (forall ((x _β_____β)) (= x |_β_____β!val!0|))
  ;; -----------
  (define-fun valid_fact_2 () Bool
    (let ((a!1 (= (_DFunLike.coe (_RelIso.symm (|_OrderIso.smulRightDual_β| _ha))
                             _a.26_)
              (_HSMul.hSMul (_Inv.inv _a)
                            (_DFunLike.coe_0 _OrderDual.ofDual _a.26_)))))
  (not a!1)))
  (define-fun valid_fact_1 () Bool
    (_LT.lt _a _0_))
  (define-fun |_PosSMulMono_α_β| () Bool
    true)
  (define-fun _0_ () _α
    |_α!val!1|)
  (define-fun _a () _α
    |_α!val!0|)
  (define-fun _a.26_ () _β
    |_β!val!0|)
  (define-fun valid_fact_0 () Bool
    |_PosSMulMono_α_β|)
  (define-fun _OrderDual.ofDual () _β_____β
    |_β_____β!val!0|)
  (define-fun _ha () _a_<_0_
    _a_<_0_!val!0)
  (define-fun _DFunLike.coe_0 ((x!0 _β_____β) (x!1 _β)) _β
    |_β!val!2|)
  (define-fun _RelIso.symm ((x!0 _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_)) _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0
    _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0!val!0)
  (define-fun _LT.lt ((x!0 _α) (x!1 _α)) Bool
    true)
  (define-fun |_OrderIso.smulRightDual_β| ((x!0 _a_<_0_)) _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_
    _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2_!val!0)
  (define-fun _HSMul.hSMul ((x!0 _α) (x!1 _β)) _β
    |_β!val!3|)
  (define-fun _DFunLike.coe ((x!0
    _fun_x1_x2_=>_x1___x2__r_fun_x1_x2_=>_x1___x2__0)
   (x!1 _β)) _β
    |_β!val!1|)
  (define-fun _Inv.inv ((x!0 _α)) _α
    |_α!val!2|)
)


Testing || NormedAddGroupHom.completion_id : ∀ {G : Type u_1} [inst : SeminormedAddCommGroup G],
  (NormedAddGroupHom.id G).completion = NormedAddGroupHom.id (UniformSpace.Completion G)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `UniformSpace.Completion.map
  (cifvar_11 x_0) x_1`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || AlgebraicGeometry.LocallyRingedSpace.HasCoequalizer.imageBasicOpen_image_preimage : ∀ {X Y : AlgebraicGeometry.LocallyRingedSpace} (f g : X ⟶ Y)
  (U :
    TopologicalSpace.Opens
      ↑↑(CategoryTheory.Limits.coequalizer (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom f)
              (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom g)).toPresheafedSpace)
  (s :
    ↑((CategoryTheory.Limits.coequalizer (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom f)
              (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom g)).presheaf.obj
        (Opposite.op U))),
  ⇑(CategoryTheory.Limits.coequalizer.π (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom f)
            (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom g)).base ⁻¹'
      (⇑(CategoryTheory.Limits.coequalizer.π (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom f)
              (AlgebraicGeometry.LocallyRingedSpace.Hom.toShHom g)).base ''
        (AlgebraicGeometry.LocallyRingedSpace.HasCoequalizer.imageBasicOpen f g U s).carrier) =
    (AlgebraicGeometry.LocallyRingedSpace.HasCoequalizer.imageBasicOpen f g U s).carrier
Result.autoException ::
(deterministic) timeout at `isDefEq`, maximum number of heartbeats (65536) has been reached
Use `set_option maxHeartbeats <num>` to set the limit.(invalid MessageData.lazy, missing context)

Testing || Finset.max_of_mem : ∀ {α : Type u_2} [inst : LinearOrder α] {s : Finset α} {a : α}, a ∈ s → ∃ b, s.max = ↑b
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Finset_α:
  ;;   |_Finset_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Finset_α!val!0| () _Finset_α)
  ;; cardinality constraint:
  (forall ((x _Finset_α)) (= x |_Finset_α!val!0|))
  ;; -----------
  ;; universe for _α:
  ;;   |_α!val!1| |_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!1| () _α)
  (declare-fun |_α!val!0| () _α)
  ;; cardinality constraint:
  (forall ((x _α)) (or (= x |_α!val!1|) (= x |_α!val!0|)))
  ;; -----------
  ;; universe for _WithBot_α:
  ;;   |_WithBot_α!val!0| |_WithBot_α!val!1| |_WithBot_α!val!2| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_WithBot_α!val!0| () _WithBot_α)
  (declare-fun |_WithBot_α!val!1| () _WithBot_α)
  (declare-fun |_WithBot_α!val!2| () _WithBot_α)
  ;; cardinality constraint:
  (forall ((x _WithBot_α))
          (or (= x |_WithBot_α!val!0|)
              (= x |_WithBot_α!val!1|)
              (= x |_WithBot_α!val!2|)))
  ;; -----------
  (define-fun valid_fact_0 () Bool
    (_Membership.mem _s _a))
  (define-fun _a () _α
    |_α!val!0|)
  (define-fun valid_fact_1 () Bool
    (not (exists ((|_α_0| _α)) (= (_Finset.max _s) (_WithBot.some |_α_0|)))))
  (define-fun _s () _Finset_α
    |_Finset_α!val!0|)
  (define-fun _WithBot.some ((x!0 _α)) _WithBot_α
    |_WithBot_α!val!1|)
  (define-fun _Membership.mem ((x!0 _Finset_α) (x!1 _α)) Bool
    true)
  (define-fun _Finset.max ((x!0 _Finset_α)) _WithBot_α
    |_WithBot_α!val!0|)
)


Testing || tendsto_integral_exp_smul_cocompact : ∀ {E : Type u_1} {V : Type u_2} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ℂ E] (f : V → E)
  [inst_2 : AddCommGroup V] [inst_3 : TopologicalSpace V] [inst_4 : TopologicalAddGroup V] [inst_5 : T2Space V]
  [inst_6 : MeasurableSpace V] [inst_7 : BorelSpace V] [inst_8 : Module ℝ V] [inst_9 : ContinuousSMul ℝ V]
  [inst_10 : FiniteDimensional ℝ V] (μ : MeasureTheory.Measure V) [inst_11 : μ.IsAddHaarMeasure],
  Filter.Tendsto (fun w => ∫ (v : V), Real.fourierChar (-w v) • f v ∂μ) (Filter.cocompact (V →L[ℝ] ℝ)) (nhds 0)
Result.autoException ::
Auto failed to find proof

Testing || Odd.zpow_neg_iff : ∀ {α : Type u_1} [inst : LinearOrderedField α] {a : α} {n : ℤ}, Odd n → (a ^ n < 0 ↔ a < 0)
Result.autoException ::
Auto failed to find proof

Testing || Matrix.mul_kronecker_mul : ∀ {α : Type u_2} {l : Type u_8} {m : Type u_9} {n : Type u_10} {l' : Type u_14} {m' : Type u_15} {n' : Type u_16}
  [inst : Fintype m] [inst_1 : Fintype m'] [inst_2 : CommSemiring α] (A : Matrix l m α) (B : Matrix m n α)
  (A' : Matrix l' m' α) (B' : Matrix m' n' α),
  Matrix.kroneckerMap (fun x1 x2 => x1 * x2) (A * B) (A' * B') =
    Matrix.kroneckerMap (fun x1 x2 => x1 * x2) A A' * Matrix.kroneckerMap (fun x1 x2 => x1 * x2) B B'
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Matrix_l_m_α:
  ;;   |_Matrix_l_m_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Matrix_l_m_α!val!0| () _Matrix_l_m_α)
  ;; cardinality constraint:
  (forall ((x _Matrix_l_m_α)) (= x |_Matrix_l_m_α!val!0|))
  ;; -----------
  ;; universe for _Matrix_m_n_α:
  ;;   |_Matrix_m_n_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Matrix_m_n_α!val!0| () _Matrix_m_n_α)
  ;; cardinality constraint:
  (forall ((x _Matrix_m_n_α)) (= x |_Matrix_m_n_α!val!0|))
  ;; -----------
  ;; universe for _Matrix_l_n_α:
  ;;   |_Matrix_l_n_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Matrix_l_n_α!val!0| () _Matrix_l_n_α)
  ;; cardinality constraint:
  (forall ((x _Matrix_l_n_α)) (= x |_Matrix_l_n_α!val!0|))
  ;; -----------
  ;; universe for _Matrix_l__m__α:
  ;;   |_Matrix_l__m__α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Matrix_l__m__α!val!0| () _Matrix_l__m__α)
  ;; cardinality constraint:
  (forall ((x _Matrix_l__m__α)) (= x |_Matrix_l__m__α!val!0|))
  ;; -----------
  ;; universe for _Matrix_m__n__α:
  ;;   |_Matrix_m__n__α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Matrix_m__n__α!val!0| () _Matrix_m__n__α)
  ;; cardinality constraint:
  (forall ((x _Matrix_m__n__α)) (= x |_Matrix_m__n__α!val!0|))
  ;; -----------
  ;; universe for _Matrix_l__n__α:
  ;;   |_Matrix_l__n__α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Matrix_l__n__α!val!0| () _Matrix_l__n__α)
  ;; cardinality constraint:
  (forall ((x _Matrix_l__n__α)) (= x |_Matrix_l__n__α!val!0|))
  ;; -----------
  ;; universe for _Matrix_l___l__n___n__α:
  ;;   |_Matrix_l___l__n___n__α!val!0| |_Matrix_l___l__n___n__α!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Matrix_l___l__n___n__α!val!0| () _Matrix_l___l__n___n__α)
  (declare-fun |_Matrix_l___l__n___n__α!val!1| () _Matrix_l___l__n___n__α)
  ;; cardinality constraint:
  (forall ((x _Matrix_l___l__n___n__α))
          (or (= x |_Matrix_l___l__n___n__α!val!0|)
              (= x |_Matrix_l___l__n___n__α!val!1|)))
  ;; -----------
  ;; universe for _Matrix_l___l__m___m__α:
  ;;   |_Matrix_l___l__m___m__α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Matrix_l___l__m___m__α!val!0| () _Matrix_l___l__m___m__α)
  ;; cardinality constraint:
  (forall ((x _Matrix_l___l__m___m__α)) (= x |_Matrix_l___l__m___m__α!val!0|))
  ;; -----------
  ;; universe for _Matrix_m___m__n___n__α:
  ;;   |_Matrix_m___m__n___n__α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Matrix_m___m__n___n__α!val!0| () _Matrix_m___m__n___n__α)
  ;; cardinality constraint:
  (forall ((x _Matrix_m___m__n___n__α)) (= x |_Matrix_m___m__n___n__α!val!0|))
  ;; -----------
  ;; universe for _α_0:
  ;;   |_α_0!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α_0!val!0| () _α_0)
  ;; cardinality constraint:
  (forall ((x _α_0)) (= x |_α_0!val!0|))
  ;; -----------
  (define-fun _B () _Matrix_m_n_α
    |_Matrix_m_n_α!val!0|)
  (define-fun _A () _Matrix_l_m_α
    |_Matrix_l_m_α!val!0|)
  (define-fun _A_ () _Matrix_l__m__α
    |_Matrix_l__m__α!val!0|)
  (define-fun _B_ () _Matrix_m__n__α
    |_Matrix_m__n__α!val!0|)
  (define-fun valid_fact_1 () Bool
    (forall ((|_α| _α_0) (|_α_1| _α_0) (|_α_2| _α_0) (|_α_3| _α_0))
  (= (_HMul.hMul_2 (_HMul.hMul_2 |_α| |_α_1|) (_HMul.hMul_2 |_α_2| |_α_3|))
     (_HMul.hMul_2 (_HMul.hMul_2 |_α| |_α_2|) (_HMul.hMul_2 |_α_1| |_α_3|)))))
  (define-fun valid_fact_0 () Bool
    (not (= (_Matrix.kroneckerMap_fun_x1_x2_=>_x1_*_x2_
          (_HMul.hMul _A _B)
          (_HMul.hMul_0 _A_ _B_))
        (_HMul.hMul_1 (_Matrix.kroneckerMap_fun_x1_x2_=>_x1_*_x2__0 _A _A_)
                      (_Matrix.kroneckerMap_fun_x1_x2_=>_x1_*_x2__1 _B _B_)))))
  (define-fun _Matrix.kroneckerMap_fun_x1_x2_=>_x1_*_x2__0 ((x!0 _Matrix_l_m_α)
   (x!1 _Matrix_l__m__α)) _Matrix_l___l__m___m__α
    |_Matrix_l___l__m___m__α!val!0|)
  (define-fun _HMul.hMul_2 ((x!0 _α_0) (x!1 _α_0)) _α_0
    |_α_0!val!0|)
  (define-fun _Matrix.kroneckerMap_fun_x1_x2_=>_x1_*_x2_ ((x!0 _Matrix_l_n_α)
   (x!1 _Matrix_l__n__α)) _Matrix_l___l__n___n__α
    |_Matrix_l___l__n___n__α!val!0|)
  (define-fun _HMul.hMul_0 ((x!0 _Matrix_l__m__α) (x!1 _Matrix_m__n__α)) _Matrix_l__n__α
    |_Matrix_l__n__α!val!0|)
  (define-fun _HMul.hMul_1 ((x!0 _Matrix_l___l__m___m__α)
   (x!1 _Matrix_m___m__n___n__α)) _Matrix_l___l__n___n__α
    |_Matrix_l___l__n___n__α!val!1|)
  (define-fun _Matrix.kroneckerMap_fun_x1_x2_=>_x1_*_x2__1 ((x!0 _Matrix_m_n_α)
   (x!1 _Matrix_m__n__α)) _Matrix_m___m__n___n__α
    |_Matrix_m___m__n___n__α!val!0|)
  (define-fun _HMul.hMul ((x!0 _Matrix_l_m_α) (x!1 _Matrix_m_n_α)) _Matrix_l_n_α
    |_Matrix_l_n_α!val!0|)
)


Testing || Finset.sum_card_inter_le : ∀ {α : Type u_2} [inst : DecidableEq α] {s : Finset α} {B : Finset (Finset α)} {n : ℕ},
  (∀ a ∈ s, (Finset.filter (fun b => a ∈ b) B).card ≤ n) → ∑ t ∈ B, (s ∩ t).card ≤ s.card * n
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Finset.decidableMem x_0 a`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || Finset.div_def : ∀ {α : Type u_2} [inst : DecidableEq α] [inst_1 : Div α] {s t : Finset α},
  s / t = Finset.image (fun p => p.1 / p.2) (s ×ˢ t)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Finset_α:
  ;;   |_Finset_α!val!1| |_Finset_α!val!3| |_Finset_α!val!0| |_Finset_α!val!2| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Finset_α!val!1| () _Finset_α)
  (declare-fun |_Finset_α!val!3| () _Finset_α)
  (declare-fun |_Finset_α!val!0| () _Finset_α)
  (declare-fun |_Finset_α!val!2| () _Finset_α)
  ;; cardinality constraint:
  (forall ((x _Finset_α))
          (or (= x |_Finset_α!val!1|)
              (= x |_Finset_α!val!3|)
              (= x |_Finset_α!val!0|)
              (= x |_Finset_α!val!2|)))
  ;; -----------
  ;; universe for _Finset_α___α:
  ;;   |_Finset_α___α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Finset_α___α!val!0| () _Finset_α___α)
  ;; cardinality constraint:
  (forall ((x _Finset_α___α)) (= x |_Finset_α___α!val!0|))
  ;; -----------
  (define-fun _s () _Finset_α
    |_Finset_α!val!0|)
  (define-fun valid_fact_0 () Bool
    (not (= (_HDiv.hDiv _s _t)
        (_Finset.image_fun_p_=>_p.1_/_p.2_ (_SProd.sprod _s _t)))))
  (define-fun _t () _Finset_α
    |_Finset_α!val!1|)
  (define-fun _HDiv.hDiv ((x!0 _Finset_α) (x!1 _Finset_α)) _Finset_α
    |_Finset_α!val!2|)
  (define-fun _SProd.sprod ((x!0 _Finset_α) (x!1 _Finset_α)) _Finset_α___α
    |_Finset_α___α!val!0|)
  (define-fun _Finset.image_fun_p_=>_p.1_/_p.2_ ((x!0 _Finset_α___α)) _Finset_α
    |_Finset_α!val!3|)
)


Testing || Set.inter_sub_union_subset_union : ∀ {α : Type u_2} [inst : Sub α] {s₁ s₂ t₁ t₂ : Set α}, s₁ ∩ s₂ - (t₁ ∪ t₂) ⊆ s₁ - t₁ ∪ (s₂ - t₂)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Set_α:
  ;;   |_Set_α!val!1| |_Set_α!val!5| |_Set_α!val!8| |_Set_α!val!3| |_Set_α!val!0| |_Set_α!val!7| |_Set_α!val!9| |_Set_α!val!2| |_Set_α!val!4| |_Set_α!val!6| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_α!val!1| () _Set_α)
  (declare-fun |_Set_α!val!5| () _Set_α)
  (declare-fun |_Set_α!val!8| () _Set_α)
  (declare-fun |_Set_α!val!3| () _Set_α)
  (declare-fun |_Set_α!val!0| () _Set_α)
  (declare-fun |_Set_α!val!7| () _Set_α)
  (declare-fun |_Set_α!val!9| () _Set_α)
  (declare-fun |_Set_α!val!2| () _Set_α)
  (declare-fun |_Set_α!val!4| () _Set_α)
  (declare-fun |_Set_α!val!6| () _Set_α)
  ;; cardinality constraint:
  (forall ((x _Set_α))
          (or (= x |_Set_α!val!1|)
              (= x |_Set_α!val!5|)
              (= x |_Set_α!val!8|)
              (= x |_Set_α!val!3|)
              (= x |_Set_α!val!0|)
              (= x |_Set_α!val!7|)
              (= x |_Set_α!val!9|)
              (= x |_Set_α!val!2|)
              (= x |_Set_α!val!4|)
              (= x |_Set_α!val!6|)))
  ;; -----------
  (define-fun |_s₁| () _Set_α
    |_Set_α!val!0|)
  (define-fun valid_fact_0 () Bool
    (not (_Subset (_HSub.hSub (_Inter.inter |_s₁| |_s₂|)
                          (_Union.union |_t₁| |_t₂|))
              (_Union.union (_HSub.hSub |_s₁| |_t₁|)
                            (_HSub.hSub |_s₂| |_t₂|)))))
  (define-fun |_s₂| () _Set_α
    |_Set_α!val!1|)
  (define-fun |_t₁| () _Set_α
    |_Set_α!val!3|)
  (define-fun |_t₂| () _Set_α
    |_Set_α!val!4|)
  (define-fun _HSub.hSub ((x!0 _Set_α) (x!1 _Set_α)) _Set_α
    (ite (and (= x!0 |_Set_α!val!0|) (= x!1 |_Set_α!val!3|)) |_Set_α!val!7|
    (ite (and (= x!0 |_Set_α!val!1|) (= x!1 |_Set_α!val!4|)) |_Set_α!val!8|
      |_Set_α!val!6|)))
  (define-fun _Subset ((x!0 _Set_α) (x!1 _Set_α)) Bool
    false)
  (define-fun _Union.union ((x!0 _Set_α) (x!1 _Set_α)) _Set_α
    (ite (and (= x!0 |_Set_α!val!7|) (= x!1 |_Set_α!val!8|)) |_Set_α!val!9|
      |_Set_α!val!5|))
  (define-fun _Inter.inter ((x!0 _Set_α) (x!1 _Set_α)) _Set_α
    |_Set_α!val!2|)
)


Testing || Orientation.oangle_sub_right_eq_arccos_of_oangle_eq_pi_div_two : ∀ {V : Type u_1} [inst : NormedAddCommGroup V] [inst_1 : InnerProductSpace ℝ V] [hd2 : Fact (Module.finrank ℝ V = 2)]
  (o : Orientation ℝ V (Fin 2)) {x y : V},
  o.oangle x y = ↑(Real.pi / 2) → o.oangle y (y - x) = ↑(Real.arccos (‖y‖ / ‖y - x‖))
Result.success

Testing || MulAction.isInvariantBlock_iff_isFixedBlock : ∀ {G : Type u_1} [inst : Group G] {X : Type u_2} [inst_1 : MulAction G X] {B : Set X},
  MulAction.IsInvariantBlock G B ↔ MulAction.IsFixedBlock G B
Result.autoException ::
Auto failed to find proof

Testing || WithTop.ofNat_eq_coe : ∀ {α : Type u} [inst : AddMonoidWithOne α] (n : ℕ) [inst_1 : n.AtLeastTwo] (m : α),
  OfNat.ofNat n = ↑m ↔ OfNat.ofNat n = m
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _α:
  ;;   |_α!val!1| |_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!1| () _α)
  (declare-fun |_α!val!0| () _α)
  ;; cardinality constraint:
  (forall ((x _α)) (or (= x |_α!val!1|) (= x |_α!val!0|)))
  ;; -----------
  ;; universe for _WithTop_α:
  ;;   |_WithTop_α!val!0| |_WithTop_α!val!1| |_WithTop_α!val!2| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_WithTop_α!val!0| () _WithTop_α)
  (declare-fun |_WithTop_α!val!1| () _WithTop_α)
  (declare-fun |_WithTop_α!val!2| () _WithTop_α)
  ;; cardinality constraint:
  (forall ((x _WithTop_α))
          (or (= x |_WithTop_α!val!0|)
              (= x |_WithTop_α!val!1|)
              (= x |_WithTop_α!val!2|)))
  ;; -----------
  (define-fun valid_fact_2 () Bool
    (forall ((|_α_0| _α) (|_α_1| _α))
  (= (= (_WithTop.some |_α_0|) (_WithTop.some |_α_1|)) (= |_α_0| |_α_1|))))
  (define-fun valid_fact_1 () Bool
    (= (not (= _OfNat.ofNat_n (_WithTop.some _m))) (= _OfNat.ofNat_n_0 _m)))
  (define-fun _m () _α
    |_α!val!0|)
  (define-fun _n () Int
    0)
  (define-fun _OfNat.ofNat_n () _WithTop_α
    |_WithTop_α!val!0|)
  (define-fun valid_fact_0 () Bool
    (_Nat.AtLeastTwo _n))
  (define-fun _OfNat.ofNat_n_0 () _α
    |_α!val!1|)
  (define-fun _Nat.AtLeastTwo ((x!0 Int)) Bool
    true)
  (define-fun _WithTop.some ((x!0 _α)) _WithTop_α
    (ite (= x!0 |_α!val!1|) |_WithTop_α!val!1|
      |_WithTop_α!val!0|))
)


Testing || IsDedekindDomain.HeightOneSpectrum.intValuation_singleton : ∀ {R : Type u_1} [inst : CommRing R] [inst_1 : IsDedekindDomain R] (v : IsDedekindDomain.HeightOneSpectrum R) {r : R},
  r ≠ 0 → v.asIdeal = Ideal.span {r} → v.intValuation r = ↑(Multiplicative.ofAdd (-1))
Result.autoException ::
Auto.LamReif.reifTermCheckType :: LamTerm (¬ ((!7 (!8 !4) !1) = (!9 (!10 !11 (- (iofNat (1 : Nat))))))) is not type correct

Testing || Action.Hom.comm_assoc : ∀ {V : Type (u + 1)} [inst : CategoryTheory.LargeCategory V] {G : MonCat} {M N : Action V G} (self : M.Hom N) (g : ↑G)
  {Z : V} (h : N.V ⟶ Z),
  CategoryTheory.CategoryStruct.comp (M.ρ g) (CategoryTheory.CategoryStruct.comp self.hom h) =
    CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp (N.ρ g) h)
Result.autoException ::
Auto failed to find proof

Testing || CauchySeq.tendsto_uniformity : ∀ {α : Type u} {β : Type v} [uniformSpace : UniformSpace α] [inst : Preorder β] {u : β → α},
  CauchySeq u → Filter.Tendsto (Prod.map u u) Filter.atTop (uniformity α)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Filter_β:
  ;;   |_Filter_β!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Filter_β!val!0| () _Filter_β)
  ;; cardinality constraint:
  (forall ((x _Filter_β)) (= x |_Filter_β!val!0|))
  ;; -----------
  ;; universe for _Filter_β___β:
  ;;   |_Filter_β___β!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Filter_β___β!val!0| () _Filter_β___β)
  ;; cardinality constraint:
  (forall ((x _Filter_β___β)) (= x |_Filter_β___β!val!0|))
  ;; -----------
  ;; universe for _Filter_α___α:
  ;;   |_Filter_α___α!val!2| |_Filter_α___α!val!0| |_Filter_α___α!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Filter_α___α!val!2| () _Filter_α___α)
  (declare-fun |_Filter_α___α!val!0| () _Filter_α___α)
  (declare-fun |_Filter_α___α!val!1| () _Filter_α___α)
  ;; cardinality constraint:
  (forall ((x _Filter_α___α))
          (or (= x |_Filter_α___α!val!2|)
              (= x |_Filter_α___α!val!0|)
              (= x |_Filter_α___α!val!1|)))
  ;; -----------
  ;; universe for _Filter_α:
  ;;   |_Filter_α!val!1| |_Filter_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Filter_α!val!1| () _Filter_α)
  (declare-fun |_Filter_α!val!0| () _Filter_α)
  ;; cardinality constraint:
  (forall ((x _Filter_α)) (or (= x |_Filter_α!val!1|) (= x |_Filter_α!val!0|)))
  ;; -----------
  ;; universe for _Filter_β___β___β:
  ;;   |_Filter_β___β___β!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Filter_β___β___β!val!0| () _Filter_β___β___β)
  ;; cardinality constraint:
  (forall ((x _Filter_β___β___β)) (= x |_Filter_β___β___β!val!0|))
  ;; -----------
  ;; universe for _Filter_β___β___β_0:
  ;;   |_Filter_β___β___β_0!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Filter_β___β___β_0!val!0| () _Filter_β___β___β_0)
  ;; cardinality constraint:
  (forall ((x _Filter_β___β___β_0)) (= x |_Filter_β___β___β_0!val!0|))
  ;; -----------
  ;; universe for _Filter_α___α___α:
  ;;   |_Filter_α___α___α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Filter_α___α___α!val!0| () _Filter_α___α___α)
  ;; cardinality constraint:
  (forall ((x _Filter_α___α___α)) (= x |_Filter_α___α___α!val!0|))
  ;; -----------
  ;; universe for _Filter_α___α___α_0:
  ;;   |_Filter_α___α___α_0!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Filter_α___α___α_0!val!0| () _Filter_α___α___α_0)
  ;; cardinality constraint:
  (forall ((x _Filter_α___α___α_0)) (= x |_Filter_α___α___α_0!val!0|))
  ;; -----------
  (define-fun valid_fact_5 () Bool
    true)
  (define-fun valid_fact_2 () Bool
    (forall ((_f _Filter_β) (_f_0 _Filter_β))
  (= (_SProd.sprod_0 (_Filter.map_u _f) (_Filter.map_u _f_0))
     (_Filter.map_Prod.map_u_u (_SProd.sprod _f _f_0)))))
  (define-fun _Filter.atTop () _Filter_β
    |_Filter_β!val!0|)
  (define-fun valid_fact_3 () Bool
    (forall ((_f_1 _Filter_β___β) (_f_2 _Filter_β))
  (= (_SProd.sprod_1 (_Filter.map_Prod.map_u_u _f_1) (_Filter.map_u _f_2))
     (_Filter.map_Prod.map_Prod.map_u_u_u (_SProd.sprod_2 _f_1 _f_2)))))
  (define-fun valid_fact_7 () Bool
    true)
  (define-fun _CauchySeq_u () Bool
    true)
  (define-fun valid_fact_1 () Bool
    (not (_Filter.Tendsto_Prod.map_u_u
       (_SProd.sprod _Filter.atTop _Filter.atTop)
       |_uniformity_α|)))
  (define-fun valid_fact_0 () Bool
    _CauchySeq_u)
  (define-fun valid_fact_6 () Bool
    true)
  (define-fun valid_fact_4 () Bool
    (forall ((_f_3 _Filter_β) (_f_4 _Filter_β___β))
  (= (_SProd.sprod_3 (_Filter.map_u _f_3) (_Filter.map_Prod.map_u_u _f_4))
     (_Filter.map_Prod.map_u_Prod.map_u_u (_SProd.sprod_4 _f_3 _f_4)))))
  (define-fun |_uniformity_α| () _Filter_α___α
    |_Filter_α___α!val!0|)
  (define-fun _SProd.sprod_1 ((x!0 _Filter_α___α) (x!1 _Filter_α)) _Filter_α___α___α
    |_Filter_α___α___α!val!0|)
  (define-fun _SProd.sprod_2 ((x!0 _Filter_β___β) (x!1 _Filter_β)) _Filter_β___β___β
    |_Filter_β___β___β!val!0|)
  (define-fun _SProd.sprod_0 ((x!0 _Filter_α) (x!1 _Filter_α)) _Filter_α___α
    |_Filter_α___α!val!1|)
  (define-fun _SProd.sprod_3 ((x!0 _Filter_α) (x!1 _Filter_α___α)) _Filter_α___α___α_0
    |_Filter_α___α___α_0!val!0|)
  (define-fun _Filter.map_Prod.map_u_Prod.map_u_u ((x!0 _Filter_β___β___β_0)) _Filter_α___α___α_0
    |_Filter_α___α___α_0!val!0|)
  (define-fun _Filter.Tendsto_Prod.map_u_u ((x!0 _Filter_β___β)
   (x!1 _Filter_α___α)) Bool
    false)
  (define-fun _Filter.map_Prod.map_u_u ((x!0 _Filter_β___β)) _Filter_α___α
    |_Filter_α___α!val!1|)
  (define-fun _SProd.sprod ((x!0 _Filter_β) (x!1 _Filter_β)) _Filter_β___β
    |_Filter_β___β!val!0|)
  (define-fun _Filter.map_Prod.map_Prod.map_u_u_u ((x!0 _Filter_β___β___β)) _Filter_α___α___α
    |_Filter_α___α___α!val!0|)
  (define-fun _Filter.map_u ((x!0 _Filter_β)) _Filter_α
    |_Filter_α!val!0|)
  (define-fun _SProd.sprod_4 ((x!0 _Filter_β) (x!1 _Filter_β___β)) _Filter_β___β___β_0
    |_Filter_β___β___β_0!val!0|)
)


Testing || TrivSqZeroExt.inlAlgHom_apply : ∀ (S : Type u_1) (R : Type u) (M : Type v) [inst : CommSemiring S] [inst_1 : Semiring R] [inst_2 : AddCommMonoid M]
  [inst_3 : Algebra S R] [inst_4 : Module S M] [inst_5 : Module R M] [inst_6 : Module Rᵐᵒᵖ M]
  [inst_7 : SMulCommClass R Rᵐᵒᵖ M] [inst_8 : IsScalarTower S R M] [inst_9 : IsScalarTower S Rᵐᵒᵖ M] (r : R),
  (TrivSqZeroExt.inlAlgHom S R M) r = TrivSqZeroExt.inl r
Result.autoException ::
Auto failed to find proof

Testing || Matroid.StrictRestriction.ssubset : ∀ {α : Type u_1} {M N : Matroid α}, N.StrictRestriction M → N.E ⊂ M.E
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Matroid_α:
  ;;   |_Matroid_α!val!1| |_Matroid_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Matroid_α!val!1| () _Matroid_α)
  (declare-fun |_Matroid_α!val!0| () _Matroid_α)
  ;; cardinality constraint:
  (forall ((x _Matroid_α))
          (or (= x |_Matroid_α!val!1|) (= x |_Matroid_α!val!0|)))
  ;; -----------
  ;; universe for _Set_α:
  ;;   |_Set_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_α!val!0| () _Set_α)
  ;; cardinality constraint:
  (forall ((x _Set_α)) (= x |_Set_α!val!0|))
  ;; -----------
  (define-fun _N () _Matroid_α
    |_Matroid_α!val!0|)
  (define-fun valid_fact_4 () Bool
    (forall ((_s_3 _Set_α) (_s_4 _Set_α))
  (or (= _s_3 _s_4) (_SSubset _s_3 _s_4) (not (_Subset _s_3 _s_4)))))
  (define-fun valid_fact_7 () Bool
    (forall ((_s_5 _Set_α)) (_Subset _s_5 _s_5)))
  (define-fun valid_fact_8 () Bool
    (forall ((_m_3 _Matroid_α) (_s_6 _Set_α))
  (= (_Matroid.restrict (_Matroid.restrict _m_3 _s_6) _s_6)
     (_Matroid.restrict _m_3 _s_6))))
  (define-fun valid_fact_9 () Bool
    (forall ((_m_4 _Matroid_α))
  (= (_Matroid.restrict _m_4 (_Matroid.E _m_4)) _m_4)))
  (define-fun valid_fact_5 () Bool
    (forall ((_m _Matroid_α) (_m_0 _Matroid_α))
  (or (not (_Matroid.Restriction _m_0 _m))
      (_Subset (_Matroid.E _m_0) (_Matroid.E _m)))))
  (define-fun valid_fact_0 () Bool
    (_Matroid.StrictRestriction _N _M))
  (define-fun _M () _Matroid_α
    |_Matroid_α!val!1|)
  (define-fun valid_fact_6 () Bool
    (forall ((_m_1 _Matroid_α) (_m_2 _Matroid_α))
  (or (not (_Matroid.StrictRestriction _m_2 _m_1))
      (_Matroid.Restriction _m_2 _m_1))))
  (define-fun valid_fact_2 () Bool
    (forall ((_s _Set_α) (_s_0 _Set_α))
  (or (= _s _s_0) (_SSubset _s _s_0) (not (_Subset _s _s_0)))))
  (define-fun valid_fact_1 () Bool
    (not (_SSubset (_Matroid.E _N) (_Matroid.E _M))))
  (define-fun valid_fact_3 () Bool
    (forall ((_s_1 _Set_α) (_s_2 _Set_α))
  (or (= _s_1 _s_2) (_SSubset _s_1 _s_2) (not (_Subset _s_1 _s_2)))))
  (define-fun _Matroid.StrictRestriction ((x!0 _Matroid_α) (x!1 _Matroid_α)) Bool
    (and (not (= x!0 |_Matroid_α!val!1|)) (= x!1 |_Matroid_α!val!1|)))
  (define-fun _Matroid.E ((x!0 _Matroid_α)) _Set_α
    |_Set_α!val!0|)
  (define-fun _Matroid.Restriction ((x!0 _Matroid_α) (x!1 _Matroid_α)) Bool
    (and (not (= x!0 |_Matroid_α!val!1|)) (= x!1 |_Matroid_α!val!1|)))
  (define-fun _Subset ((x!0 _Set_α) (x!1 _Set_α)) Bool
    true)
  (define-fun _Matroid.restrict ((x!0 _Matroid_α) (x!1 _Set_α)) _Matroid_α
    (ite (and (= x!0 |_Matroid_α!val!0|) (= x!1 |_Set_α!val!0|))
      |_Matroid_α!val!0|
    (ite (and (= x!0 |_Matroid_α!val!1|) (= x!1 |_Set_α!val!0|))
      |_Matroid_α!val!1|
      x!0)))
  (define-fun _SSubset ((x!0 _Set_α) (x!1 _Set_α)) Bool
    false)
)


Testing || RelEmbedding.sumLexInr_apply : ∀ {α : Type u_1} {β : Type u_2} (r : α → α → Prop) (s : β → β → Prop) (val : β),
  (RelEmbedding.sumLexInr r s) val = Sum.inr val
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _s__r_Sum.Lex_r_s:
  ;;   _s__r_Sum.Lex_r_s!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _s__r_Sum.Lex_r_s!val!0 () _s__r_Sum.Lex_r_s)
  ;; cardinality constraint:
  (forall ((x _s__r_Sum.Lex_r_s)) (= x _s__r_Sum.Lex_r_s!val!0))
  ;; -----------
  ;; universe for _β:
  ;;   |_β!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_β!val!0| () _β)
  ;; cardinality constraint:
  (forall ((x _β)) (= x |_β!val!0|))
  ;; -----------
  ;; universe for _α:
  ;;   |_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!0| () _α)
  ;; cardinality constraint:
  (forall ((x _α)) (= x |_α!val!0|))
  ;; -----------
  (define-fun _RelEmbedding.sumLexInr_r_s () _s__r_Sum.Lex_r_s
    _s__r_Sum.Lex_r_s!val!0)
  (define-fun valid_fact_0 () Bool
    (not (= (_DFunLike.coe _RelEmbedding.sumLexInr_r_s _val) (_Sum.inr _val))))
  (define-fun _val () _β
    |_β!val!0|)
  (define-fun _DFunLike.coe ((x!0 _s__r_Sum.Lex_r_s) (x!1 _β)) _α___β
    (_Sum.inl |_α!val!0|))
)


Testing || Algebra.embeddingsMatrix_apply : ∀ {κ : Type w} (A : Type u) {B : Type v} (C : Type z) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]
  [inst_3 : CommRing C] [inst_4 : Algebra A C] (b : κ → B) (i : κ) (σ : B →ₐ[A] C),
  Algebra.embeddingsMatrix A C b i σ = σ (b i)
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix κ (B →ₐ[A] C) C is not a `∀`

Testing || Quaternion.coe_injective : ∀ {R : Type u_3} [inst : CommRing R], Function.Injective Quaternion.coe
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `QuaternionAlgebra.coe`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || CategoryTheory.Limits.Cocone.mapCoconeToOver_inv_hom : ∀ {J : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} J] {C : Type u₃} [inst_1 : CategoryTheory.Category.{v₃, u₃} C]
  {F : CategoryTheory.Functor J C} (c : CategoryTheory.Limits.Cocone F),
  c.mapCoconeToOver.inv.hom = CategoryTheory.CategoryStruct.id c.pt
Result.autoException ::
Auto failed to find proof

Testing || Antivary.inv_right : ∀ {ι : Type u_1} {α : Type u_2} {β : Type u_3} [inst : OrderedCommGroup α] [inst_1 : OrderedCommGroup β] {f : ι → α}
  {g : ι → β}, Antivary f g → Monovary f g⁻¹
Result.autoException ::
Auto failed to find proof

Testing || Submonoid.coe_centralizer : ∀ {M : Type u_1} (S : Set M) [inst : Monoid M], ↑(Submonoid.centralizer S) = S.centralizer
Result.autoException ::
Auto failed to find proof

Testing || AddAction.quotient.proof_3 : ∀ {α : Type u_1} (β : Type u_2) [inst : AddGroup α] [inst_1 : AddMonoid β] [inst_2 : AddAction β α] (H : AddSubgroup α)
  [inst_3 : AddAction.QuotientAction β H] (b b' : β) (q : α ⧸ H), b + b' +ᵥ q = b +ᵥ (b' +ᵥ q)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `QuotientAddGroup.leftRel x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || Cardinal.mk_pi : ∀ {ι : Type u} (α : ι → Type v), Cardinal.mk ((i : ι) → α i) = Cardinal.prod fun i => Cardinal.mk (α i)
Result.autoException ::
_private.Auto.Translation.LamFOL2SMT.0.Auto.SMT.lamTerm2STermAux :: Unexpected head term Auto.Embedding.Lam.LamTerm.lam (.atom 2) (.app (.atom 2) (.atom 2) (.bvar 0))

Testing || CategoryTheory.Functor.surjective_toEventualRanges : ∀ {J : Type u} [inst : CategoryTheory.Category.{u_1, u} J] (F : CategoryTheory.Functor J (Type v))
  [inst_1 : CategoryTheory.IsCofilteredOrEmpty J],
  F.IsMittagLeffler → ∀ ⦃i j : J⦄ (f : i ⟶ j), Function.Surjective (F.toEventualRanges.map f)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_12 f '' cifvar_13`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || Class.coe_union : ∀ (x y : ZFSet), ↑(x ∪ y) = ↑x ∪ ↑y
Result.autoException ::
Auto failed to find proof

Testing || Matrix.GeneralLinearGroup.coe_mul : ∀ {n : Type u} [inst : DecidableEq n] [inst_1 : Fintype n] {R : Type v} [inst_2 : CommRing R] (A B : GL n R),
  ↑(A * B) = ↑A * ↑B
Result.autoException ::
Auto failed to find proof

Testing || WCovBy.ge_of_gt : ∀ {α : Type u_1} [inst : LinearOrder α] {a b c : α}, a ⩿ b → a < c → b ≤ c
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _α:
  ;;   |_α!val!0| |_α!val!1| |_α!val!2| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!0| () _α)
  (declare-fun |_α!val!1| () _α)
  (declare-fun |_α!val!2| () _α)
  ;; cardinality constraint:
  (forall ((x _α)) (or (= x |_α!val!0|) (= x |_α!val!1|) (= x |_α!val!2|)))
  ;; -----------
  (define-fun _a () _α
    |_α!val!0|)
  (define-fun valid_fact_2 () Bool
    (_LT.lt _c _b))
  (define-fun valid_fact_0 () Bool
    (_WCovBy _a _b))
  (define-fun valid_fact_1 () Bool
    (_LT.lt _a _c))
  (define-fun _b () _α
    |_α!val!1|)
  (define-fun _c () _α
    |_α!val!2|)
  (define-fun _LT.lt ((x!0 _α) (x!1 _α)) Bool
    true)
  (define-fun _WCovBy ((x!0 _α) (x!1 _α)) Bool
    true)
)


Testing || IsCyclic.exists_monoid_generator : ∀ {α : Type u} [inst : Group α] [inst_1 : Finite α] [inst_2 : IsCyclic α], ∃ x, ∀ (y : α), y ∈ Submonoid.powers x
Result.success

Testing || Polynomial.rootOfSplits'_eq_rootOfSplits : ∀ {K : Type v} {L : Type w} [inst : Field K] [inst_1 : Field L] (i : K →+* L) {f : Polynomial K}
  (hf : Polynomial.Splits i f) (hfd : (Polynomial.map i f).degree ≠ 0),
  Polynomial.rootOfSplits' i hf hfd = Polynomial.rootOfSplits i hf ⋯
Result.autoException ::
Auto failed to find proof

Testing || Booleanisation.comp_sdiff_comp : ∀ {α : Type u_1} [inst : GeneralizedBooleanAlgebra α] (a b : α),
  Booleanisation.comp a \ Booleanisation.comp b = Booleanisation.lift (b \ a)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _α:
  ;;   |_α!val!0| |_α!val!1| |_α!val!2| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!0| () _α)
  (declare-fun |_α!val!1| () _α)
  (declare-fun |_α!val!2| () _α)
  ;; cardinality constraint:
  (forall ((x _α)) (or (= x |_α!val!0|) (= x |_α!val!1|) (= x |_α!val!2|)))
  ;; -----------
  ;; universe for _Booleanisation_α:
  ;;   |_Booleanisation_α!val!3| |_Booleanisation_α!val!0| |_Booleanisation_α!val!1| |_Booleanisation_α!val!2| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Booleanisation_α!val!3| () _Booleanisation_α)
  (declare-fun |_Booleanisation_α!val!0| () _Booleanisation_α)
  (declare-fun |_Booleanisation_α!val!1| () _Booleanisation_α)
  (declare-fun |_Booleanisation_α!val!2| () _Booleanisation_α)
  ;; cardinality constraint:
  (forall ((x _Booleanisation_α))
          (or (= x |_Booleanisation_α!val!3|)
              (= x |_Booleanisation_α!val!0|)
              (= x |_Booleanisation_α!val!1|)
              (= x |_Booleanisation_α!val!2|)))
  ;; -----------
  (define-fun _a () _α
    |_α!val!0|)
  (define-fun valid_fact_0 () Bool
    (not (= (_sdiff (_Booleanisation.comp _a) (_Booleanisation.comp _b))
        (_Booleanisation.lift (_sdiff_0 _b _a)))))
  (define-fun _b () _α
    |_α!val!1|)
  (define-fun _Booleanisation.comp ((x!0 _α)) _Booleanisation_α
    (ite (= x!0 |_α!val!1|) |_Booleanisation_α!val!1|
      |_Booleanisation_α!val!0|))
  (define-fun _Booleanisation.lift ((x!0 _α)) _Booleanisation_α
    |_Booleanisation_α!val!3|)
  (define-fun _sdiff_0 ((x!0 _α) (x!1 _α)) _α
    |_α!val!2|)
  (define-fun _sdiff ((x!0 _Booleanisation_α) (x!1 _Booleanisation_α)) _Booleanisation_α
    |_Booleanisation_α!val!2|)
)


Testing || aemeasurable_lineDeriv : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] [inst_1 : LocallyCompactSpace 𝕜] {E : Type u_2}
  [inst_2 : NormedAddCommGroup E] [inst_3 : NormedSpace 𝕜 E] [inst_4 : MeasurableSpace E]
  [inst_5 : OpensMeasurableSpace E] {F : Type u_3} [inst_6 : NormedAddCommGroup F] [inst_7 : NormedSpace 𝕜 F]
  [inst_8 : CompleteSpace F] {f : E → F} {v : E} [inst_9 : MeasurableSpace F] [inst_10 : BorelSpace F],
  Continuous f → ∀ (μ : MeasureTheory.Measure E), AEMeasurable (fun x => lineDeriv 𝕜 f x v) μ
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Measurable fun x =>
  cifvar_12 x x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || ite_false : ∀ {α : Sort u_1} (a b : α), (if False then a else b) = b
Result.success

Testing || linearEquivIsoModuleIso_hom : ∀ {R : Type u} [inst : Ring R] {X Y : Type u} [inst_1 : AddCommGroup X] [inst_2 : AddCommGroup Y] [inst_3 : Module R X]
  [inst_4 : Module R Y] (e : X ≃ₗ[R] Y), linearEquivIsoModuleIso.hom e = e.toModuleIso
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: (X ≃ₗ[R] Y) ⟶ ModuleCat.of R X ≅ ModuleCat.of R Y is not a `∀`

Testing || Function.fixedPoints_subset_range : ∀ {α : Type u} {f : α → α}, Function.fixedPoints f ⊆ Set.range f
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Set_α:
  ;;   |_Set_α!val!1| |_Set_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_α!val!1| () _Set_α)
  (declare-fun |_Set_α!val!0| () _Set_α)
  ;; cardinality constraint:
  (forall ((x _Set_α)) (or (= x |_Set_α!val!1|) (= x |_Set_α!val!0|)))
  ;; -----------
  (define-fun _Function.fixedPoints_f () _Set_α
    |_Set_α!val!0|)
  (define-fun valid_fact_0 () Bool
    (not (_Subset _Function.fixedPoints_f _Set.range_f)))
  (define-fun _Set.range_f () _Set_α
    |_Set_α!val!1|)
  (define-fun _Subset ((x!0 _Set_α) (x!1 _Set_α)) Bool
    false)
)


Testing || Prod.normedAddGroup.proof_2 : ∀ {E : Type u_1} {F : Type u_2} [inst : NormedAddGroup E] [inst_1 : NormedAddGroup F] (x y : E × F), dist x y = ‖x - y‖
Result.success

Testing || Prod.pow_swap : ∀ {E : Type u_4} {α : Type u_5} {β : Type u_6} [inst : Pow α E] [inst_1 : Pow β E] (p : α × β) (c : E),
  (p ^ c).swap = p.swap ^ c
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _E:
  ;;   _E!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _E!val!0 () _E)
  ;; cardinality constraint:
  (forall ((x _E)) (= x _E!val!0))
  ;; -----------
  ;; universe for _α:
  ;;   |_α!val!0| |_α!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!0| () _α)
  (declare-fun |_α!val!1| () _α)
  ;; cardinality constraint:
  (forall ((x _α)) (or (= x |_α!val!0|) (= x |_α!val!1|)))
  ;; -----------
  ;; universe for _β:
  ;;   |_β!val!0| |_β!val!2| |_β!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_β!val!0| () _β)
  (declare-fun |_β!val!2| () _β)
  (declare-fun |_β!val!1| () _β)
  ;; cardinality constraint:
  (forall ((x _β)) (or (= x |_β!val!0|) (= x |_β!val!2|) (= x |_β!val!1|)))
  ;; -----------
  (define-fun _c () _E
    _E!val!0)
  (define-fun valid_fact_0 () Bool
    (not (= (_Prod.swap (_HPow.hPow _p _c)) (_HPow.hPow_0 (_Prod.swap _p) _c))))
  (define-fun _p () _α___β
    (_Prod.mk |_α!val!0| |_β!val!0|))
  (define-fun _Prod.swap ((x!0 _α___β)) _β___α
    (ite (= x!0 (_Prod.mk |_α!val!0| |_β!val!0|))
      (_Prod.mk_0 |_β!val!1| |_α!val!0|)
      (_Prod.mk_0 |_β!val!0| |_α!val!0|)))
  (define-fun _HPow.hPow_0 ((x!0 _β___α) (x!1 _E)) _β___α
    (_Prod.mk_0 |_β!val!2| |_α!val!0|))
  (define-fun _HPow.hPow ((x!0 _α___β) (x!1 _E)) _α___β
    (_Prod.mk |_α!val!1| |_β!val!0|))
)


Testing || hasDerivAt_jacobiTheta₂_fst : ∀ (z : ℂ) {τ : ℂ}, 0 < τ.im → HasDerivAt (fun x => jacobiTheta₂ x τ) (jacobiTheta₂' z τ) z
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `HasSum
  (fun n => cifvar_13 n x_0 x_1) (cifvar_14 x_0 x_1)`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || _private.Mathlib.Algebra.Lie.BaseChange.0.LieAlgebra.ExtendScalars.bracket'_tmul : ∀ (R : Type u_1) (A : Type u_2) (L : Type u_3) (M : Type u_4) [inst : CommRing R] [inst_1 : CommRing A]
  [inst_2 : Algebra R A] [inst_3 : LieRing L] [inst_4 : LieAlgebra R L] [inst_5 : AddCommGroup M] [inst_6 : Module R M]
  [inst_7 : LieRingModule L M] [inst_8 : LieModule R L M] (s t : A) (x : L) (m : M),
  ((LieAlgebra.ExtendScalars.bracket' R A L M) (s ⊗ₜ[R] x)) (t ⊗ₜ[R] m) = (s * t) ⊗ₜ[R] ⁅x, m⁆
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.MorphismProperty.Comma.Hom.hom_left : ∀ {A : Type u_1} [inst : CategoryTheory.Category.{u_4, u_1} A] {B : Type u_2}
  [inst_1 : CategoryTheory.Category.{u_5, u_2} B] {T : Type u_3} [inst_2 : CategoryTheory.Category.{u_6, u_3} T]
  {L : CategoryTheory.Functor A T} {R : CategoryTheory.Functor B T} {P : CategoryTheory.MorphismProperty T}
  {Q : CategoryTheory.MorphismProperty A} {W : CategoryTheory.MorphismProperty B}
  {X Y : CategoryTheory.MorphismProperty.Comma L R P Q W} (f : X.Hom Y), f.hom.left = f.left
Result.success

Testing || Nat.log_zero_right : ∀ (b : ℕ), Nat.log b 0 = 0
Result.success

Testing || ConvexOn.slope_le_deriv : ∀ {S : Set ℝ} {f : ℝ → ℝ} {x y : ℝ},
  ConvexOn ℝ S f → x ∈ S → y ∈ S → x < y → DifferentiableAt ℝ f y → slope f x y ≤ deriv f y
Result.success

Testing || NonemptyFinLinOrd.dualEquiv_functor : NonemptyFinLinOrd.dualEquiv.functor = NonemptyFinLinOrd.dual
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.PreGaloisCategory.toAut_hom_app_apply : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{u₂, u₁} C] (F : CategoryTheory.Functor C FintypeCat) {G : Type u_1}
  [inst_1 : Group G] [inst_2 : (X : C) → MulAction G ↑(F.obj X)]
  [inst_3 : CategoryTheory.PreGaloisCategory.IsNaturalSMul F G] (g : G) {X : C} (x : ↑(F.obj X)),
  ((CategoryTheory.PreGaloisCategory.toAut F G) g).hom.app X x = g • x
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: F.obj X ⟶ F.obj X is not a `∀`

Testing || Std.DHashMap.Internal.List.insertEntry_of_containsKey_eq_false : ∀ {α : Type u} {β : α → Type v} [inst : BEq α] {l : List ((a : α) × β a)} {k : α} {v : β k},
  Std.DHashMap.Internal.List.containsKey k l = false → Std.DHashMap.Internal.List.insertEntry k v l = ⟨k, v⟩ :: l
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _α:
  ;;   |_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!0| () _α)
  ;; cardinality constraint:
  (forall ((x _α)) (= x |_α!val!0|))
  ;; -----------
  ;; universe for _β_k:
  ;;   |_β_k!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_β_k!val!0| () _β_k)
  ;; cardinality constraint:
  (forall ((x _β_k)) (= x |_β_k!val!0|))
  ;; -----------
  ;; universe for __a___α____β_a:
  ;;   |__a___α____β_a!val!0| |__a___α____β_a!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |__a___α____β_a!val!0| () __a___α____β_a)
  (declare-fun |__a___α____β_a!val!1| () __a___α____β_a)
  ;; cardinality constraint:
  (forall ((x __a___α____β_a))
          (or (= x |__a___α____β_a!val!0|) (= x |__a___α____β_a!val!1|)))
  ;; -----------
  (define-fun _l () _List__a___α____β_a
    _pl___)
  (define-fun _k () _α
    |_α!val!0|)
  (define-fun _v () _β_k
    |_β_k!val!0|)
  (define-fun valid_fact_0 () Bool
    (not (_Std.DHashMap.Internal.List.containsKey _k _l)))
  (define-fun valid_fact_1 () Bool
    (not (= (_Std.DHashMap.Internal.List.insertEntry_k _v _l)
        (_List.cons (_Sigma.mk_k _v) _l))))
  (define-fun _Sigma.mk_k ((x!0 _β_k)) __a___α____β_a
    |__a___α____β_a!val!0|)
  (define-fun _Std.DHashMap.Internal.List.containsKey ((x!0 _α)
   (x!1 _List__a___α____β_a)) Bool
    false)
  (define-fun _Std.DHashMap.Internal.List.insertEntry_k ((x!0 _β_k)
   (x!1 _List__a___α____β_a)) _List__a___α____β_a
    (_List.cons |__a___α____β_a!val!1| _pl___))
)


Testing || AddSubmonoid.toOrderedAddCommMonoid.proof_2 : ∀ {M : Type u_1} [inst : OrderedAddCommMonoid M] (S : AddSubmonoid M), Function.Injective fun a => ↑a
Result.success

Testing || HasFDerivWithinAt.multiset_prod : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {s : Set E} {ι : Type u_5} {𝔸' : Type u_7} [inst_3 : NormedCommRing 𝔸']
  [inst_4 : NormedAlgebra 𝕜 𝔸'] {g : ι → E → 𝔸'} {g' : ι → E →L[𝕜] 𝔸'} [inst_5 : DecidableEq ι] {u : Multiset ι}
  {x : E},
  (∀ i ∈ u, HasFDerivWithinAt (fun x => g i x) (g' i) s x) →
    HasFDerivWithinAt (fun x => (Multiset.map (fun x_1 => g x_1 x) u).prod)
      (Multiset.map (fun i => (Multiset.map (fun x_1 => g x_1 x) (u.erase i)).prod • g' i) u).sum s x
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `HasFDerivWithinAt
  (fun x => cifvar_3 x_0 x) (cifvar_4 x_0) cifvar_5 cifvar_6`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || Complex.map_isometryOfOrthonormal : ∀ {F : Type u_6} [inst : NormedAddCommGroup F] [inst_1 : InnerProductSpace ℝ F] {F' : Type u_7}
  [inst_2 : NormedAddCommGroup F'] [inst_3 : InnerProductSpace ℝ F'] (v : OrthonormalBasis (Fin 2) ℝ F)
  (f : F ≃ₗᵢ[ℝ] F'), Complex.isometryOfOrthonormal (v.map f) = (Complex.isometryOfOrthonormal v).trans f
Result.autoException ::
Auto failed to find proof

Testing || Finset.image_preimage : ∀ {α : Type u} {β : Type v} [inst : DecidableEq β] (f : α → β) (s : Finset β)
  [inst_1 : (x : β) → Decidable (x ∈ Set.range f)] (hf : Set.InjOn f (f ⁻¹' ↑s)),
  Finset.image f (s.preimage f hf) = Finset.filter (fun x => x ∈ Set.range f) s
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{x |
  cifvar_22 (cifvar_23 x_0 x) (cifvar_24 cifvar_19 x)}`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || UInt32.toNat_ofNat_of_lt : ∀ {n : ℕ}, n < UInt32.size → (UInt32.ofNat n).toNat = n
Result.success

Testing || SimpleGraph.comap_comap : ∀ {V : Type u_1} {W : Type u_2} {X : Type u_3} {G : SimpleGraph X} (f : V → W) (g : W → X),
  SimpleGraph.comap f (SimpleGraph.comap g G) = SimpleGraph.comap (g ∘ f) G
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.Subobject.ofMkLE_comp_ofLEMk : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] {B A₁ A₂ : C} (f : A₁ ⟶ B) [inst_1 : CategoryTheory.Mono f]
  (X : CategoryTheory.Subobject B) (g : A₂ ⟶ B) [inst_2 : CategoryTheory.Mono g]
  (h₁ : CategoryTheory.Subobject.mk f ≤ X) (h₂ : X ≤ CategoryTheory.Subobject.mk g),
  CategoryTheory.CategoryStruct.comp (CategoryTheory.Subobject.ofMkLE f X h₁) (X.ofLEMk g h₂) =
    CategoryTheory.Subobject.ofMkLEMk f g ⋯
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _A₁___B:
  ;;   |_A₁___B!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_A₁___B!val!0| () _A₁___B)
  ;; cardinality constraint:
  (forall ((x _A₁___B)) (= x |_A₁___B!val!0|))
  ;; -----------
  ;; universe for _A₂___B:
  ;;   |_A₂___B!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_A₂___B!val!0| () _A₂___B)
  ;; cardinality constraint:
  (forall ((x _A₂___B)) (= x |_A₂___B!val!0|))
  ;; -----------
  ;; universe for _CategoryTheory.Subobject_B:
  ;;   _CategoryTheory.Subobject_B!val!0 _CategoryTheory.Subobject_B!val!1 _CategoryTheory.Subobject_B!val!2 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _CategoryTheory.Subobject_B!val!0 () _CategoryTheory.Subobject_B)
  (declare-fun _CategoryTheory.Subobject_B!val!1 () _CategoryTheory.Subobject_B)
  (declare-fun _CategoryTheory.Subobject_B!val!2 () _CategoryTheory.Subobject_B)
  ;; cardinality constraint:
  (forall ((x _CategoryTheory.Subobject_B))
          (or (= x _CategoryTheory.Subobject_B!val!0)
              (= x _CategoryTheory.Subobject_B!val!1)
              (= x _CategoryTheory.Subobject_B!val!2)))
  ;; -----------
  ;; universe for _CategoryTheory.Subobject.mk_f___X:
  ;;   _CategoryTheory.Subobject.mk_f___X!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _CategoryTheory.Subobject.mk_f___X!val!0 () _CategoryTheory.Subobject.mk_f___X)
  ;; cardinality constraint:
  (forall ((x _CategoryTheory.Subobject.mk_f___X))
          (= x _CategoryTheory.Subobject.mk_f___X!val!0))
  ;; -----------
  ;; universe for _A₁___CategoryTheory.Subobject.underlying.obj_X:
  ;;   |_A₁___CategoryTheory.Subobject.underlying.obj_X!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_A₁___CategoryTheory.Subobject.underlying.obj_X!val!0| () _A₁___CategoryTheory.Subobject.underlying.obj_X)
  ;; cardinality constraint:
  (forall ((x _A₁___CategoryTheory.Subobject.underlying.obj_X))
          (= x |_A₁___CategoryTheory.Subobject.underlying.obj_X!val!0|))
  ;; -----------
  ;; universe for _X___CategoryTheory.Subobject.mk_g:
  ;;   _X___CategoryTheory.Subobject.mk_g!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _X___CategoryTheory.Subobject.mk_g!val!0 () _X___CategoryTheory.Subobject.mk_g)
  ;; cardinality constraint:
  (forall ((x _X___CategoryTheory.Subobject.mk_g))
          (= x _X___CategoryTheory.Subobject.mk_g!val!0))
  ;; -----------
  ;; universe for _CategoryTheory.Subobject.underlying.obj_X___A₂:
  ;;   |_CategoryTheory.Subobject.underlying.obj_X___A₂!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_CategoryTheory.Subobject.underlying.obj_X___A₂!val!0| () _CategoryTheory.Subobject.underlying.obj_X___A₂)
  ;; cardinality constraint:
  (forall ((x _CategoryTheory.Subobject.underlying.obj_X___A₂))
          (= x |_CategoryTheory.Subobject.underlying.obj_X___A₂!val!0|))
  ;; -----------
  ;; universe for _A₁___A₂:
  ;;   |_A₁___A₂!val!0| |_A₁___A₂!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_A₁___A₂!val!0| () _A₁___A₂)
  (declare-fun |_A₁___A₂!val!1| () _A₁___A₂)
  ;; cardinality constraint:
  (forall ((x _A₁___A₂))
          (or (= x |_A₁___A₂!val!0|) (= x |_A₁___A₂!val!1|)))
  ;; -----------
  ;; universe for _CategoryTheory.Subobject.mk_f___CategoryTheory.Subobject.mk_g:
  ;;   _CategoryTheory.Subobject.mk_f___CategoryTheory.Subobject.mk_g!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _CategoryTheory.Subobject.mk_f___CategoryTheory.Subobject.mk_g!val!0 () _CategoryTheory.Subobject.mk_f___CategoryTheory.Subobject.mk_g)
  ;; cardinality constraint:
  (forall ((x _CategoryTheory.Subobject.mk_f___CategoryTheory.Subobject.mk_g))
          (= x
             _CategoryTheory.Subobject.mk_f___CategoryTheory.Subobject.mk_g!val!0))
  ;; -----------
  (define-fun _X () _CategoryTheory.Subobject_B
    _CategoryTheory.Subobject_B!val!1)
  (define-fun |_h₂| () _X___CategoryTheory.Subobject.mk_g
    _X___CategoryTheory.Subobject.mk_g!val!0)
  (define-fun _CategoryTheory.Subobject.mk_f () _CategoryTheory.Subobject_B
    _CategoryTheory.Subobject_B!val!0)
  (define-fun _CategoryTheory.Subobject.mk_g () _CategoryTheory.Subobject_B
    _CategoryTheory.Subobject_B!val!2)
  (define-fun valid_fact_4 () Bool
    (not (= (_CategoryTheory.CategoryStruct.comp
          (_CategoryTheory.Subobject.ofMkLE_f_X |_h₁|)
          (_X.ofLEMk_g |_h₂|))
        (_CategoryTheory.Subobject.ofMkLEMk_f_g (_LE.le.trans |_h₁| |_h₂|)))))
  (define-fun |_h₁| () _CategoryTheory.Subobject.mk_f___X
    _CategoryTheory.Subobject.mk_f___X!val!0)
  (define-fun _f () _A₁___B
    |_A₁___B!val!0|)
  (define-fun valid_fact_1 () Bool
    (_CategoryTheory.Mono_0 _g))
  (define-fun valid_fact_3 () Bool
    (_LE.le _X _CategoryTheory.Subobject.mk_g))
  (define-fun valid_fact_2 () Bool
    (_LE.le _CategoryTheory.Subobject.mk_f _X))
  (define-fun _g () _A₂___B
    |_A₂___B!val!0|)
  (define-fun valid_fact_5 () Bool
    (forall ((_c _CategoryTheory.Subobject_B)
         (_c_0 _CategoryTheory.Subobject_B)
         (_c_1 _CategoryTheory.Subobject_B))
  (or (_LE.le _c _c_1) (not (_LE.le _c_0 _c_1)) (not (_LE.le _c _c_0)))))
  (define-fun valid_fact_0 () Bool
    (_CategoryTheory.Mono _f))
  (define-fun _CategoryTheory.Subobject.ofMkLEMk_f_g ((x!0
    _CategoryTheory.Subobject.mk_f___CategoryTheory.Subobject.mk_g)) _A₁___A₂
    |_A₁___A₂!val!1|)
  (define-fun _LE.le ((x!0 _CategoryTheory.Subobject_B)
   (x!1 _CategoryTheory.Subobject_B)) Bool
    (or (and (= x!0 _CategoryTheory.Subobject_B!val!0)
             (not (= x!0 _CategoryTheory.Subobject_B!val!2))
             (= x!1 _CategoryTheory.Subobject_B!val!2))
        (and (= x!0 _CategoryTheory.Subobject_B!val!0)
             (not (= x!0 _CategoryTheory.Subobject_B!val!2))
             (not (= x!1 _CategoryTheory.Subobject_B!val!0))
             (not (= x!1 _CategoryTheory.Subobject_B!val!2)))
        (and (not (= x!0 _CategoryTheory.Subobject_B!val!0))
             (not (= x!0 _CategoryTheory.Subobject_B!val!2))
             (= x!1 _CategoryTheory.Subobject_B!val!2))))
  (define-fun _LE.le.trans ((x!0 _CategoryTheory.Subobject.mk_f___X)
   (x!1 _X___CategoryTheory.Subobject.mk_g)) _CategoryTheory.Subobject.mk_f___CategoryTheory.Subobject.mk_g
    _CategoryTheory.Subobject.mk_f___CategoryTheory.Subobject.mk_g!val!0)
  (define-fun _CategoryTheory.Mono_0 ((x!0 _A₂___B)) Bool
    true)
  (define-fun _CategoryTheory.Subobject.ofMkLE_f_X ((x!0
    _CategoryTheory.Subobject.mk_f___X)) _A₁___CategoryTheory.Subobject.underlying.obj_X
    |_A₁___CategoryTheory.Subobject.underlying.obj_X!val!0|)
  (define-fun _X.ofLEMk_g ((x!0 _X___CategoryTheory.Subobject.mk_g)) _CategoryTheory.Subobject.underlying.obj_X___A₂
    |_CategoryTheory.Subobject.underlying.obj_X___A₂!val!0|)
  (define-fun _CategoryTheory.Mono ((x!0 _A₁___B)) Bool
    true)
  (define-fun _CategoryTheory.CategoryStruct.comp ((x!0
    _A₁___CategoryTheory.Subobject.underlying.obj_X)
   (x!1 _CategoryTheory.Subobject.underlying.obj_X___A₂)) _A₁___A₂
    |_A₁___A₂!val!0|)
)


Testing || Primrec.option_bind₁ : ∀ {α : Type u_1} {σ : Type u_3} [inst : Primcodable α] [inst_1 : Primcodable σ] {f : α → Option σ},
  Primrec f → Primrec fun o => o.bind f
Result.autoException ::
Auto failed to find proof

Testing || HasStrictFDerivAt.congr_of_eventuallyEq : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {F : Type u_3} [inst_3 : NormedAddCommGroup F] [inst_4 : NormedSpace 𝕜 F] {f f₁ : E → F}
  {f' : E →L[𝕜] F} {x : E}, HasStrictFDerivAt f f' x → f =ᶠ[nhds x] f₁ → HasStrictFDerivAt f₁ f' x
Result.success

Testing || MeasureTheory.AEStronglyMeasurable.nullMeasurableSet_le : ∀ {α : Type u_1} {β : Type u_2} {m : MeasurableSpace α} {μ : MeasureTheory.Measure α} [inst : TopologicalSpace β]
  [inst_1 : Preorder β] [inst_2 : OrderClosedTopology β] [inst_3 : TopologicalSpace.PseudoMetrizableSpace β]
  {f g : α → β},
  MeasureTheory.AEStronglyMeasurable f μ →
    MeasureTheory.AEStronglyMeasurable g μ → MeasureTheory.NullMeasurableSet {a | f a ≤ g a} μ
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `x_1 =ᶠ[cifvar_9 x_0] x_2`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || List.sorted_mergeSort : ∀ {α : Type u_1} {le : α → α → Bool},
  (∀ (a b c : α), le a b = true → le b c = true → le a c = true) →
    (∀ (a b : α), (le a b || le b a) = true) → ∀ (l : List α), List.Pairwise (fun a b => le a b = true) (l.mergeSort le)
Result.autoException ::
Auto.Lemma.rewriteUMonoRigid? :: Motive fun _a =>
  ∀ {α : Type u_1} {n : ℕ} (l : { l // l.length = n }),
    (List.splitInTwo l).1 = ⟨List.take ((n + 1) / 2) ↑l, ⋯⟩ is not type correct

Testing || List.forall_mem_inter_of_forall_right : ∀ {α : Type u_1} {l₂ : List α} {p : α → Prop} [inst : DecidableEq α] (l₁ : List α), (∀ x ∈ l₂, p x) → ∀ x ∈ l₁ ∩ l₂, p x
Result.success

Testing || ULift.addCancelMonoid.proof_4 : ∀ {α : Type u_2} [inst : AddCancelMonoid α] (x : ULift.{u_1, u_2} α) (x_1 : ℕ),
  Equiv.ulift (x_1 • x) = Equiv.ulift (x_1 • x)
Result.success

Testing || List.nextOr_nil : ∀ {α : Type u_1} [inst : DecidableEq α] (x d : α), [].nextOr x d = d
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _α:
  ;;   |_α!val!0| |_α!val!1| |_α!val!2| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!0| () _α)
  (declare-fun |_α!val!1| () _α)
  (declare-fun |_α!val!2| () _α)
  ;; cardinality constraint:
  (forall ((x _α)) (or (= x |_α!val!0|) (= x |_α!val!1|) (= x |_α!val!2|)))
  ;; -----------
  (define-fun valid_fact_0 () Bool
    (not (= (_List.nextOr _pl___ _x _d) _d)))
  (define-fun _d () _α
    |_α!val!1|)
  (define-fun _x () _α
    |_α!val!0|)
  (define-fun _List.nextOr ((x!0 _List_α) (x!1 _α) (x!2 _α)) _α
    |_α!val!2|)
)


Testing || Std.HashSet.get?_erase_self : ∀ {α : Type u} {x : BEq α} {x_1 : Hashable α} {m : Std.HashSet α} [inst : EquivBEq α] [inst : LawfulHashable α] {k : α},
  (m.erase k).get? k = none
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _α:
  ;;   |_α!val!1| |_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α!val!1| () _α)
  (declare-fun |_α!val!0| () _α)
  ;; cardinality constraint:
  (forall ((x _α)) (or (= x |_α!val!1|) (= x |_α!val!0|)))
  ;; -----------
  ;; universe for _Std.DHashMap_α_fun_x_=>_PUnit._1_:
  ;;   |_Std.DHashMap_α_fun_x_=>_PUnit._1_!val!0| |_Std.DHashMap_α_fun_x_=>_PUnit._1_!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Std.DHashMap_α_fun_x_=>_PUnit._1_!val!0| () _Std.DHashMap_α_fun_x_=>_PUnit._1_)
  (declare-fun |_Std.DHashMap_α_fun_x_=>_PUnit._1_!val!1| () _Std.DHashMap_α_fun_x_=>_PUnit._1_)
  ;; cardinality constraint:
  (forall ((x _Std.DHashMap_α_fun_x_=>_PUnit._1_))
          (or (= x |_Std.DHashMap_α_fun_x_=>_PUnit._1_!val!0|)
              (= x |_Std.DHashMap_α_fun_x_=>_PUnit._1_!val!1|)))
  ;; -----------
  (define-fun _k () _α
    |_α!val!0|)
  (define-fun |_EquivBEq_α| () Bool
    true)
  (define-fun valid_fact_0 () Bool
    |_EquivBEq_α|)
  (define-fun valid_fact_1 () Bool
    (not (= (_Std.HashSet.get? (_Std.HashSet.erase _m _k) _k) _none)))
  (define-fun _m () _Std.HashSet_α
    (_Std.HashSet.mk (_Std.HashMap.mk |_Std.DHashMap_α_fun_x_=>_PUnit._1_!val!0|)))
  (define-fun _Std.HashSet.erase ((x!0 _Std.HashSet_α) (x!1 _α)) _Std.HashSet_α
    (_Std.HashSet.mk (_Std.HashMap.mk |_Std.DHashMap_α_fun_x_=>_PUnit._1_!val!1|)))
  (define-fun _Std.HashSet.get? ((x!0 _Std.HashSet_α) (x!1 _α)) _Option_α
    (_some |_α!val!1|))
)


Testing || Rat.mk'_zero : ∀ (d : ℕ) (h : d ≠ 0) (w : (Int.natAbs 0).Coprime d), { num := 0, den := d, den_nz := h, reduced := w } = 0
Result.autoException ::
Auto failed to find proof

Testing || Set.prod_univ : ∀ {α : Type u_1} {β : Type u_2} {s : Set α}, s ×ˢ Set.univ = Prod.fst ⁻¹' s
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Set_α:
  ;;   |_Set_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_α!val!0| () _Set_α)
  ;; cardinality constraint:
  (forall ((x _Set_α)) (= x |_Set_α!val!0|))
  ;; -----------
  ;; universe for _Set_β:
  ;;   |_Set_β!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_β!val!0| () _Set_β)
  ;; cardinality constraint:
  (forall ((x _Set_β)) (= x |_Set_β!val!0|))
  ;; -----------
  ;; universe for _Set_α___β:
  ;;   |_Set_α___β!val!0| |_Set_α___β!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_α___β!val!0| () _Set_α___β)
  (declare-fun |_Set_α___β!val!1| () _Set_α___β)
  ;; cardinality constraint:
  (forall ((x _Set_α___β))
          (or (= x |_Set_α___β!val!0|) (= x |_Set_α___β!val!1|)))
  ;; -----------
  (define-fun valid_fact_0 () Bool
    (not (= (_SProd.sprod _s _Set.univ) (_Set.preimage_fun_self_=>_self.1_ _s))))
  (define-fun valid_fact_1 () Bool
    (forall ((_s_0 _Set_β)) (= (_Inter.inter _s_0 _Set.univ) _s_0)))
  (define-fun _Set.univ () _Set_β
    |_Set_β!val!0|)
  (define-fun _s () _Set_α
    |_Set_α!val!0|)
  (define-fun _Inter.inter ((x!0 _Set_β) (x!1 _Set_β)) _Set_β
    x!0)
  (define-fun _SProd.sprod ((x!0 _Set_α) (x!1 _Set_β)) _Set_α___β
    |_Set_α___β!val!0|)
  (define-fun _Set.preimage_fun_self_=>_self.1_ ((x!0 _Set_α)) _Set_α___β
    |_Set_α___β!val!1|)
)


Testing || tangentMapWithin_id : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners 𝕜 E H} {M : Type u_4}
  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] {s : Set M} {p : TangentBundle I M},
  UniqueMDiffWithinAt I s p.proj → tangentMapWithin I I id s p = p
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `instTopologicalSpaceTangentSpace
  x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || affineSegment_eq_segment : ∀ (R : Type u_1) {V : Type u_2} [inst : OrderedRing R] [inst_1 : AddCommGroup V] [inst_2 : Module R V] (x y : V),
  affineSegment R x y = segment R x y
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `cifvar_8 (cifvar_9 x_0 x_1) ''
  cifvar_10 cifvar_11 cifvar_12`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || RingHom.OfLocalizationSpanTarget.ofIsLocalization : ∀ {P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → (R →+* S) → Prop},
  (RingHom.OfLocalizationSpanTarget fun {R S} [CommRing R] [CommRing S] => P) →
    (RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P) →
      ∀ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (f : R →+* S) (s : Set S),
        Ideal.span s = ⊤ →
          (∀ (r : ↑s), ∃ T x x_1, ∃ (_ : IsLocalization.Away (↑r) T), P ((algebraMap S T).comp f)) → P f
Result.autoException ::
Auto.Monomorphization.FVarRep.replacePolyWithFVar :: Type CommRing R✝ of λ binder contains bound variables

Testing || CompHausLike.LocallyConstant.functor_obj_val : ∀ (P : TopCat → Prop) [inst : CompHausLike.HasExplicitFiniteCoproducts P] [inst_1 : CompHausLike.HasExplicitPullbacks P]
  (hs : ∀ ⦃X Y : CompHausLike P⦄ (f : X ⟶ Y), CategoryTheory.EffectiveEpi f → Function.Surjective ⇑f)
  (X : Type (max u w)),
  ((CompHausLike.LocallyConstant.functor P hs).obj X).val = CompHausLike.LocallyConstant.functorToPresheaves.obj X
Result.autoException ::
Auto failed to find proof

Testing || MeasureTheory.Measure.measure_isMulInvariant_eq_smul_of_isCompact_closure_of_measurableSet : ∀ {G : Type u_1} [inst : TopologicalSpace G] [inst_1 : Group G] [inst_2 : TopologicalGroup G]
  [inst_3 : MeasurableSpace G] [inst_4 : BorelSpace G] [inst_5 : LocallyCompactSpace G] (μ' μ : MeasureTheory.Measure G)
  [inst_6 : μ.IsHaarMeasure] [inst_7 : MeasureTheory.IsFiniteMeasureOnCompacts μ'] [inst_8 : μ'.IsMulLeftInvariant]
  {s : Set G}, MeasurableSet s → IsCompact (closure s) → μ' s = μ'.haarScalarFactor μ • μ s
Result.autoException ::
Auto failed to find proof

Testing || Mod_.comap_obj_X : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] [inst_1 : CategoryTheory.MonoidalCategory C] {A B : Mon_ C}
  (f : A ⟶ B) (M : Mod_ B), ((Mod_.comap f).obj M).X = M.X
Result.autoException ::
Auto failed to find proof

Testing || ContinuousLinearMap.coe_zero : ∀ {R₁ : Type u_1} {R₂ : Type u_2} [inst : Semiring R₁] [inst_1 : Semiring R₂] {σ₁₂ : R₁ →+* R₂} {M₁ : Type u_4}
  [inst_2 : TopologicalSpace M₁] [inst_3 : AddCommMonoid M₁] {M₂ : Type u_6} [inst_4 : TopologicalSpace M₂]
  [inst_5 : AddCommMonoid M₂] [inst_6 : Module R₁ M₁] [inst_7 : Module R₂ M₂], ↑0 = 0
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _M₁__SL_σ₁₂__M₂:
  ;;   |_M₁__SL_σ₁₂__M₂!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_M₁__SL_σ₁₂__M₂!val!0| () _M₁__SL_σ₁₂__M₂)
  ;; cardinality constraint:
  (forall ((x _M₁__SL_σ₁₂__M₂)) (= x |_M₁__SL_σ₁₂__M₂!val!0|))
  ;; -----------
  ;; universe for _M₁_____σ₁₂__M₂:
  ;;   |_M₁_____σ₁₂__M₂!val!1| |_M₁_____σ₁₂__M₂!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_M₁_____σ₁₂__M₂!val!1| () _M₁_____σ₁₂__M₂)
  (declare-fun |_M₁_____σ₁₂__M₂!val!0| () _M₁_____σ₁₂__M₂)
  ;; cardinality constraint:
  (forall ((x _M₁_____σ₁₂__M₂))
          (or (= x |_M₁_____σ₁₂__M₂!val!1|)
              (= x |_M₁_____σ₁₂__M₂!val!0|)))
  ;; -----------
  (define-fun _0__0 () _M₁_____σ₁₂__M₂
    |_M₁_____σ₁₂__M₂!val!1|)
  (define-fun valid_fact_0 () Bool
    (not (= (_ContinuousLinearMap.toLinearMap _0_) _0__0)))
  (define-fun _0_ () _M₁__SL_σ₁₂__M₂
    |_M₁__SL_σ₁₂__M₂!val!0|)
  (define-fun _ContinuousLinearMap.toLinearMap ((x!0 _M₁__SL_σ₁₂__M₂)) _M₁_____σ₁₂__M₂
    |_M₁_____σ₁₂__M₂!val!0|)
)


Testing || Function.Injective2.uncurry : ∀ {α : Type u_4} {β : Type u_5} {γ : Type u_6} {f : α → β → γ},
  Function.Injective2 f → Function.Injective (Function.uncurry f)
Result.autoException ::
Auto failed to find proof

Testing || FirstOrder.Language.ElementaryEmbedding.refl_apply : ∀ {L : FirstOrder.Language} {M : Type u_1} [inst : L.Structure M] (x : M),
  (FirstOrder.Language.ElementaryEmbedding.refl L M) x = x
Result.autoException ::
_private.Auto.Translation.LamFOL2SMT.0.Auto.SMT.lamSort2SSortAux :: Unexpected error. Higher order input?

Testing || Cycle.isCycle_formPerm : ∀ {α : Type u_1} [inst : DecidableEq α] (s : Cycle α) (h : s.Nodup), s.Nontrivial → (s.formPerm h).IsCycle
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Cycle_α:
  ;;   |_Cycle_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Cycle_α!val!0| () _Cycle_α)
  ;; cardinality constraint:
  (forall ((x _Cycle_α)) (= x |_Cycle_α!val!0|))
  ;; -----------
  ;; universe for _s.Nodup:
  ;;   _s.Nodup!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _s.Nodup!val!0 () _s.Nodup)
  ;; cardinality constraint:
  (forall ((x _s.Nodup)) (= x _s.Nodup!val!0))
  ;; -----------
  ;; universe for _α___α:
  ;;   |_α___α!val!0| |_α___α!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_α___α!val!0| () _α___α)
  (declare-fun |_α___α!val!1| () _α___α)
  ;; cardinality constraint:
  (forall ((x _α___α)) (or (= x |_α___α!val!0|) (= x |_α___α!val!1|)))
  ;; -----------
  (define-fun valid_fact_1 () Bool
    (_Cycle.Nontrivial _s))
  (define-fun valid_fact_3 () Bool
    (forall ((_l _List_α))
  (or (_Equiv.Perm.IsCycle (_List.formPerm _l))
      (not (_List.Nodup _l))
      (not (<= 2 (_List.length _l))))))
  (define-fun valid_fact_4 () Bool
    (forall ((_c _Cycle_α))
  (or (not (_Cycle.Nontrivial _c)) (<= 2 (_Cycle.length _c)))))
  (define-fun valid_fact_2 () Bool
    (not (_Equiv.Perm.IsCycle (_s.formPerm _h))))
  (define-fun _s () _Cycle_α
    |_Cycle_α!val!0|)
  (define-fun valid_fact_0 () Bool
    (_Cycle.Nodup _s))
  (define-fun _h () _s.Nodup
    _s.Nodup!val!0)
  (define-fun _Equiv.Perm.IsCycle ((x!0 _α___α)) Bool
    false)
  (define-fun _List.length ((x!0 _List_α)) Int
    3)
  (define-fun _List.formPerm ((x!0 _List_α)) _α___α
    |_α___α!val!1|)
  (define-fun _Cycle.length ((x!0 _Cycle_α)) Int
    2)
  (define-fun _Cycle.Nodup ((x!0 _Cycle_α)) Bool
    true)
  (define-fun _Cycle.Nontrivial ((x!0 _Cycle_α)) Bool
    true)
  (define-fun _s.formPerm ((x!0 _s.Nodup)) _α___α
    |_α___α!val!0|)
  (define-fun _List.Nodup ((x!0 _List_α)) Bool
    false)
)


Testing || Matrix.inv_subsingleton : ∀ {m : Type u} {α : Type v} [inst : CommRing α] [inst_1 : Subsingleton m] [inst_2 : Fintype m] [inst_3 : DecidableEq m]
  (A : Matrix m m α), A⁻¹ = Matrix.diagonal fun i => Ring.inverse (A i i)
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Matrix m m α is not a `∀`

Testing || Submodule.dualAnnihilator_sup_eq : ∀ {R : Type u} {M : Type v} [inst : CommSemiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]
  (U V : Submodule R M), (U ⊔ V).dualAnnihilator = U.dualAnnihilator ⊓ V.dualAnnihilator
Result.autoException ::
Auto failed to find proof

Testing || not_isMin : ∀ {α : Type u_1} [inst : Preorder α] [inst_1 : NoMinOrder α] (a : α), ¬IsMin a
Result.success

Testing || Combinatorics.Line.vertical_apply : ∀ {α : Type u_5} {ι : Type u_6} {ι' : Type u_7} (v : ι → α) (l : Combinatorics.Line α ι') (x : α),
  (fun x i => ((Combinatorics.Line.vertical v l).idxFun i).getD x) x = Sum.elim v ((fun x i => (l.idxFun i).getD x) x)
Result.autoException ::
Auto failed to find proof

Testing || QuasiIsoAt.quasiIso : ∀ {ι : Type u_1} {C : Type u} {inst : CategoryTheory.Category.{v, u} C}
  {inst_1 : CategoryTheory.Limits.HasZeroMorphisms C} {c : ComplexShape ι} {K L : HomologicalComplex C c} {f : K ⟶ L}
  {i : ι} {inst_2 : K.HasHomology i} {inst_3 : L.HasHomology i} [self : QuasiIsoAt f i],
  CategoryTheory.ShortComplex.QuasiIso ((HomologicalComplex.shortComplexFunctor C c i).map f)
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _ι:
  ;;   |_ι!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_ι!val!0| () _ι)
  ;; cardinality constraint:
  (forall ((x _ι)) (= x |_ι!val!0|))
  ;; -----------
  ;; universe for _CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C:
  ;;   _CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C!val!0 () _CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C)
  ;; cardinality constraint:
  (forall ((x _CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C))
          (= x
             _CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C!val!0))
  ;; -----------
  ;; universe for _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C:
  ;;   _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C!val!0 () _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C)
  ;; cardinality constraint:
  (forall ((x _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C))
          (= x _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C!val!0))
  ;; -----------
  ;; universe for _HomologicalComplex_C_c:
  ;;   _HomologicalComplex_C_c!val!1 _HomologicalComplex_C_c!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _HomologicalComplex_C_c!val!1 () _HomologicalComplex_C_c)
  (declare-fun _HomologicalComplex_C_c!val!0 () _HomologicalComplex_C_c)
  ;; cardinality constraint:
  (forall ((x _HomologicalComplex_C_c))
          (or (= x _HomologicalComplex_C_c!val!1)
              (= x _HomologicalComplex_C_c!val!0)))
  ;; -----------
  ;; universe for _CategoryTheory.ShortComplex_C:
  ;;   _CategoryTheory.ShortComplex_C!val!1 _CategoryTheory.ShortComplex_C!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _CategoryTheory.ShortComplex_C!val!1 () _CategoryTheory.ShortComplex_C)
  (declare-fun _CategoryTheory.ShortComplex_C!val!0 () _CategoryTheory.ShortComplex_C)
  ;; cardinality constraint:
  (forall ((x _CategoryTheory.ShortComplex_C))
          (or (= x _CategoryTheory.ShortComplex_C!val!1)
              (= x _CategoryTheory.ShortComplex_C!val!0)))
  ;; -----------
  ;; universe for _K___L:
  ;;   _K___L!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _K___L!val!0 () _K___L)
  ;; cardinality constraint:
  (forall ((x _K___L)) (= x _K___L!val!0))
  ;; -----------
  ;; universe for _HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L:
  ;;   _HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L!val!0 () _HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L)
  ;; cardinality constraint:
  (forall ((x _HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L))
          (= x
             _HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L!val!0))
  ;; -----------
  (define-fun valid_fact_2 () Bool
    (_fun_f_=>_QuasiIsoAt_f_i _f))
  (define-fun valid_fact_1 () Bool
    (_CategoryTheory.ShortComplex.HasHomology
  (_Prefunctor.obj (_CategoryTheory.Functor.toPrefunctor
                     (_HomologicalComplex.shortComplexFunctor_C_c _i))
                   _L)))
  (define-fun _K () _HomologicalComplex_C_c
    _HomologicalComplex_C_c!val!0)
  (define-fun valid_fact_3 () Bool
    (not (_CategoryTheory.ShortComplex.QuasiIso
       (_HomologicalComplex.shortComplexFunctor_C_c_i.map _f))))
  (define-fun _i () _ι
    |_ι!val!0|)
  (define-fun _f () _K___L
    _K___L!val!0)
  (define-fun valid_fact_0 () Bool
    (_CategoryTheory.ShortComplex.HasHomology
  (_Prefunctor.obj (_CategoryTheory.Functor.toPrefunctor
                     (_HomologicalComplex.shortComplexFunctor_C_c _i))
                   _K)))
  (define-fun _L () _HomologicalComplex_C_c
    _HomologicalComplex_C_c!val!1)
  (define-fun _CategoryTheory.Functor.toPrefunctor ((x!0
    _CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C)) _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C
    _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C!val!0)
  (define-fun _HomologicalComplex.shortComplexFunctor_C_c ((x!0 _ι)) _CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C
    _CategoryTheory.Functor_HomologicalComplex_C_c_CategoryTheory.ShortComplex_C!val!0)
  (define-fun _fun_f_=>_QuasiIsoAt_f_i ((x!0 _K___L)) Bool
    true)
  (define-fun _Prefunctor.obj ((x!0
    _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C)
   (x!1 _HomologicalComplex_C_c)) _CategoryTheory.ShortComplex_C
    (ite (and (= x!0
                 _HomologicalComplex_C_c__q_CategoryTheory.ShortComplex_C!val!0)
              (= x!1 _HomologicalComplex_C_c!val!1))
      _CategoryTheory.ShortComplex_C!val!1
      _CategoryTheory.ShortComplex_C!val!0))
  (define-fun _HomologicalComplex.shortComplexFunctor_C_c_i.map ((x!0 _K___L)) _HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L
    _HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L!val!0)
  (define-fun _CategoryTheory.ShortComplex.HasHomology ((x!0
    _CategoryTheory.ShortComplex_C)) Bool
    true)
  (define-fun _CategoryTheory.ShortComplex.QuasiIso ((x!0
    _HomologicalComplex.shortComplexFunctor_C_c_i.obj_K___HomologicalComplex.shortComplexFunctor_C_c_i.obj_L)) Bool
    false)
)


Testing || Continuous.locallyIntegrable : ∀ {X : Type u_1} {E : Type u_3} [inst : MeasurableSpace X] [inst_1 : TopologicalSpace X] [inst_2 : NormedAddCommGroup E]
  {f : X → E} {μ : MeasureTheory.Measure X} [inst_3 : OpensMeasurableSpace X]
  [inst_4 : MeasureTheory.IsLocallyFiniteMeasure μ] [inst_5 : SecondCountableTopologyEither X E],
  Continuous f → MeasureTheory.LocallyIntegrable f μ
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.simplicialToCosimplicialAugmented_map_right : ∀ (C : Type u) [inst : CategoryTheory.Category.{v, u} C] {X Y : (CategoryTheory.SimplicialObject.Augmented C)ᵒᵖ}
  (f : X ⟶ Y),
  ((CategoryTheory.simplicialToCosimplicialAugmented C).map f).right = CategoryTheory.NatTrans.rightOp f.unop.left
Result.autoException ::
Auto failed to find proof

Testing || contDiffOn_succ_iff_fderiv_apply : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {D : Type uD} [inst_1 : NormedAddCommGroup D]
  [inst_2 : NormedSpace 𝕜 D] {E : Type uE} [inst_3 : NormedAddCommGroup E] [inst_4 : NormedSpace 𝕜 E]
  [inst_5 : CompleteSpace 𝕜] [inst_6 : FiniteDimensional 𝕜 D] {n : ℕ} {f : D → E} {s : Set D},
  UniqueDiffOn 𝕜 s →
    (ContDiffOn 𝕜 (↑(n + 1)) f s ↔
      DifferentiableOn 𝕜 f s ∧ ∀ (y : D), ContDiffOn 𝕜 (↑n) (fun x => (fderivWithin 𝕜 f s x) y) s)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `ContDiffOn cifvar_13
  (cifvar_7 cifvar_9) (fun x => cifvar_16 (cifvar_17 cifvar_3 x) y) cifvar_3`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || Finset.insert_erase : ∀ {α : Type u_1} [inst : DecidableEq α] {s : Finset α} {a : α}, a ∈ s → insert a (s.erase a) = s
Result.success

Testing || PartENat.lt_add_one_iff_lt : ∀ {x y : PartENat}, x ≠ ⊤ → (x < y + 1 ↔ x ≤ y)
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.ShortComplex.Homotopy.refl_h₀ : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] [inst_1 : CategoryTheory.Preadditive C]
  {S₁ S₂ : CategoryTheory.ShortComplex C} (φ : S₁ ⟶ S₂), (CategoryTheory.ShortComplex.Homotopy.refl φ).h₀ = 0
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _CategoryTheory.ShortComplex.Homotopy_φ_φ:
  ;;   |_CategoryTheory.ShortComplex.Homotopy_φ_φ!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_CategoryTheory.ShortComplex.Homotopy_φ_φ!val!0| () _CategoryTheory.ShortComplex.Homotopy_φ_φ)
  ;; cardinality constraint:
  (forall ((x _CategoryTheory.ShortComplex.Homotopy_φ_φ))
          (= x |_CategoryTheory.ShortComplex.Homotopy_φ_φ!val!0|))
  ;; -----------
  ;; universe for _S₁.X₁___S₂.X₁:
  ;;   |_S₁.X₁___S₂.X₁!val!1| |_S₁.X₁___S₂.X₁!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_S₁.X₁___S₂.X₁!val!1| () _S₁.X₁___S₂.X₁)
  (declare-fun |_S₁.X₁___S₂.X₁!val!0| () _S₁.X₁___S₂.X₁)
  ;; cardinality constraint:
  (forall ((x _S₁.X₁___S₂.X₁))
          (or (= x |_S₁.X₁___S₂.X₁!val!1|)
              (= x |_S₁.X₁___S₂.X₁!val!0|)))
  ;; -----------
  (define-fun |_CategoryTheory.ShortComplex.Homotopy.refl_φ| () _CategoryTheory.ShortComplex.Homotopy_φ_φ
    |_CategoryTheory.ShortComplex.Homotopy_φ_φ!val!0|)
  (define-fun valid_fact_0 () Bool
    (not (= (|_CategoryTheory.ShortComplex.Homotopy.h₀|
          |_CategoryTheory.ShortComplex.Homotopy.refl_φ|)
        _0_)))
  (define-fun _0_ () _S₁.X₁___S₂.X₁
    |_S₁.X₁___S₂.X₁!val!1|)
  (define-fun |_CategoryTheory.ShortComplex.Homotopy.h₀| ((x!0
    _CategoryTheory.ShortComplex.Homotopy_φ_φ)) _S₁.X₁___S₂.X₁
    |_S₁.X₁___S₂.X₁!val!0|)
)


Testing || NonUnitalContinuousFunctionalCalculus.predicate_zero : ∀ (R : Type u_1) {A : Type u_2} {p : outParam (A → Prop)} {inst : CommSemiring R} {inst_1 : Nontrivial R}
  {inst_2 : StarRing R} {inst_3 : MetricSpace R} {inst_4 : TopologicalSemiring R} {inst_5 : ContinuousStar R}
  {inst_6 : NonUnitalRing A} {inst_7 : StarRing A} {inst_8 : TopologicalSpace A} {inst_9 : Module R A}
  {inst_10 : IsScalarTower R A A} {inst_11 : SMulCommClass R A A} [self : NonUnitalContinuousFunctionalCalculus R p],
  p 0
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: outParam (A → Prop) is not a `∀`

Testing || Filter.Germ.instAddMonoid.proof_3 : ∀ {α : Type u_2} {l : Filter α} {M : Type u_1} [inst : AddMonoid M] (x x_1 : α → M), ↑(x + x_1) = ↑(x + x_1)
Result.success

Testing || TensorProduct.SMul.aux_of : ∀ {R : Type u_1} [inst : CommSemiring R] {M : Type u_4} {N : Type u_5} [inst_1 : AddCommMonoid M]
  [inst_2 : AddCommMonoid N] [inst_3 : Module R M] [inst_4 : Module R N] {R' : Type u_10} [inst_5 : SMul R' M] (r : R')
  (m : M) (n : N), (TensorProduct.SMul.aux r) (FreeAddMonoid.of (m, n)) = (r • m) ⊗ₜ[R] n
Result.autoException ::
Auto failed to find proof

Testing || CategoryTheory.ComposableArrows.ext₁ : ∀ {C : Type u_1} [inst : CategoryTheory.Category.{u_2, u_1} C] {F G : CategoryTheory.ComposableArrows C 1}
  (left : F.left = G.left) (right : F.right = G.right),
  F.hom =
      CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom left)
        (CategoryTheory.CategoryStruct.comp G.hom (CategoryTheory.eqToHom ⋯)) →
    F = G
Result.autoException ::
Auto failed to find proof

Testing || Fin.Ioo_eq_finset_subtype : ∀ {n : ℕ} (a b : Fin n), Finset.Ioo a b = Finset.fin n (Finset.Ioo ↑a ↑b)
Result.autoException ::
Auto failed to find proof

Testing || Pi.ringHom_injective : ∀ {I : Type u} {f : I → Type v} {γ : Type w} [inst : Nonempty I] [inst : (i : I) → NonAssocSemiring (f i)]
  [inst_1 : NonAssocSemiring γ] (g : (i : I) → γ →+* f i),
  (∀ (i : I), Function.Injective ⇑(g i)) → Function.Injective ⇑(Pi.ringHom g)
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `inst✝¹ x_0`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || MeasureTheory.mul_meas_ge_le_pow_eLpNorm : ∀ {α : Type u_1} {E : Type u_2} {m0 : MeasurableSpace α} [inst : NormedAddCommGroup E] {p : ENNReal}
  (μ : MeasureTheory.Measure α) {f : α → E},
  p ≠ 0 →
    p ≠ ⊤ →
      MeasureTheory.AEStronglyMeasurable f μ →
        ∀ (ε : ENNReal), ε * μ {x | ε ≤ ↑‖f x‖₊ ^ p.toReal} ≤ MeasureTheory.eLpNorm f p μ ^ p.toReal
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `{x |
  cifvar_7 ε (cifvar_12 (cifvar_25 (cifvar_26 (cifvar_27 x))) (cifvar_14 x_0))}`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || Orientation.map_symm : ∀ {R : Type u_1} [inst : StrictOrderedCommSemiring R] {M : Type u_2} [inst_1 : AddCommMonoid M] [inst_2 : Module R M]
  {N : Type u_3} [inst_3 : AddCommMonoid N] [inst_4 : Module R N] (ι : Type u_4) (e : M ≃ₗ[R] N),
  (Orientation.map ι e).symm = Orientation.map ι e.symm
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _M____R__N:
  ;;   _M____R__N!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _M____R__N!val!0 () _M____R__N)
  ;; cardinality constraint:
  (forall ((x _M____R__N)) (= x _M____R__N!val!0))
  ;; -----------
  ;; universe for _Module.Ray_R_M___^ι____R__R___Module.Ray_R_N___^ι____R__R:
  ;;   |_Module.Ray_R_M___^ι____R__R___Module.Ray_R_N___^ι____R__R!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Module.Ray_R_M___^ι____R__R___Module.Ray_R_N___^ι____R__R!val!0| () _Module.Ray_R_M___^ι____R__R___Module.Ray_R_N___^ι____R__R)
  ;; cardinality constraint:
  (forall ((x _Module.Ray_R_M___^ι____R__R___Module.Ray_R_N___^ι____R__R))
          (= x
             |_Module.Ray_R_M___^ι____R__R___Module.Ray_R_N___^ι____R__R!val!0|))
  ;; -----------
  ;; universe for _Module.Ray_R_N___^ι____R__R___Module.Ray_R_M___^ι____R__R:
  ;;   |_Module.Ray_R_N___^ι____R__R___Module.Ray_R_M___^ι____R__R!val!0| |_Module.Ray_R_N___^ι____R__R___Module.Ray_R_M___^ι____R__R!val!1| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Module.Ray_R_N___^ι____R__R___Module.Ray_R_M___^ι____R__R!val!0| () _Module.Ray_R_N___^ι____R__R___Module.Ray_R_M___^ι____R__R)
  (declare-fun |_Module.Ray_R_N___^ι____R__R___Module.Ray_R_M___^ι____R__R!val!1| () _Module.Ray_R_N___^ι____R__R___Module.Ray_R_M___^ι____R__R)
  ;; cardinality constraint:
  (forall ((x _Module.Ray_R_N___^ι____R__R___Module.Ray_R_M___^ι____R__R))
          (or (= x
                 |_Module.Ray_R_N___^ι____R__R___Module.Ray_R_M___^ι____R__R!val!0|)
              (= x
                 |_Module.Ray_R_N___^ι____R__R___Module.Ray_R_M___^ι____R__R!val!1|)))
  ;; -----------
  ;; universe for _N____R__M:
  ;;   _N____R__M!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _N____R__M!val!0 () _N____R__M)
  ;; cardinality constraint:
  (forall ((x _N____R__M)) (= x _N____R__M!val!0))
  ;; -----------
  (define-fun valid_fact_0 () Bool
    (not (= (_Equiv.symm (|_Orientation.map_ι| _e))
        (|_Orientation.map_ι_0| (_LinearEquiv.symm _e)))))
  (define-fun _e () _M____R__N
    _M____R__N!val!0)
  (define-fun _LinearEquiv.symm ((x!0 _M____R__N)) _N____R__M
    _N____R__M!val!0)
  (define-fun |_Orientation.map_ι_0| ((x!0 _N____R__M)) _Module.Ray_R_N___^ι____R__R___Module.Ray_R_M___^ι____R__R
    |_Module.Ray_R_N___^ι____R__R___Module.Ray_R_M___^ι____R__R!val!1|)
  (define-fun |_Orientation.map_ι| ((x!0 _M____R__N)) _Module.Ray_R_M___^ι____R__R___Module.Ray_R_N___^ι____R__R
    |_Module.Ray_R_M___^ι____R__R___Module.Ray_R_N___^ι____R__R!val!0|)
  (define-fun _Equiv.symm ((x!0
    _Module.Ray_R_M___^ι____R__R___Module.Ray_R_N___^ι____R__R)) _Module.Ray_R_N___^ι____R__R___Module.Ray_R_M___^ι____R__R
    |_Module.Ray_R_N___^ι____R__R___Module.Ray_R_M___^ι____R__R!val!0|)
)


Testing || TopologicalSpace.Opens.map_eq : ∀ {X Y : TopCat} (f g : X ⟶ Y), f = g → TopologicalSpace.Opens.map f = TopologicalSpace.Opens.map g
Result.success

Testing || IsometryEquiv.surjective : ∀ {α : Type u} {β : Type v} [inst : PseudoEMetricSpace α] [inst_1 : PseudoEMetricSpace β] (h : α ≃ᵢ β),
  Function.Surjective ⇑h
Result.autoException ::
Monomorphization failed because currently the procedure cannot deal with expression `Function.Surjective
  (cifvar_4 x_0)`.
This is because it contains free variables and has subterms possessing at least one of the following features
· Type argument with free variables, e.g. `@Fin.add (n + 2) a b`
· λ binders whose type contain free variables, e.g. `fun (x : a) => x` where `a` is a free variable
· (TODO)

Testing || hasMFDerivWithinAt_extChartAt : ∀ {𝕜 : Type u_1} [inst : NontriviallyNormedField 𝕜] {E : Type u_2} [inst_1 : NormedAddCommGroup E]
  [inst_2 : NormedSpace 𝕜 E] {H : Type u_3} [inst_3 : TopologicalSpace H] {I : ModelWithCorners 𝕜 E H} {M : Type u_4}
  [inst_4 : TopologicalSpace M] [inst_5 : ChartedSpace H M] [inst_6 : SmoothManifoldWithCorners I M] {s : Set M}
  {x y : M},
  y ∈ (chartAt H x).source →
    HasMFDerivWithinAt I (modelWithCornersSelf 𝕜 E) (↑(extChartAt I x)) s y (mfderiv I I (↑(chartAt H x)) y)
Result.success

Testing || AddHom.op.proof_4 : ∀ {M : Type u_1} {N : Type u_2} [inst : Add M] [inst_1 : Add N] (x : AddHom Mᵃᵒᵖ Nᵃᵒᵖ),
  (fun f => { toFun := AddOpposite.op ∘ ⇑f ∘ AddOpposite.unop, map_add' := ⋯ })
      ((fun f => { toFun := AddOpposite.unop ∘ ⇑f ∘ AddOpposite.op, map_add' := ⋯ }) x) =
    (fun f => { toFun := AddOpposite.op ∘ ⇑f ∘ AddOpposite.unop, map_add' := ⋯ })
      ((fun f => { toFun := AddOpposite.unop ∘ ⇑f ∘ AddOpposite.op, map_add' := ⋯ }) x)
Result.autoException ::
Auto.Monomorphization.ConstInst.ofExpr? :: Function.Injective AddOpposite.unop is not a `∀`

Testing || CategoryTheory.Comonad.cofree_obj_A : ∀ {C : Type u₁} [inst : CategoryTheory.Category.{v₁, u₁} C] (G : CategoryTheory.Comonad C) (X : C),
  (G.cofree.obj X).A = G.obj X
Result.autoException ::
Auto failed to find proof

Testing || Matroid.ground_finite : ∀ {α : Type u_1} (M : Matroid α) [inst : M.Finite], M.E.Finite
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Matroid_α:
  ;;   |_Matroid_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Matroid_α!val!0| () _Matroid_α)
  ;; cardinality constraint:
  (forall ((x _Matroid_α)) (= x |_Matroid_α!val!0|))
  ;; -----------
  ;; universe for _Set_α:
  ;;   |_Set_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_α!val!0| () _Set_α)
  ;; cardinality constraint:
  (forall ((x _Set_α)) (= x |_Set_α!val!0|))
  ;; -----------
  (define-fun _M () _Matroid_α
    |_Matroid_α!val!0|)
  (define-fun valid_fact_0 () Bool
    (_Matroid.Finite _M))
  (define-fun valid_fact_1 () Bool
    (not (_Set.Finite (_Matroid.E _M))))
  (define-fun _Set.Finite ((x!0 _Set_α)) Bool
    false)
  (define-fun _Matroid.Finite ((x!0 _Matroid_α)) Bool
    true)
  (define-fun _Matroid.E ((x!0 _Matroid_α)) _Set_α
    |_Set_α!val!0|)
)


Testing || Nat.testBit_and : ∀ (x y i : ℕ), (x &&& y).testBit i = (x.testBit i && y.testBit i)
Result.autoException ::
Auto failed to find proof

Testing || Function.support_comp_eq_preimage : ∀ {α : Type u_1} {β : Type u_2} {M : Type u_5} [inst : Zero M] (g : β → M) (f : α → β),
  Function.support (g ∘ f) = f ⁻¹' Function.support g
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _Set_α:
  ;;   |_Set_α!val!1| |_Set_α!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_α!val!1| () _Set_α)
  (declare-fun |_Set_α!val!0| () _Set_α)
  ;; cardinality constraint:
  (forall ((x _Set_α)) (or (= x |_Set_α!val!1|) (= x |_Set_α!val!0|)))
  ;; -----------
  ;; universe for _Set_β:
  ;;   |_Set_β!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Set_β!val!0| () _Set_β)
  ;; cardinality constraint:
  (forall ((x _Set_β)) (= x |_Set_β!val!0|))
  ;; -----------
  (define-fun _Function.support_g___f () _Set_α
    |_Set_α!val!0|)
  (define-fun valid_fact_0 () Bool
    (not (= _Function.support_g___f (_Set.preimage_f _Function.support_g))))
  (define-fun _Function.support_g () _Set_β
    |_Set_β!val!0|)
  (define-fun _Set.preimage_f ((x!0 _Set_β)) _Set_α
    |_Set_α!val!1|)
)


Testing || DFinsupp.lapply_comp_lsingle_of_ne : ∀ {ι : Type u_1} {R : Type u_2} {M : ι → Type u_4} [inst : Semiring R] [inst_1 : (i : ι) → AddCommMonoid (M i)]
  [inst_2 : (i : ι) → Module R (M i)] [inst_3 : DecidableEq ι] (i i' : ι),
  i ≠ i' → DFinsupp.lapply i ∘ₗ DFinsupp.lsingle i' = 0
Result.autoException ::
Auto.Solver.SMT.getSexp :: Malformed (prefix of) input (
  ;; universe for _ι:
  ;;   |_ι!val!1| |_ι!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_ι!val!1| () _ι)
  (declare-fun |_ι!val!0| () _ι)
  ;; cardinality constraint:
  (forall ((x _ι)) (or (= x |_ι!val!1|) (= x |_ι!val!0|)))
  ;; -----------
  ;; universe for _Π₀__i___ι___M_i____R__M_i:
  ;;   |_Π₀__i___ι___M_i____R__M_i!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_Π₀__i___ι___M_i____R__M_i!val!0| () _Π₀__i___ι___M_i____R__M_i)
  ;; cardinality constraint:
  (forall ((x _Π₀__i___ι___M_i____R__M_i))
          (= x |_Π₀__i___ι___M_i____R__M_i!val!0|))
  ;; -----------
  ;; universe for _M_i_____R__Π₀__i___ι___M_i:
  ;;   |_M_i_____R__Π₀__i___ι___M_i!val!0| 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun |_M_i_____R__Π₀__i___ι___M_i!val!0| () _M_i_____R__Π₀__i___ι___M_i)
  ;; cardinality constraint:
  (forall ((x _M_i_____R__Π₀__i___ι___M_i))
          (= x |_M_i_____R__Π₀__i___ι___M_i!val!0|))
  ;; -----------
  ;; universe for _M_i_____R__M_i:
  ;;   _M_i_____R__M_i!val!1 _M_i_____R__M_i!val!0 
  ;; -----------
  ;; definitions for universe elements:
  (declare-fun _M_i_____R__M_i!val!1 () _M_i_____R__M_i)
  (declare-fun _M_i_____R__M_i!val!0 () _M_i_____R__M_i)
  ;; cardinality constraint:
  (forall ((x _M_i_____R__M_i))
          (or (= x _M_i_____R__M_i!val!1) (= x _M_i_____R__M_i!val!0)))
  ;; -----------
  (define-fun _0_ () _M_i_____R__M_i
    _M_i_____R__M_i!val!1)
  (define-fun valid_fact_1 () Bool
    (not (= (_LinearMap.comp _DFinsupp.lapply_i _DFinsupp.lsingle_i_) _0_)))
  (define-fun _i_ () _ι
    |_ι!val!1|)
  (define-fun _DFinsupp.lsingle_i_ () _M_i_____R__Π₀__i___ι___M_i
    |_M_i_____R__Π₀__i___ι___M_i!val!0|)
  (define-fun _i () _ι
    |_ι!val!0|)
  (define-fun valid_fact_0 () Bool
    (not (= _i _i_)))
  (define-fun _DFinsupp.lapply_i () _Π₀__i___ι___M_i____R__M_i
    |_Π₀__i___ι___M_i____R__M_i!val!0|)
  (define-fun _LinearMap.comp ((x!0 _Π₀__i___ι___M_i____R__M_i)
   (x!1 _M_i_____R__Π₀__i___ι___M_i)) _M_i_____R__M_i
    _M_i_____R__M_i!val!0)
)


Elapsed time: 74241 ms
